"""
Tests for WebSocket Authentication
Verifies JWT validation, thread access, and rate limiting
"""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from uuid import uuid4

from fastapi.testclient import TestClient
from fastapi.websockets import WebSocket


@pytest.fixture
def mock_thread():
    """Mock thread data"""
    return {
        "id": uuid4(),
        "tenant_id": "tenant123",
        "scope_type": "field",
        "scope_id": "field456",
        "is_archived": False,
    }


@pytest.fixture
def mock_participant():
    """Mock participant data"""
    return {
        "id": uuid4(),
        "tenant_id": "tenant123",
        "thread_id": None,  # Will be set in test
        "user_id": "user123",
    }


@pytest.fixture
def valid_token():
    """Valid JWT token for testing"""
    # This would be generated by the JWT module in actual tests
    return "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwidGlkIjoidGVuYW50MTIzIn0.signature"


class TestWebSocketAuthentication:
    """Test WebSocket authentication flow"""

    @pytest.mark.asyncio
    async def test_connection_without_token_rejected(self, client):
        """Connection without token should be rejected with code 4001"""
        thread_id = str(uuid4())

        with pytest.raises(Exception) as exc_info:
            async with client.websocket_connect(f"/ws/chat/{thread_id}"):
                pass

        # WebSocket should close with authentication required
        assert "4001" in str(exc_info.value) or "Authentication" in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_connection_with_invalid_token_rejected(self, client):
        """Connection with invalid token should be rejected"""
        thread_id = str(uuid4())
        invalid_token = "invalid.token.here"

        with pytest.raises(Exception) as exc_info:
            async with client.websocket_connect(
                f"/ws/chat/{thread_id}?token={invalid_token}"
            ):
                pass

        assert "4001" in str(exc_info.value) or "Invalid" in str(exc_info.value)

    @pytest.mark.asyncio
    @patch("apps.services.field-chat.src.main.validate_websocket_token")
    @patch("apps.services.field-chat.src.main.verify_thread_access")
    async def test_valid_connection_accepted(
        self, mock_verify_access, mock_validate_token, client, valid_token, mock_thread
    ):
        """Valid token and participant should connect successfully"""
        thread_id = str(mock_thread["id"])

        # Mock successful authentication
        mock_validate_token.return_value = {
            "sub": "user123",
            "tid": "tenant123",
        }
        mock_verify_access.return_value = (True, None)

        async with client.websocket_connect(
            f"/ws/chat/{thread_id}?token={valid_token}"
        ) as websocket:
            # Should receive connection confirmation
            data = await websocket.receive_json()
            assert data["type"] == "connected"
            assert data["user_id"] == "user123"
            assert data["thread_id"] == thread_id

    @pytest.mark.asyncio
    @patch("apps.services.field-chat.src.main.validate_websocket_token")
    @patch("apps.services.field-chat.src.main.verify_thread_access")
    async def test_non_participant_rejected(
        self, mock_verify_access, mock_validate_token, client, valid_token
    ):
        """User who is not a participant should be rejected"""
        thread_id = str(uuid4())

        mock_validate_token.return_value = {
            "sub": "user123",
            "tid": "tenant123",
        }
        # User is not a participant
        mock_verify_access.return_value = (
            False,
            "Access denied: not a participant in this thread",
        )

        with pytest.raises(Exception) as exc_info:
            async with client.websocket_connect(
                f"/ws/chat/{thread_id}?token={valid_token}"
            ):
                pass

        assert "4003" in str(exc_info.value) or "Access denied" in str(exc_info.value)


class TestWebSocketRateLimiting:
    """Test WebSocket rate limiting"""

    @pytest.mark.asyncio
    @patch("apps.services.field-chat.src.main.validate_websocket_token")
    @patch("apps.services.field-chat.src.main.verify_thread_access")
    async def test_rate_limit_burst_protection(
        self, mock_verify_access, mock_validate_token, client, valid_token
    ):
        """Sending too many messages rapidly should trigger rate limit"""
        thread_id = str(uuid4())

        mock_validate_token.return_value = {"sub": "user123", "tid": "tenant123"}
        mock_verify_access.return_value = (True, None)

        async with client.websocket_connect(
            f"/ws/chat/{thread_id}?token={valid_token}"
        ) as websocket:
            # Receive connection confirmation
            await websocket.receive_json()

            # Send messages rapidly (burst limit is 10)
            rate_limited = False
            for i in range(15):
                await websocket.send_text(f"message {i}")
                response = await websocket.receive_json()

                if response.get("type") == "error" and response.get("error") == "rate_limit_exceeded":
                    rate_limited = True
                    break

            assert rate_limited, "Rate limit should have been triggered"

    @pytest.mark.asyncio
    @patch("apps.services.field-chat.src.main.validate_websocket_token")
    @patch("apps.services.field-chat.src.main.verify_thread_access")
    async def test_ping_pong_works(
        self, mock_verify_access, mock_validate_token, client, valid_token
    ):
        """Ping messages should receive pong response"""
        thread_id = str(uuid4())

        mock_validate_token.return_value = {"sub": "user123", "tid": "tenant123"}
        mock_verify_access.return_value = (True, None)

        async with client.websocket_connect(
            f"/ws/chat/{thread_id}?token={valid_token}"
        ) as websocket:
            # Receive connection confirmation
            await websocket.receive_json()

            # Send ping
            await websocket.send_text("ping")
            response = await websocket.receive_json()

            assert response["type"] == "pong"
            assert "timestamp" in response


class TestThreadAccessVerification:
    """Test thread access verification logic"""

    @pytest.mark.asyncio
    async def test_verify_thread_access_with_participant(self, mock_thread, mock_participant):
        """User who is a participant should have access"""
        from apps.services.field-chat.src.main import verify_thread_access
        from apps.services.field-chat.src.models import ChatThread, ChatParticipant

        thread_id = mock_thread["id"]
        tenant_id = mock_thread["tenant_id"]
        user_id = mock_participant["user_id"]

        with patch.object(ChatThread, "get_or_none", return_value=mock_thread), \
             patch.object(ChatParticipant, "get_or_none", return_value=mock_participant):

            has_access, error = await verify_thread_access(thread_id, tenant_id, user_id)

            assert has_access is True
            assert error is None

    @pytest.mark.asyncio
    async def test_verify_thread_access_without_participant(self, mock_thread):
        """User who is not a participant should be denied"""
        from apps.services.field-chat.src.main import verify_thread_access
        from apps.services.field-chat.src.models import ChatThread, ChatParticipant

        thread_id = mock_thread["id"]
        tenant_id = mock_thread["tenant_id"]
        user_id = "other_user"

        with patch.object(ChatThread, "get_or_none", return_value=mock_thread), \
             patch.object(ChatParticipant, "get_or_none", return_value=None):

            has_access, error = await verify_thread_access(thread_id, tenant_id, user_id)

            assert has_access is False
            assert "not a participant" in error

    @pytest.mark.asyncio
    async def test_verify_thread_access_archived_thread(self, mock_thread):
        """Archived thread should be denied"""
        from apps.services.field-chat.src.main import verify_thread_access
        from apps.services.field-chat.src.models import ChatThread

        mock_thread["is_archived"] = True
        thread_id = mock_thread["id"]
        tenant_id = mock_thread["tenant_id"]
        user_id = "user123"

        with patch.object(ChatThread, "get_or_none", return_value=mock_thread):
            has_access, error = await verify_thread_access(thread_id, tenant_id, user_id)

            assert has_access is False
            assert "archived" in error.lower()


class TestWebSocketRateLimiter:
    """Test WebSocketRateLimiter class"""

    def test_rate_limiter_allows_within_limits(self):
        """Messages within limits should be allowed"""
        from apps.services.field-chat.src.main import WebSocketRateLimiter

        limiter = WebSocketRateLimiter(messages_per_minute=30, burst_limit=10)
        connection_id = "test_connection"

        # Send 5 messages (within burst limit of 10)
        for i in range(5):
            allowed, reason = limiter.check_rate_limit(connection_id)
            assert allowed is True
            assert reason is None

    def test_rate_limiter_blocks_burst(self):
        """Too many messages in short time should be blocked"""
        from apps.services.field-chat.src.main import WebSocketRateLimiter

        limiter = WebSocketRateLimiter(messages_per_minute=30, burst_limit=5)
        connection_id = "test_connection"

        # Send messages up to burst limit
        for i in range(5):
            allowed, _ = limiter.check_rate_limit(connection_id)
            assert allowed is True

        # Next message should be blocked (burst limit exceeded)
        allowed, reason = limiter.check_rate_limit(connection_id)
        assert allowed is False
        assert "burst" in reason.lower()

    def test_rate_limiter_cleanup(self):
        """Cleanup should remove connection data"""
        from apps.services.field-chat.src.main import WebSocketRateLimiter

        limiter = WebSocketRateLimiter()
        connection_id = "test_connection"

        # Generate some data
        limiter.check_rate_limit(connection_id)
        assert connection_id in limiter._message_timestamps

        # Cleanup
        limiter.cleanup(connection_id)
        assert connection_id not in limiter._message_timestamps


@pytest.fixture
def client():
    """FastAPI test client"""
    from apps.services.field-chat.src.main import app

    return TestClient(app)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
