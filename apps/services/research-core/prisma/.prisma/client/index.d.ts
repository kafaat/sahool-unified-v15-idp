
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Germplasm
 * 
 */
export type Germplasm = $Result.DefaultSelection<Prisma.$GermplasmPayload>
/**
 * Model SeedLot
 * 
 */
export type SeedLot = $Result.DefaultSelection<Prisma.$SeedLotPayload>
/**
 * Model Planting
 * 
 */
export type Planting = $Result.DefaultSelection<Prisma.$PlantingPayload>
/**
 * Model Experiment
 * 
 */
export type Experiment = $Result.DefaultSelection<Prisma.$ExperimentPayload>
/**
 * Model ResearchProtocol
 * 
 */
export type ResearchProtocol = $Result.DefaultSelection<Prisma.$ResearchProtocolPayload>
/**
 * Model ResearchPlot
 * 
 */
export type ResearchPlot = $Result.DefaultSelection<Prisma.$ResearchPlotPayload>
/**
 * Model Treatment
 * 
 */
export type Treatment = $Result.DefaultSelection<Prisma.$TreatmentPayload>
/**
 * Model ResearchDailyLog
 * 
 */
export type ResearchDailyLog = $Result.DefaultSelection<Prisma.$ResearchDailyLogPayload>
/**
 * Model LabSample
 * 
 */
export type LabSample = $Result.DefaultSelection<Prisma.$LabSamplePayload>
/**
 * Model DigitalSignature
 * 
 */
export type DigitalSignature = $Result.DefaultSelection<Prisma.$DigitalSignaturePayload>
/**
 * Model ExperimentCollaborator
 * 
 */
export type ExperimentCollaborator = $Result.DefaultSelection<Prisma.$ExperimentCollaboratorPayload>
/**
 * Model ExperimentAuditLog
 * 
 */
export type ExperimentAuditLog = $Result.DefaultSelection<Prisma.$ExperimentAuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const GermplasmType: {
  seed: 'seed',
  cutting: 'cutting',
  tissue: 'tissue',
  pollen: 'pollen',
  other: 'other'
};

export type GermplasmType = (typeof GermplasmType)[keyof typeof GermplasmType]


export const SeedQualityGrade: {
  certified: 'certified',
  foundation: 'foundation',
  registered: 'registered',
  breeder: 'breeder',
  commercial: 'commercial',
  farmer_saved: 'farmer_saved'
};

export type SeedQualityGrade = (typeof SeedQualityGrade)[keyof typeof SeedQualityGrade]


export const ExperimentStatus: {
  draft: 'draft',
  active: 'active',
  locked: 'locked',
  completed: 'completed',
  archived: 'archived'
};

export type ExperimentStatus = (typeof ExperimentStatus)[keyof typeof ExperimentStatus]


export const TreatmentType: {
  fertilizer: 'fertilizer',
  pesticide: 'pesticide',
  irrigation: 'irrigation',
  seed_variety: 'seed_variety',
  other: 'other'
};

export type TreatmentType = (typeof TreatmentType)[keyof typeof TreatmentType]


export const LogCategory: {
  observation: 'observation',
  measurement: 'measurement',
  treatment: 'treatment',
  harvest: 'harvest',
  weather: 'weather',
  pest: 'pest',
  planting: 'planting',
  germination: 'germination',
  other: 'other'
};

export type LogCategory = (typeof LogCategory)[keyof typeof LogCategory]


export const SampleType: {
  soil: 'soil',
  plant: 'plant',
  water: 'water',
  pest: 'pest',
  other: 'other'
};

export type SampleType = (typeof SampleType)[keyof typeof SampleType]

}

export type GermplasmType = $Enums.GermplasmType

export const GermplasmType: typeof $Enums.GermplasmType

export type SeedQualityGrade = $Enums.SeedQualityGrade

export const SeedQualityGrade: typeof $Enums.SeedQualityGrade

export type ExperimentStatus = $Enums.ExperimentStatus

export const ExperimentStatus: typeof $Enums.ExperimentStatus

export type TreatmentType = $Enums.TreatmentType

export const TreatmentType: typeof $Enums.TreatmentType

export type LogCategory = $Enums.LogCategory

export const LogCategory: typeof $Enums.LogCategory

export type SampleType = $Enums.SampleType

export const SampleType: typeof $Enums.SampleType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Germplasms
 * const germplasms = await prisma.germplasm.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Germplasms
   * const germplasms = await prisma.germplasm.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.germplasm`: Exposes CRUD operations for the **Germplasm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Germplasms
    * const germplasms = await prisma.germplasm.findMany()
    * ```
    */
  get germplasm(): Prisma.GermplasmDelegate<ExtArgs>;

  /**
   * `prisma.seedLot`: Exposes CRUD operations for the **SeedLot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeedLots
    * const seedLots = await prisma.seedLot.findMany()
    * ```
    */
  get seedLot(): Prisma.SeedLotDelegate<ExtArgs>;

  /**
   * `prisma.planting`: Exposes CRUD operations for the **Planting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plantings
    * const plantings = await prisma.planting.findMany()
    * ```
    */
  get planting(): Prisma.PlantingDelegate<ExtArgs>;

  /**
   * `prisma.experiment`: Exposes CRUD operations for the **Experiment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Experiments
    * const experiments = await prisma.experiment.findMany()
    * ```
    */
  get experiment(): Prisma.ExperimentDelegate<ExtArgs>;

  /**
   * `prisma.researchProtocol`: Exposes CRUD operations for the **ResearchProtocol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchProtocols
    * const researchProtocols = await prisma.researchProtocol.findMany()
    * ```
    */
  get researchProtocol(): Prisma.ResearchProtocolDelegate<ExtArgs>;

  /**
   * `prisma.researchPlot`: Exposes CRUD operations for the **ResearchPlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchPlots
    * const researchPlots = await prisma.researchPlot.findMany()
    * ```
    */
  get researchPlot(): Prisma.ResearchPlotDelegate<ExtArgs>;

  /**
   * `prisma.treatment`: Exposes CRUD operations for the **Treatment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Treatments
    * const treatments = await prisma.treatment.findMany()
    * ```
    */
  get treatment(): Prisma.TreatmentDelegate<ExtArgs>;

  /**
   * `prisma.researchDailyLog`: Exposes CRUD operations for the **ResearchDailyLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchDailyLogs
    * const researchDailyLogs = await prisma.researchDailyLog.findMany()
    * ```
    */
  get researchDailyLog(): Prisma.ResearchDailyLogDelegate<ExtArgs>;

  /**
   * `prisma.labSample`: Exposes CRUD operations for the **LabSample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabSamples
    * const labSamples = await prisma.labSample.findMany()
    * ```
    */
  get labSample(): Prisma.LabSampleDelegate<ExtArgs>;

  /**
   * `prisma.digitalSignature`: Exposes CRUD operations for the **DigitalSignature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DigitalSignatures
    * const digitalSignatures = await prisma.digitalSignature.findMany()
    * ```
    */
  get digitalSignature(): Prisma.DigitalSignatureDelegate<ExtArgs>;

  /**
   * `prisma.experimentCollaborator`: Exposes CRUD operations for the **ExperimentCollaborator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExperimentCollaborators
    * const experimentCollaborators = await prisma.experimentCollaborator.findMany()
    * ```
    */
  get experimentCollaborator(): Prisma.ExperimentCollaboratorDelegate<ExtArgs>;

  /**
   * `prisma.experimentAuditLog`: Exposes CRUD operations for the **ExperimentAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExperimentAuditLogs
    * const experimentAuditLogs = await prisma.experimentAuditLog.findMany()
    * ```
    */
  get experimentAuditLog(): Prisma.ExperimentAuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Germplasm: 'Germplasm',
    SeedLot: 'SeedLot',
    Planting: 'Planting',
    Experiment: 'Experiment',
    ResearchProtocol: 'ResearchProtocol',
    ResearchPlot: 'ResearchPlot',
    Treatment: 'Treatment',
    ResearchDailyLog: 'ResearchDailyLog',
    LabSample: 'LabSample',
    DigitalSignature: 'DigitalSignature',
    ExperimentCollaborator: 'ExperimentCollaborator',
    ExperimentAuditLog: 'ExperimentAuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "germplasm" | "seedLot" | "planting" | "experiment" | "researchProtocol" | "researchPlot" | "treatment" | "researchDailyLog" | "labSample" | "digitalSignature" | "experimentCollaborator" | "experimentAuditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Germplasm: {
        payload: Prisma.$GermplasmPayload<ExtArgs>
        fields: Prisma.GermplasmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GermplasmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GermplasmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload>
          }
          findFirst: {
            args: Prisma.GermplasmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GermplasmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload>
          }
          findMany: {
            args: Prisma.GermplasmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload>[]
          }
          create: {
            args: Prisma.GermplasmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload>
          }
          createMany: {
            args: Prisma.GermplasmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GermplasmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload>[]
          }
          delete: {
            args: Prisma.GermplasmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload>
          }
          update: {
            args: Prisma.GermplasmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload>
          }
          deleteMany: {
            args: Prisma.GermplasmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GermplasmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GermplasmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GermplasmPayload>
          }
          aggregate: {
            args: Prisma.GermplasmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGermplasm>
          }
          groupBy: {
            args: Prisma.GermplasmGroupByArgs<ExtArgs>
            result: $Utils.Optional<GermplasmGroupByOutputType>[]
          }
          count: {
            args: Prisma.GermplasmCountArgs<ExtArgs>
            result: $Utils.Optional<GermplasmCountAggregateOutputType> | number
          }
        }
      }
      SeedLot: {
        payload: Prisma.$SeedLotPayload<ExtArgs>
        fields: Prisma.SeedLotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeedLotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeedLotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload>
          }
          findFirst: {
            args: Prisma.SeedLotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeedLotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload>
          }
          findMany: {
            args: Prisma.SeedLotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload>[]
          }
          create: {
            args: Prisma.SeedLotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload>
          }
          createMany: {
            args: Prisma.SeedLotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeedLotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload>[]
          }
          delete: {
            args: Prisma.SeedLotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload>
          }
          update: {
            args: Prisma.SeedLotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload>
          }
          deleteMany: {
            args: Prisma.SeedLotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeedLotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeedLotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeedLotPayload>
          }
          aggregate: {
            args: Prisma.SeedLotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeedLot>
          }
          groupBy: {
            args: Prisma.SeedLotGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeedLotGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeedLotCountArgs<ExtArgs>
            result: $Utils.Optional<SeedLotCountAggregateOutputType> | number
          }
        }
      }
      Planting: {
        payload: Prisma.$PlantingPayload<ExtArgs>
        fields: Prisma.PlantingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload>
          }
          findFirst: {
            args: Prisma.PlantingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload>
          }
          findMany: {
            args: Prisma.PlantingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload>[]
          }
          create: {
            args: Prisma.PlantingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload>
          }
          createMany: {
            args: Prisma.PlantingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload>[]
          }
          delete: {
            args: Prisma.PlantingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload>
          }
          update: {
            args: Prisma.PlantingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload>
          }
          deleteMany: {
            args: Prisma.PlantingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlantingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantingPayload>
          }
          aggregate: {
            args: Prisma.PlantingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanting>
          }
          groupBy: {
            args: Prisma.PlantingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantingCountArgs<ExtArgs>
            result: $Utils.Optional<PlantingCountAggregateOutputType> | number
          }
        }
      }
      Experiment: {
        payload: Prisma.$ExperimentPayload<ExtArgs>
        fields: Prisma.ExperimentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExperimentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExperimentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload>
          }
          findFirst: {
            args: Prisma.ExperimentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExperimentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload>
          }
          findMany: {
            args: Prisma.ExperimentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload>[]
          }
          create: {
            args: Prisma.ExperimentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload>
          }
          createMany: {
            args: Prisma.ExperimentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExperimentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload>[]
          }
          delete: {
            args: Prisma.ExperimentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload>
          }
          update: {
            args: Prisma.ExperimentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload>
          }
          deleteMany: {
            args: Prisma.ExperimentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExperimentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExperimentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentPayload>
          }
          aggregate: {
            args: Prisma.ExperimentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperiment>
          }
          groupBy: {
            args: Prisma.ExperimentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperimentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExperimentCountArgs<ExtArgs>
            result: $Utils.Optional<ExperimentCountAggregateOutputType> | number
          }
        }
      }
      ResearchProtocol: {
        payload: Prisma.$ResearchProtocolPayload<ExtArgs>
        fields: Prisma.ResearchProtocolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchProtocolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchProtocolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload>
          }
          findFirst: {
            args: Prisma.ResearchProtocolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchProtocolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload>
          }
          findMany: {
            args: Prisma.ResearchProtocolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload>[]
          }
          create: {
            args: Prisma.ResearchProtocolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload>
          }
          createMany: {
            args: Prisma.ResearchProtocolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchProtocolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload>[]
          }
          delete: {
            args: Prisma.ResearchProtocolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload>
          }
          update: {
            args: Prisma.ResearchProtocolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload>
          }
          deleteMany: {
            args: Prisma.ResearchProtocolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchProtocolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResearchProtocolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchProtocolPayload>
          }
          aggregate: {
            args: Prisma.ResearchProtocolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchProtocol>
          }
          groupBy: {
            args: Prisma.ResearchProtocolGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchProtocolGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchProtocolCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchProtocolCountAggregateOutputType> | number
          }
        }
      }
      ResearchPlot: {
        payload: Prisma.$ResearchPlotPayload<ExtArgs>
        fields: Prisma.ResearchPlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchPlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchPlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload>
          }
          findFirst: {
            args: Prisma.ResearchPlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchPlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload>
          }
          findMany: {
            args: Prisma.ResearchPlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload>[]
          }
          create: {
            args: Prisma.ResearchPlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload>
          }
          createMany: {
            args: Prisma.ResearchPlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchPlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload>[]
          }
          delete: {
            args: Prisma.ResearchPlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload>
          }
          update: {
            args: Prisma.ResearchPlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload>
          }
          deleteMany: {
            args: Prisma.ResearchPlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchPlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResearchPlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchPlotPayload>
          }
          aggregate: {
            args: Prisma.ResearchPlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchPlot>
          }
          groupBy: {
            args: Prisma.ResearchPlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchPlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchPlotCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchPlotCountAggregateOutputType> | number
          }
        }
      }
      Treatment: {
        payload: Prisma.$TreatmentPayload<ExtArgs>
        fields: Prisma.TreatmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreatmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreatmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          findFirst: {
            args: Prisma.TreatmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreatmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          findMany: {
            args: Prisma.TreatmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>[]
          }
          create: {
            args: Prisma.TreatmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          createMany: {
            args: Prisma.TreatmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TreatmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>[]
          }
          delete: {
            args: Prisma.TreatmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          update: {
            args: Prisma.TreatmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          deleteMany: {
            args: Prisma.TreatmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreatmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TreatmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          aggregate: {
            args: Prisma.TreatmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreatment>
          }
          groupBy: {
            args: Prisma.TreatmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreatmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreatmentCountArgs<ExtArgs>
            result: $Utils.Optional<TreatmentCountAggregateOutputType> | number
          }
        }
      }
      ResearchDailyLog: {
        payload: Prisma.$ResearchDailyLogPayload<ExtArgs>
        fields: Prisma.ResearchDailyLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchDailyLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchDailyLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload>
          }
          findFirst: {
            args: Prisma.ResearchDailyLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchDailyLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload>
          }
          findMany: {
            args: Prisma.ResearchDailyLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload>[]
          }
          create: {
            args: Prisma.ResearchDailyLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload>
          }
          createMany: {
            args: Prisma.ResearchDailyLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchDailyLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload>[]
          }
          delete: {
            args: Prisma.ResearchDailyLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload>
          }
          update: {
            args: Prisma.ResearchDailyLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload>
          }
          deleteMany: {
            args: Prisma.ResearchDailyLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchDailyLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResearchDailyLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDailyLogPayload>
          }
          aggregate: {
            args: Prisma.ResearchDailyLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchDailyLog>
          }
          groupBy: {
            args: Prisma.ResearchDailyLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchDailyLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchDailyLogCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchDailyLogCountAggregateOutputType> | number
          }
        }
      }
      LabSample: {
        payload: Prisma.$LabSamplePayload<ExtArgs>
        fields: Prisma.LabSampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabSampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabSampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload>
          }
          findFirst: {
            args: Prisma.LabSampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabSampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload>
          }
          findMany: {
            args: Prisma.LabSampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload>[]
          }
          create: {
            args: Prisma.LabSampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload>
          }
          createMany: {
            args: Prisma.LabSampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabSampleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload>[]
          }
          delete: {
            args: Prisma.LabSampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload>
          }
          update: {
            args: Prisma.LabSampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload>
          }
          deleteMany: {
            args: Prisma.LabSampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabSampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabSampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabSamplePayload>
          }
          aggregate: {
            args: Prisma.LabSampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabSample>
          }
          groupBy: {
            args: Prisma.LabSampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabSampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabSampleCountArgs<ExtArgs>
            result: $Utils.Optional<LabSampleCountAggregateOutputType> | number
          }
        }
      }
      DigitalSignature: {
        payload: Prisma.$DigitalSignaturePayload<ExtArgs>
        fields: Prisma.DigitalSignatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DigitalSignatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DigitalSignatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload>
          }
          findFirst: {
            args: Prisma.DigitalSignatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DigitalSignatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload>
          }
          findMany: {
            args: Prisma.DigitalSignatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload>[]
          }
          create: {
            args: Prisma.DigitalSignatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload>
          }
          createMany: {
            args: Prisma.DigitalSignatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DigitalSignatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload>[]
          }
          delete: {
            args: Prisma.DigitalSignatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload>
          }
          update: {
            args: Prisma.DigitalSignatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload>
          }
          deleteMany: {
            args: Prisma.DigitalSignatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DigitalSignatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DigitalSignatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalSignaturePayload>
          }
          aggregate: {
            args: Prisma.DigitalSignatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDigitalSignature>
          }
          groupBy: {
            args: Prisma.DigitalSignatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<DigitalSignatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.DigitalSignatureCountArgs<ExtArgs>
            result: $Utils.Optional<DigitalSignatureCountAggregateOutputType> | number
          }
        }
      }
      ExperimentCollaborator: {
        payload: Prisma.$ExperimentCollaboratorPayload<ExtArgs>
        fields: Prisma.ExperimentCollaboratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExperimentCollaboratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExperimentCollaboratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload>
          }
          findFirst: {
            args: Prisma.ExperimentCollaboratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExperimentCollaboratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload>
          }
          findMany: {
            args: Prisma.ExperimentCollaboratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload>[]
          }
          create: {
            args: Prisma.ExperimentCollaboratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload>
          }
          createMany: {
            args: Prisma.ExperimentCollaboratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExperimentCollaboratorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload>[]
          }
          delete: {
            args: Prisma.ExperimentCollaboratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload>
          }
          update: {
            args: Prisma.ExperimentCollaboratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload>
          }
          deleteMany: {
            args: Prisma.ExperimentCollaboratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExperimentCollaboratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExperimentCollaboratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentCollaboratorPayload>
          }
          aggregate: {
            args: Prisma.ExperimentCollaboratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperimentCollaborator>
          }
          groupBy: {
            args: Prisma.ExperimentCollaboratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperimentCollaboratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExperimentCollaboratorCountArgs<ExtArgs>
            result: $Utils.Optional<ExperimentCollaboratorCountAggregateOutputType> | number
          }
        }
      }
      ExperimentAuditLog: {
        payload: Prisma.$ExperimentAuditLogPayload<ExtArgs>
        fields: Prisma.ExperimentAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExperimentAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExperimentAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload>
          }
          findFirst: {
            args: Prisma.ExperimentAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExperimentAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload>
          }
          findMany: {
            args: Prisma.ExperimentAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload>[]
          }
          create: {
            args: Prisma.ExperimentAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload>
          }
          createMany: {
            args: Prisma.ExperimentAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExperimentAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload>[]
          }
          delete: {
            args: Prisma.ExperimentAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload>
          }
          update: {
            args: Prisma.ExperimentAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.ExperimentAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExperimentAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExperimentAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperimentAuditLogPayload>
          }
          aggregate: {
            args: Prisma.ExperimentAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperimentAuditLog>
          }
          groupBy: {
            args: Prisma.ExperimentAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperimentAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExperimentAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<ExperimentAuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GermplasmCountOutputType
   */

  export type GermplasmCountOutputType = {
    seedLots: number
    plantings: number
  }

  export type GermplasmCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seedLots?: boolean | GermplasmCountOutputTypeCountSeedLotsArgs
    plantings?: boolean | GermplasmCountOutputTypeCountPlantingsArgs
  }

  // Custom InputTypes
  /**
   * GermplasmCountOutputType without action
   */
  export type GermplasmCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GermplasmCountOutputType
     */
    select?: GermplasmCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GermplasmCountOutputType without action
   */
  export type GermplasmCountOutputTypeCountSeedLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeedLotWhereInput
  }

  /**
   * GermplasmCountOutputType without action
   */
  export type GermplasmCountOutputTypeCountPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantingWhereInput
  }


  /**
   * Count Type SeedLotCountOutputType
   */

  export type SeedLotCountOutputType = {
    plantings: number
  }

  export type SeedLotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plantings?: boolean | SeedLotCountOutputTypeCountPlantingsArgs
  }

  // Custom InputTypes
  /**
   * SeedLotCountOutputType without action
   */
  export type SeedLotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLotCountOutputType
     */
    select?: SeedLotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeedLotCountOutputType without action
   */
  export type SeedLotCountOutputTypeCountPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantingWhereInput
  }


  /**
   * Count Type ExperimentCountOutputType
   */

  export type ExperimentCountOutputType = {
    protocols: number
    plots: number
    treatments: number
    logs: number
    samples: number
    collaborators: number
    auditLogs: number
    plantings: number
  }

  export type ExperimentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocols?: boolean | ExperimentCountOutputTypeCountProtocolsArgs
    plots?: boolean | ExperimentCountOutputTypeCountPlotsArgs
    treatments?: boolean | ExperimentCountOutputTypeCountTreatmentsArgs
    logs?: boolean | ExperimentCountOutputTypeCountLogsArgs
    samples?: boolean | ExperimentCountOutputTypeCountSamplesArgs
    collaborators?: boolean | ExperimentCountOutputTypeCountCollaboratorsArgs
    auditLogs?: boolean | ExperimentCountOutputTypeCountAuditLogsArgs
    plantings?: boolean | ExperimentCountOutputTypeCountPlantingsArgs
  }

  // Custom InputTypes
  /**
   * ExperimentCountOutputType without action
   */
  export type ExperimentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCountOutputType
     */
    select?: ExperimentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExperimentCountOutputType without action
   */
  export type ExperimentCountOutputTypeCountProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchProtocolWhereInput
  }

  /**
   * ExperimentCountOutputType without action
   */
  export type ExperimentCountOutputTypeCountPlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchPlotWhereInput
  }

  /**
   * ExperimentCountOutputType without action
   */
  export type ExperimentCountOutputTypeCountTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
  }

  /**
   * ExperimentCountOutputType without action
   */
  export type ExperimentCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchDailyLogWhereInput
  }

  /**
   * ExperimentCountOutputType without action
   */
  export type ExperimentCountOutputTypeCountSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabSampleWhereInput
  }

  /**
   * ExperimentCountOutputType without action
   */
  export type ExperimentCountOutputTypeCountCollaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperimentCollaboratorWhereInput
  }

  /**
   * ExperimentCountOutputType without action
   */
  export type ExperimentCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperimentAuditLogWhereInput
  }

  /**
   * ExperimentCountOutputType without action
   */
  export type ExperimentCountOutputTypeCountPlantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantingWhereInput
  }


  /**
   * Count Type ResearchPlotCountOutputType
   */

  export type ResearchPlotCountOutputType = {
    treatments: number
    logs: number
    samples: number
  }

  export type ResearchPlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    treatments?: boolean | ResearchPlotCountOutputTypeCountTreatmentsArgs
    logs?: boolean | ResearchPlotCountOutputTypeCountLogsArgs
    samples?: boolean | ResearchPlotCountOutputTypeCountSamplesArgs
  }

  // Custom InputTypes
  /**
   * ResearchPlotCountOutputType without action
   */
  export type ResearchPlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlotCountOutputType
     */
    select?: ResearchPlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResearchPlotCountOutputType without action
   */
  export type ResearchPlotCountOutputTypeCountTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
  }

  /**
   * ResearchPlotCountOutputType without action
   */
  export type ResearchPlotCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchDailyLogWhereInput
  }

  /**
   * ResearchPlotCountOutputType without action
   */
  export type ResearchPlotCountOutputTypeCountSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabSampleWhereInput
  }


  /**
   * Count Type TreatmentCountOutputType
   */

  export type TreatmentCountOutputType = {
    logs: number
  }

  export type TreatmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | TreatmentCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * TreatmentCountOutputType without action
   */
  export type TreatmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentCountOutputType
     */
    select?: TreatmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TreatmentCountOutputType without action
   */
  export type TreatmentCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchDailyLogWhereInput
  }


  /**
   * Count Type ResearchDailyLogCountOutputType
   */

  export type ResearchDailyLogCountOutputType = {
    samples: number
  }

  export type ResearchDailyLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    samples?: boolean | ResearchDailyLogCountOutputTypeCountSamplesArgs
  }

  // Custom InputTypes
  /**
   * ResearchDailyLogCountOutputType without action
   */
  export type ResearchDailyLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLogCountOutputType
     */
    select?: ResearchDailyLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResearchDailyLogCountOutputType without action
   */
  export type ResearchDailyLogCountOutputTypeCountSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabSampleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Germplasm
   */

  export type AggregateGermplasm = {
    _count: GermplasmCountAggregateOutputType | null
    _avg: GermplasmAvgAggregateOutputType | null
    _sum: GermplasmSumAggregateOutputType | null
    _min: GermplasmMinAggregateOutputType | null
    _max: GermplasmMaxAggregateOutputType | null
  }

  export type GermplasmAvgAggregateOutputType = {
    maturityDays: number | null
    storageTemperature: Decimal | null
    storageHumidity: Decimal | null
    quantityAvailable: Decimal | null
  }

  export type GermplasmSumAggregateOutputType = {
    maturityDays: number | null
    storageTemperature: Decimal | null
    storageHumidity: Decimal | null
    quantityAvailable: Decimal | null
  }

  export type GermplasmMinAggregateOutputType = {
    id: string | null
    accessionNumber: string | null
    commonName: string | null
    commonNameAr: string | null
    scientificName: string | null
    genus: string | null
    species: string | null
    subspecies: string | null
    cultivar: string | null
    variety: string | null
    pedigree: string | null
    type: $Enums.GermplasmType | null
    countryOfOrigin: string | null
    regionOfOrigin: string | null
    collectionSite: string | null
    collectionDate: Date | null
    collectedBy: string | null
    donorInstitution: string | null
    donorAccessionNumber: string | null
    growthHabit: string | null
    maturityDays: number | null
    yieldPotential: string | null
    droughtTolerance: string | null
    storageLocation: string | null
    storageConditions: string | null
    storageTemperature: Decimal | null
    storageHumidity: Decimal | null
    isAvailable: boolean | null
    quantityAvailable: Decimal | null
    quantityUnit: string | null
    description: string | null
    descriptionAr: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GermplasmMaxAggregateOutputType = {
    id: string | null
    accessionNumber: string | null
    commonName: string | null
    commonNameAr: string | null
    scientificName: string | null
    genus: string | null
    species: string | null
    subspecies: string | null
    cultivar: string | null
    variety: string | null
    pedigree: string | null
    type: $Enums.GermplasmType | null
    countryOfOrigin: string | null
    regionOfOrigin: string | null
    collectionSite: string | null
    collectionDate: Date | null
    collectedBy: string | null
    donorInstitution: string | null
    donorAccessionNumber: string | null
    growthHabit: string | null
    maturityDays: number | null
    yieldPotential: string | null
    droughtTolerance: string | null
    storageLocation: string | null
    storageConditions: string | null
    storageTemperature: Decimal | null
    storageHumidity: Decimal | null
    isAvailable: boolean | null
    quantityAvailable: Decimal | null
    quantityUnit: string | null
    description: string | null
    descriptionAr: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GermplasmCountAggregateOutputType = {
    id: number
    accessionNumber: number
    commonName: number
    commonNameAr: number
    scientificName: number
    genus: number
    species: number
    subspecies: number
    cultivar: number
    variety: number
    pedigree: number
    type: number
    countryOfOrigin: number
    regionOfOrigin: number
    collectionSite: number
    collectionDate: number
    collectedBy: number
    donorInstitution: number
    donorAccessionNumber: number
    growthHabit: number
    maturityDays: number
    yieldPotential: number
    droughtTolerance: number
    diseaseResistance: number
    pestResistance: number
    qualityTraits: number
    storageLocation: number
    storageConditions: number
    storageTemperature: number
    storageHumidity: number
    isAvailable: number
    quantityAvailable: number
    quantityUnit: number
    description: number
    descriptionAr: number
    photos: number
    documents: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GermplasmAvgAggregateInputType = {
    maturityDays?: true
    storageTemperature?: true
    storageHumidity?: true
    quantityAvailable?: true
  }

  export type GermplasmSumAggregateInputType = {
    maturityDays?: true
    storageTemperature?: true
    storageHumidity?: true
    quantityAvailable?: true
  }

  export type GermplasmMinAggregateInputType = {
    id?: true
    accessionNumber?: true
    commonName?: true
    commonNameAr?: true
    scientificName?: true
    genus?: true
    species?: true
    subspecies?: true
    cultivar?: true
    variety?: true
    pedigree?: true
    type?: true
    countryOfOrigin?: true
    regionOfOrigin?: true
    collectionSite?: true
    collectionDate?: true
    collectedBy?: true
    donorInstitution?: true
    donorAccessionNumber?: true
    growthHabit?: true
    maturityDays?: true
    yieldPotential?: true
    droughtTolerance?: true
    storageLocation?: true
    storageConditions?: true
    storageTemperature?: true
    storageHumidity?: true
    isAvailable?: true
    quantityAvailable?: true
    quantityUnit?: true
    description?: true
    descriptionAr?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GermplasmMaxAggregateInputType = {
    id?: true
    accessionNumber?: true
    commonName?: true
    commonNameAr?: true
    scientificName?: true
    genus?: true
    species?: true
    subspecies?: true
    cultivar?: true
    variety?: true
    pedigree?: true
    type?: true
    countryOfOrigin?: true
    regionOfOrigin?: true
    collectionSite?: true
    collectionDate?: true
    collectedBy?: true
    donorInstitution?: true
    donorAccessionNumber?: true
    growthHabit?: true
    maturityDays?: true
    yieldPotential?: true
    droughtTolerance?: true
    storageLocation?: true
    storageConditions?: true
    storageTemperature?: true
    storageHumidity?: true
    isAvailable?: true
    quantityAvailable?: true
    quantityUnit?: true
    description?: true
    descriptionAr?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GermplasmCountAggregateInputType = {
    id?: true
    accessionNumber?: true
    commonName?: true
    commonNameAr?: true
    scientificName?: true
    genus?: true
    species?: true
    subspecies?: true
    cultivar?: true
    variety?: true
    pedigree?: true
    type?: true
    countryOfOrigin?: true
    regionOfOrigin?: true
    collectionSite?: true
    collectionDate?: true
    collectedBy?: true
    donorInstitution?: true
    donorAccessionNumber?: true
    growthHabit?: true
    maturityDays?: true
    yieldPotential?: true
    droughtTolerance?: true
    diseaseResistance?: true
    pestResistance?: true
    qualityTraits?: true
    storageLocation?: true
    storageConditions?: true
    storageTemperature?: true
    storageHumidity?: true
    isAvailable?: true
    quantityAvailable?: true
    quantityUnit?: true
    description?: true
    descriptionAr?: true
    photos?: true
    documents?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GermplasmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Germplasm to aggregate.
     */
    where?: GermplasmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Germplasms to fetch.
     */
    orderBy?: GermplasmOrderByWithRelationInput | GermplasmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GermplasmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Germplasms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Germplasms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Germplasms
    **/
    _count?: true | GermplasmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GermplasmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GermplasmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GermplasmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GermplasmMaxAggregateInputType
  }

  export type GetGermplasmAggregateType<T extends GermplasmAggregateArgs> = {
        [P in keyof T & keyof AggregateGermplasm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGermplasm[P]>
      : GetScalarType<T[P], AggregateGermplasm[P]>
  }




  export type GermplasmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GermplasmWhereInput
    orderBy?: GermplasmOrderByWithAggregationInput | GermplasmOrderByWithAggregationInput[]
    by: GermplasmScalarFieldEnum[] | GermplasmScalarFieldEnum
    having?: GermplasmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GermplasmCountAggregateInputType | true
    _avg?: GermplasmAvgAggregateInputType
    _sum?: GermplasmSumAggregateInputType
    _min?: GermplasmMinAggregateInputType
    _max?: GermplasmMaxAggregateInputType
  }

  export type GermplasmGroupByOutputType = {
    id: string
    accessionNumber: string
    commonName: string
    commonNameAr: string | null
    scientificName: string | null
    genus: string | null
    species: string | null
    subspecies: string | null
    cultivar: string | null
    variety: string | null
    pedigree: string | null
    type: $Enums.GermplasmType
    countryOfOrigin: string | null
    regionOfOrigin: string | null
    collectionSite: string | null
    collectionDate: Date | null
    collectedBy: string | null
    donorInstitution: string | null
    donorAccessionNumber: string | null
    growthHabit: string | null
    maturityDays: number | null
    yieldPotential: string | null
    droughtTolerance: string | null
    diseaseResistance: JsonValue
    pestResistance: JsonValue
    qualityTraits: JsonValue
    storageLocation: string | null
    storageConditions: string | null
    storageTemperature: Decimal | null
    storageHumidity: Decimal | null
    isAvailable: boolean
    quantityAvailable: Decimal | null
    quantityUnit: string | null
    description: string | null
    descriptionAr: string | null
    photos: string[]
    documents: string[]
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: GermplasmCountAggregateOutputType | null
    _avg: GermplasmAvgAggregateOutputType | null
    _sum: GermplasmSumAggregateOutputType | null
    _min: GermplasmMinAggregateOutputType | null
    _max: GermplasmMaxAggregateOutputType | null
  }

  type GetGermplasmGroupByPayload<T extends GermplasmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GermplasmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GermplasmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GermplasmGroupByOutputType[P]>
            : GetScalarType<T[P], GermplasmGroupByOutputType[P]>
        }
      >
    >


  export type GermplasmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accessionNumber?: boolean
    commonName?: boolean
    commonNameAr?: boolean
    scientificName?: boolean
    genus?: boolean
    species?: boolean
    subspecies?: boolean
    cultivar?: boolean
    variety?: boolean
    pedigree?: boolean
    type?: boolean
    countryOfOrigin?: boolean
    regionOfOrigin?: boolean
    collectionSite?: boolean
    collectionDate?: boolean
    collectedBy?: boolean
    donorInstitution?: boolean
    donorAccessionNumber?: boolean
    growthHabit?: boolean
    maturityDays?: boolean
    yieldPotential?: boolean
    droughtTolerance?: boolean
    diseaseResistance?: boolean
    pestResistance?: boolean
    qualityTraits?: boolean
    storageLocation?: boolean
    storageConditions?: boolean
    storageTemperature?: boolean
    storageHumidity?: boolean
    isAvailable?: boolean
    quantityAvailable?: boolean
    quantityUnit?: boolean
    description?: boolean
    descriptionAr?: boolean
    photos?: boolean
    documents?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seedLots?: boolean | Germplasm$seedLotsArgs<ExtArgs>
    plantings?: boolean | Germplasm$plantingsArgs<ExtArgs>
    _count?: boolean | GermplasmCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["germplasm"]>

  export type GermplasmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accessionNumber?: boolean
    commonName?: boolean
    commonNameAr?: boolean
    scientificName?: boolean
    genus?: boolean
    species?: boolean
    subspecies?: boolean
    cultivar?: boolean
    variety?: boolean
    pedigree?: boolean
    type?: boolean
    countryOfOrigin?: boolean
    regionOfOrigin?: boolean
    collectionSite?: boolean
    collectionDate?: boolean
    collectedBy?: boolean
    donorInstitution?: boolean
    donorAccessionNumber?: boolean
    growthHabit?: boolean
    maturityDays?: boolean
    yieldPotential?: boolean
    droughtTolerance?: boolean
    diseaseResistance?: boolean
    pestResistance?: boolean
    qualityTraits?: boolean
    storageLocation?: boolean
    storageConditions?: boolean
    storageTemperature?: boolean
    storageHumidity?: boolean
    isAvailable?: boolean
    quantityAvailable?: boolean
    quantityUnit?: boolean
    description?: boolean
    descriptionAr?: boolean
    photos?: boolean
    documents?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["germplasm"]>

  export type GermplasmSelectScalar = {
    id?: boolean
    accessionNumber?: boolean
    commonName?: boolean
    commonNameAr?: boolean
    scientificName?: boolean
    genus?: boolean
    species?: boolean
    subspecies?: boolean
    cultivar?: boolean
    variety?: boolean
    pedigree?: boolean
    type?: boolean
    countryOfOrigin?: boolean
    regionOfOrigin?: boolean
    collectionSite?: boolean
    collectionDate?: boolean
    collectedBy?: boolean
    donorInstitution?: boolean
    donorAccessionNumber?: boolean
    growthHabit?: boolean
    maturityDays?: boolean
    yieldPotential?: boolean
    droughtTolerance?: boolean
    diseaseResistance?: boolean
    pestResistance?: boolean
    qualityTraits?: boolean
    storageLocation?: boolean
    storageConditions?: boolean
    storageTemperature?: boolean
    storageHumidity?: boolean
    isAvailable?: boolean
    quantityAvailable?: boolean
    quantityUnit?: boolean
    description?: boolean
    descriptionAr?: boolean
    photos?: boolean
    documents?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GermplasmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seedLots?: boolean | Germplasm$seedLotsArgs<ExtArgs>
    plantings?: boolean | Germplasm$plantingsArgs<ExtArgs>
    _count?: boolean | GermplasmCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GermplasmIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GermplasmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Germplasm"
    objects: {
      seedLots: Prisma.$SeedLotPayload<ExtArgs>[]
      plantings: Prisma.$PlantingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accessionNumber: string
      commonName: string
      commonNameAr: string | null
      scientificName: string | null
      genus: string | null
      species: string | null
      subspecies: string | null
      cultivar: string | null
      variety: string | null
      pedigree: string | null
      type: $Enums.GermplasmType
      countryOfOrigin: string | null
      regionOfOrigin: string | null
      collectionSite: string | null
      collectionDate: Date | null
      collectedBy: string | null
      donorInstitution: string | null
      donorAccessionNumber: string | null
      growthHabit: string | null
      maturityDays: number | null
      yieldPotential: string | null
      droughtTolerance: string | null
      diseaseResistance: Prisma.JsonValue
      pestResistance: Prisma.JsonValue
      qualityTraits: Prisma.JsonValue
      storageLocation: string | null
      storageConditions: string | null
      storageTemperature: Prisma.Decimal | null
      storageHumidity: Prisma.Decimal | null
      isAvailable: boolean
      quantityAvailable: Prisma.Decimal | null
      quantityUnit: string | null
      description: string | null
      descriptionAr: string | null
      photos: string[]
      documents: string[]
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["germplasm"]>
    composites: {}
  }

  type GermplasmGetPayload<S extends boolean | null | undefined | GermplasmDefaultArgs> = $Result.GetResult<Prisma.$GermplasmPayload, S>

  type GermplasmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GermplasmFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GermplasmCountAggregateInputType | true
    }

  export interface GermplasmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Germplasm'], meta: { name: 'Germplasm' } }
    /**
     * Find zero or one Germplasm that matches the filter.
     * @param {GermplasmFindUniqueArgs} args - Arguments to find a Germplasm
     * @example
     * // Get one Germplasm
     * const germplasm = await prisma.germplasm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GermplasmFindUniqueArgs>(args: SelectSubset<T, GermplasmFindUniqueArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Germplasm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GermplasmFindUniqueOrThrowArgs} args - Arguments to find a Germplasm
     * @example
     * // Get one Germplasm
     * const germplasm = await prisma.germplasm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GermplasmFindUniqueOrThrowArgs>(args: SelectSubset<T, GermplasmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Germplasm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GermplasmFindFirstArgs} args - Arguments to find a Germplasm
     * @example
     * // Get one Germplasm
     * const germplasm = await prisma.germplasm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GermplasmFindFirstArgs>(args?: SelectSubset<T, GermplasmFindFirstArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Germplasm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GermplasmFindFirstOrThrowArgs} args - Arguments to find a Germplasm
     * @example
     * // Get one Germplasm
     * const germplasm = await prisma.germplasm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GermplasmFindFirstOrThrowArgs>(args?: SelectSubset<T, GermplasmFindFirstOrThrowArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Germplasms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GermplasmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Germplasms
     * const germplasms = await prisma.germplasm.findMany()
     * 
     * // Get first 10 Germplasms
     * const germplasms = await prisma.germplasm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const germplasmWithIdOnly = await prisma.germplasm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GermplasmFindManyArgs>(args?: SelectSubset<T, GermplasmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Germplasm.
     * @param {GermplasmCreateArgs} args - Arguments to create a Germplasm.
     * @example
     * // Create one Germplasm
     * const Germplasm = await prisma.germplasm.create({
     *   data: {
     *     // ... data to create a Germplasm
     *   }
     * })
     * 
     */
    create<T extends GermplasmCreateArgs>(args: SelectSubset<T, GermplasmCreateArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Germplasms.
     * @param {GermplasmCreateManyArgs} args - Arguments to create many Germplasms.
     * @example
     * // Create many Germplasms
     * const germplasm = await prisma.germplasm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GermplasmCreateManyArgs>(args?: SelectSubset<T, GermplasmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Germplasms and returns the data saved in the database.
     * @param {GermplasmCreateManyAndReturnArgs} args - Arguments to create many Germplasms.
     * @example
     * // Create many Germplasms
     * const germplasm = await prisma.germplasm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Germplasms and only return the `id`
     * const germplasmWithIdOnly = await prisma.germplasm.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GermplasmCreateManyAndReturnArgs>(args?: SelectSubset<T, GermplasmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Germplasm.
     * @param {GermplasmDeleteArgs} args - Arguments to delete one Germplasm.
     * @example
     * // Delete one Germplasm
     * const Germplasm = await prisma.germplasm.delete({
     *   where: {
     *     // ... filter to delete one Germplasm
     *   }
     * })
     * 
     */
    delete<T extends GermplasmDeleteArgs>(args: SelectSubset<T, GermplasmDeleteArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Germplasm.
     * @param {GermplasmUpdateArgs} args - Arguments to update one Germplasm.
     * @example
     * // Update one Germplasm
     * const germplasm = await prisma.germplasm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GermplasmUpdateArgs>(args: SelectSubset<T, GermplasmUpdateArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Germplasms.
     * @param {GermplasmDeleteManyArgs} args - Arguments to filter Germplasms to delete.
     * @example
     * // Delete a few Germplasms
     * const { count } = await prisma.germplasm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GermplasmDeleteManyArgs>(args?: SelectSubset<T, GermplasmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Germplasms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GermplasmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Germplasms
     * const germplasm = await prisma.germplasm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GermplasmUpdateManyArgs>(args: SelectSubset<T, GermplasmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Germplasm.
     * @param {GermplasmUpsertArgs} args - Arguments to update or create a Germplasm.
     * @example
     * // Update or create a Germplasm
     * const germplasm = await prisma.germplasm.upsert({
     *   create: {
     *     // ... data to create a Germplasm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Germplasm we want to update
     *   }
     * })
     */
    upsert<T extends GermplasmUpsertArgs>(args: SelectSubset<T, GermplasmUpsertArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Germplasms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GermplasmCountArgs} args - Arguments to filter Germplasms to count.
     * @example
     * // Count the number of Germplasms
     * const count = await prisma.germplasm.count({
     *   where: {
     *     // ... the filter for the Germplasms we want to count
     *   }
     * })
    **/
    count<T extends GermplasmCountArgs>(
      args?: Subset<T, GermplasmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GermplasmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Germplasm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GermplasmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GermplasmAggregateArgs>(args: Subset<T, GermplasmAggregateArgs>): Prisma.PrismaPromise<GetGermplasmAggregateType<T>>

    /**
     * Group by Germplasm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GermplasmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GermplasmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GermplasmGroupByArgs['orderBy'] }
        : { orderBy?: GermplasmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GermplasmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGermplasmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Germplasm model
   */
  readonly fields: GermplasmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Germplasm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GermplasmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seedLots<T extends Germplasm$seedLotsArgs<ExtArgs> = {}>(args?: Subset<T, Germplasm$seedLotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "findMany"> | Null>
    plantings<T extends Germplasm$plantingsArgs<ExtArgs> = {}>(args?: Subset<T, Germplasm$plantingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Germplasm model
   */ 
  interface GermplasmFieldRefs {
    readonly id: FieldRef<"Germplasm", 'String'>
    readonly accessionNumber: FieldRef<"Germplasm", 'String'>
    readonly commonName: FieldRef<"Germplasm", 'String'>
    readonly commonNameAr: FieldRef<"Germplasm", 'String'>
    readonly scientificName: FieldRef<"Germplasm", 'String'>
    readonly genus: FieldRef<"Germplasm", 'String'>
    readonly species: FieldRef<"Germplasm", 'String'>
    readonly subspecies: FieldRef<"Germplasm", 'String'>
    readonly cultivar: FieldRef<"Germplasm", 'String'>
    readonly variety: FieldRef<"Germplasm", 'String'>
    readonly pedigree: FieldRef<"Germplasm", 'String'>
    readonly type: FieldRef<"Germplasm", 'GermplasmType'>
    readonly countryOfOrigin: FieldRef<"Germplasm", 'String'>
    readonly regionOfOrigin: FieldRef<"Germplasm", 'String'>
    readonly collectionSite: FieldRef<"Germplasm", 'String'>
    readonly collectionDate: FieldRef<"Germplasm", 'DateTime'>
    readonly collectedBy: FieldRef<"Germplasm", 'String'>
    readonly donorInstitution: FieldRef<"Germplasm", 'String'>
    readonly donorAccessionNumber: FieldRef<"Germplasm", 'String'>
    readonly growthHabit: FieldRef<"Germplasm", 'String'>
    readonly maturityDays: FieldRef<"Germplasm", 'Int'>
    readonly yieldPotential: FieldRef<"Germplasm", 'String'>
    readonly droughtTolerance: FieldRef<"Germplasm", 'String'>
    readonly diseaseResistance: FieldRef<"Germplasm", 'Json'>
    readonly pestResistance: FieldRef<"Germplasm", 'Json'>
    readonly qualityTraits: FieldRef<"Germplasm", 'Json'>
    readonly storageLocation: FieldRef<"Germplasm", 'String'>
    readonly storageConditions: FieldRef<"Germplasm", 'String'>
    readonly storageTemperature: FieldRef<"Germplasm", 'Decimal'>
    readonly storageHumidity: FieldRef<"Germplasm", 'Decimal'>
    readonly isAvailable: FieldRef<"Germplasm", 'Boolean'>
    readonly quantityAvailable: FieldRef<"Germplasm", 'Decimal'>
    readonly quantityUnit: FieldRef<"Germplasm", 'String'>
    readonly description: FieldRef<"Germplasm", 'String'>
    readonly descriptionAr: FieldRef<"Germplasm", 'String'>
    readonly photos: FieldRef<"Germplasm", 'String[]'>
    readonly documents: FieldRef<"Germplasm", 'String[]'>
    readonly metadata: FieldRef<"Germplasm", 'Json'>
    readonly createdAt: FieldRef<"Germplasm", 'DateTime'>
    readonly updatedAt: FieldRef<"Germplasm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Germplasm findUnique
   */
  export type GermplasmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
    /**
     * Filter, which Germplasm to fetch.
     */
    where: GermplasmWhereUniqueInput
  }

  /**
   * Germplasm findUniqueOrThrow
   */
  export type GermplasmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
    /**
     * Filter, which Germplasm to fetch.
     */
    where: GermplasmWhereUniqueInput
  }

  /**
   * Germplasm findFirst
   */
  export type GermplasmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
    /**
     * Filter, which Germplasm to fetch.
     */
    where?: GermplasmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Germplasms to fetch.
     */
    orderBy?: GermplasmOrderByWithRelationInput | GermplasmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Germplasms.
     */
    cursor?: GermplasmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Germplasms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Germplasms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Germplasms.
     */
    distinct?: GermplasmScalarFieldEnum | GermplasmScalarFieldEnum[]
  }

  /**
   * Germplasm findFirstOrThrow
   */
  export type GermplasmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
    /**
     * Filter, which Germplasm to fetch.
     */
    where?: GermplasmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Germplasms to fetch.
     */
    orderBy?: GermplasmOrderByWithRelationInput | GermplasmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Germplasms.
     */
    cursor?: GermplasmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Germplasms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Germplasms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Germplasms.
     */
    distinct?: GermplasmScalarFieldEnum | GermplasmScalarFieldEnum[]
  }

  /**
   * Germplasm findMany
   */
  export type GermplasmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
    /**
     * Filter, which Germplasms to fetch.
     */
    where?: GermplasmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Germplasms to fetch.
     */
    orderBy?: GermplasmOrderByWithRelationInput | GermplasmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Germplasms.
     */
    cursor?: GermplasmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Germplasms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Germplasms.
     */
    skip?: number
    distinct?: GermplasmScalarFieldEnum | GermplasmScalarFieldEnum[]
  }

  /**
   * Germplasm create
   */
  export type GermplasmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
    /**
     * The data needed to create a Germplasm.
     */
    data: XOR<GermplasmCreateInput, GermplasmUncheckedCreateInput>
  }

  /**
   * Germplasm createMany
   */
  export type GermplasmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Germplasms.
     */
    data: GermplasmCreateManyInput | GermplasmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Germplasm createManyAndReturn
   */
  export type GermplasmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Germplasms.
     */
    data: GermplasmCreateManyInput | GermplasmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Germplasm update
   */
  export type GermplasmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
    /**
     * The data needed to update a Germplasm.
     */
    data: XOR<GermplasmUpdateInput, GermplasmUncheckedUpdateInput>
    /**
     * Choose, which Germplasm to update.
     */
    where: GermplasmWhereUniqueInput
  }

  /**
   * Germplasm updateMany
   */
  export type GermplasmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Germplasms.
     */
    data: XOR<GermplasmUpdateManyMutationInput, GermplasmUncheckedUpdateManyInput>
    /**
     * Filter which Germplasms to update
     */
    where?: GermplasmWhereInput
  }

  /**
   * Germplasm upsert
   */
  export type GermplasmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
    /**
     * The filter to search for the Germplasm to update in case it exists.
     */
    where: GermplasmWhereUniqueInput
    /**
     * In case the Germplasm found by the `where` argument doesn't exist, create a new Germplasm with this data.
     */
    create: XOR<GermplasmCreateInput, GermplasmUncheckedCreateInput>
    /**
     * In case the Germplasm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GermplasmUpdateInput, GermplasmUncheckedUpdateInput>
  }

  /**
   * Germplasm delete
   */
  export type GermplasmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
    /**
     * Filter which Germplasm to delete.
     */
    where: GermplasmWhereUniqueInput
  }

  /**
   * Germplasm deleteMany
   */
  export type GermplasmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Germplasms to delete
     */
    where?: GermplasmWhereInput
  }

  /**
   * Germplasm.seedLots
   */
  export type Germplasm$seedLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    where?: SeedLotWhereInput
    orderBy?: SeedLotOrderByWithRelationInput | SeedLotOrderByWithRelationInput[]
    cursor?: SeedLotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeedLotScalarFieldEnum | SeedLotScalarFieldEnum[]
  }

  /**
   * Germplasm.plantings
   */
  export type Germplasm$plantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    where?: PlantingWhereInput
    orderBy?: PlantingOrderByWithRelationInput | PlantingOrderByWithRelationInput[]
    cursor?: PlantingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantingScalarFieldEnum | PlantingScalarFieldEnum[]
  }

  /**
   * Germplasm without action
   */
  export type GermplasmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Germplasm
     */
    select?: GermplasmSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GermplasmInclude<ExtArgs> | null
  }


  /**
   * Model SeedLot
   */

  export type AggregateSeedLot = {
    _count: SeedLotCountAggregateOutputType | null
    _avg: SeedLotAvgAggregateOutputType | null
    _sum: SeedLotSumAggregateOutputType | null
    _min: SeedLotMinAggregateOutputType | null
    _max: SeedLotMaxAggregateOutputType | null
  }

  export type SeedLotAvgAggregateOutputType = {
    initialQuantity: Decimal | null
    currentQuantity: Decimal | null
    seedCount: number | null
    thousandSeedWeight: Decimal | null
    germinationRate: Decimal | null
    purityPercentage: Decimal | null
    moistureContent: Decimal | null
    vigorIndex: Decimal | null
  }

  export type SeedLotSumAggregateOutputType = {
    initialQuantity: Decimal | null
    currentQuantity: Decimal | null
    seedCount: number | null
    thousandSeedWeight: Decimal | null
    germinationRate: Decimal | null
    purityPercentage: Decimal | null
    moistureContent: Decimal | null
    vigorIndex: Decimal | null
  }

  export type SeedLotMinAggregateOutputType = {
    id: string | null
    germplasmId: string | null
    lotNumber: string | null
    initialQuantity: Decimal | null
    currentQuantity: Decimal | null
    quantityUnit: string | null
    seedCount: number | null
    thousandSeedWeight: Decimal | null
    qualityGrade: $Enums.SeedQualityGrade | null
    germinationRate: Decimal | null
    germinationTestDate: Date | null
    purityPercentage: Decimal | null
    moistureContent: Decimal | null
    vigorIndex: Decimal | null
    productionDate: Date | null
    harvestDate: Date | null
    productionLocation: string | null
    productionSeason: string | null
    producedBy: string | null
    certificationNumber: string | null
    certifiedBy: string | null
    certificationDate: Date | null
    expiryDate: Date | null
    isTreated: boolean | null
    treatmentType: string | null
    treatmentProduct: string | null
    treatmentDate: Date | null
    storageLocation: string | null
    storageConditions: string | null
    notes: string | null
    notesAr: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeedLotMaxAggregateOutputType = {
    id: string | null
    germplasmId: string | null
    lotNumber: string | null
    initialQuantity: Decimal | null
    currentQuantity: Decimal | null
    quantityUnit: string | null
    seedCount: number | null
    thousandSeedWeight: Decimal | null
    qualityGrade: $Enums.SeedQualityGrade | null
    germinationRate: Decimal | null
    germinationTestDate: Date | null
    purityPercentage: Decimal | null
    moistureContent: Decimal | null
    vigorIndex: Decimal | null
    productionDate: Date | null
    harvestDate: Date | null
    productionLocation: string | null
    productionSeason: string | null
    producedBy: string | null
    certificationNumber: string | null
    certifiedBy: string | null
    certificationDate: Date | null
    expiryDate: Date | null
    isTreated: boolean | null
    treatmentType: string | null
    treatmentProduct: string | null
    treatmentDate: Date | null
    storageLocation: string | null
    storageConditions: string | null
    notes: string | null
    notesAr: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeedLotCountAggregateOutputType = {
    id: number
    germplasmId: number
    lotNumber: number
    initialQuantity: number
    currentQuantity: number
    quantityUnit: number
    seedCount: number
    thousandSeedWeight: number
    qualityGrade: number
    germinationRate: number
    germinationTestDate: number
    purityPercentage: number
    moistureContent: number
    vigorIndex: number
    productionDate: number
    harvestDate: number
    productionLocation: number
    productionSeason: number
    producedBy: number
    certificationNumber: number
    certifiedBy: number
    certificationDate: number
    expiryDate: number
    isTreated: number
    treatmentType: number
    treatmentProduct: number
    treatmentDate: number
    storageLocation: number
    storageConditions: number
    notes: number
    notesAr: number
    photos: number
    documents: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeedLotAvgAggregateInputType = {
    initialQuantity?: true
    currentQuantity?: true
    seedCount?: true
    thousandSeedWeight?: true
    germinationRate?: true
    purityPercentage?: true
    moistureContent?: true
    vigorIndex?: true
  }

  export type SeedLotSumAggregateInputType = {
    initialQuantity?: true
    currentQuantity?: true
    seedCount?: true
    thousandSeedWeight?: true
    germinationRate?: true
    purityPercentage?: true
    moistureContent?: true
    vigorIndex?: true
  }

  export type SeedLotMinAggregateInputType = {
    id?: true
    germplasmId?: true
    lotNumber?: true
    initialQuantity?: true
    currentQuantity?: true
    quantityUnit?: true
    seedCount?: true
    thousandSeedWeight?: true
    qualityGrade?: true
    germinationRate?: true
    germinationTestDate?: true
    purityPercentage?: true
    moistureContent?: true
    vigorIndex?: true
    productionDate?: true
    harvestDate?: true
    productionLocation?: true
    productionSeason?: true
    producedBy?: true
    certificationNumber?: true
    certifiedBy?: true
    certificationDate?: true
    expiryDate?: true
    isTreated?: true
    treatmentType?: true
    treatmentProduct?: true
    treatmentDate?: true
    storageLocation?: true
    storageConditions?: true
    notes?: true
    notesAr?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeedLotMaxAggregateInputType = {
    id?: true
    germplasmId?: true
    lotNumber?: true
    initialQuantity?: true
    currentQuantity?: true
    quantityUnit?: true
    seedCount?: true
    thousandSeedWeight?: true
    qualityGrade?: true
    germinationRate?: true
    germinationTestDate?: true
    purityPercentage?: true
    moistureContent?: true
    vigorIndex?: true
    productionDate?: true
    harvestDate?: true
    productionLocation?: true
    productionSeason?: true
    producedBy?: true
    certificationNumber?: true
    certifiedBy?: true
    certificationDate?: true
    expiryDate?: true
    isTreated?: true
    treatmentType?: true
    treatmentProduct?: true
    treatmentDate?: true
    storageLocation?: true
    storageConditions?: true
    notes?: true
    notesAr?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeedLotCountAggregateInputType = {
    id?: true
    germplasmId?: true
    lotNumber?: true
    initialQuantity?: true
    currentQuantity?: true
    quantityUnit?: true
    seedCount?: true
    thousandSeedWeight?: true
    qualityGrade?: true
    germinationRate?: true
    germinationTestDate?: true
    purityPercentage?: true
    moistureContent?: true
    vigorIndex?: true
    productionDate?: true
    harvestDate?: true
    productionLocation?: true
    productionSeason?: true
    producedBy?: true
    certificationNumber?: true
    certifiedBy?: true
    certificationDate?: true
    expiryDate?: true
    isTreated?: true
    treatmentType?: true
    treatmentProduct?: true
    treatmentDate?: true
    storageLocation?: true
    storageConditions?: true
    notes?: true
    notesAr?: true
    photos?: true
    documents?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeedLotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeedLot to aggregate.
     */
    where?: SeedLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeedLots to fetch.
     */
    orderBy?: SeedLotOrderByWithRelationInput | SeedLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeedLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeedLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeedLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeedLots
    **/
    _count?: true | SeedLotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeedLotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeedLotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeedLotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeedLotMaxAggregateInputType
  }

  export type GetSeedLotAggregateType<T extends SeedLotAggregateArgs> = {
        [P in keyof T & keyof AggregateSeedLot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeedLot[P]>
      : GetScalarType<T[P], AggregateSeedLot[P]>
  }




  export type SeedLotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeedLotWhereInput
    orderBy?: SeedLotOrderByWithAggregationInput | SeedLotOrderByWithAggregationInput[]
    by: SeedLotScalarFieldEnum[] | SeedLotScalarFieldEnum
    having?: SeedLotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeedLotCountAggregateInputType | true
    _avg?: SeedLotAvgAggregateInputType
    _sum?: SeedLotSumAggregateInputType
    _min?: SeedLotMinAggregateInputType
    _max?: SeedLotMaxAggregateInputType
  }

  export type SeedLotGroupByOutputType = {
    id: string
    germplasmId: string
    lotNumber: string
    initialQuantity: Decimal
    currentQuantity: Decimal
    quantityUnit: string
    seedCount: number | null
    thousandSeedWeight: Decimal | null
    qualityGrade: $Enums.SeedQualityGrade
    germinationRate: Decimal | null
    germinationTestDate: Date | null
    purityPercentage: Decimal | null
    moistureContent: Decimal | null
    vigorIndex: Decimal | null
    productionDate: Date | null
    harvestDate: Date | null
    productionLocation: string | null
    productionSeason: string | null
    producedBy: string | null
    certificationNumber: string | null
    certifiedBy: string | null
    certificationDate: Date | null
    expiryDate: Date | null
    isTreated: boolean
    treatmentType: string | null
    treatmentProduct: string | null
    treatmentDate: Date | null
    storageLocation: string | null
    storageConditions: string | null
    notes: string | null
    notesAr: string | null
    photos: string[]
    documents: string[]
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SeedLotCountAggregateOutputType | null
    _avg: SeedLotAvgAggregateOutputType | null
    _sum: SeedLotSumAggregateOutputType | null
    _min: SeedLotMinAggregateOutputType | null
    _max: SeedLotMaxAggregateOutputType | null
  }

  type GetSeedLotGroupByPayload<T extends SeedLotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeedLotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeedLotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeedLotGroupByOutputType[P]>
            : GetScalarType<T[P], SeedLotGroupByOutputType[P]>
        }
      >
    >


  export type SeedLotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    germplasmId?: boolean
    lotNumber?: boolean
    initialQuantity?: boolean
    currentQuantity?: boolean
    quantityUnit?: boolean
    seedCount?: boolean
    thousandSeedWeight?: boolean
    qualityGrade?: boolean
    germinationRate?: boolean
    germinationTestDate?: boolean
    purityPercentage?: boolean
    moistureContent?: boolean
    vigorIndex?: boolean
    productionDate?: boolean
    harvestDate?: boolean
    productionLocation?: boolean
    productionSeason?: boolean
    producedBy?: boolean
    certificationNumber?: boolean
    certifiedBy?: boolean
    certificationDate?: boolean
    expiryDate?: boolean
    isTreated?: boolean
    treatmentType?: boolean
    treatmentProduct?: boolean
    treatmentDate?: boolean
    storageLocation?: boolean
    storageConditions?: boolean
    notes?: boolean
    notesAr?: boolean
    photos?: boolean
    documents?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    germplasm?: boolean | GermplasmDefaultArgs<ExtArgs>
    plantings?: boolean | SeedLot$plantingsArgs<ExtArgs>
    _count?: boolean | SeedLotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seedLot"]>

  export type SeedLotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    germplasmId?: boolean
    lotNumber?: boolean
    initialQuantity?: boolean
    currentQuantity?: boolean
    quantityUnit?: boolean
    seedCount?: boolean
    thousandSeedWeight?: boolean
    qualityGrade?: boolean
    germinationRate?: boolean
    germinationTestDate?: boolean
    purityPercentage?: boolean
    moistureContent?: boolean
    vigorIndex?: boolean
    productionDate?: boolean
    harvestDate?: boolean
    productionLocation?: boolean
    productionSeason?: boolean
    producedBy?: boolean
    certificationNumber?: boolean
    certifiedBy?: boolean
    certificationDate?: boolean
    expiryDate?: boolean
    isTreated?: boolean
    treatmentType?: boolean
    treatmentProduct?: boolean
    treatmentDate?: boolean
    storageLocation?: boolean
    storageConditions?: boolean
    notes?: boolean
    notesAr?: boolean
    photos?: boolean
    documents?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    germplasm?: boolean | GermplasmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seedLot"]>

  export type SeedLotSelectScalar = {
    id?: boolean
    germplasmId?: boolean
    lotNumber?: boolean
    initialQuantity?: boolean
    currentQuantity?: boolean
    quantityUnit?: boolean
    seedCount?: boolean
    thousandSeedWeight?: boolean
    qualityGrade?: boolean
    germinationRate?: boolean
    germinationTestDate?: boolean
    purityPercentage?: boolean
    moistureContent?: boolean
    vigorIndex?: boolean
    productionDate?: boolean
    harvestDate?: boolean
    productionLocation?: boolean
    productionSeason?: boolean
    producedBy?: boolean
    certificationNumber?: boolean
    certifiedBy?: boolean
    certificationDate?: boolean
    expiryDate?: boolean
    isTreated?: boolean
    treatmentType?: boolean
    treatmentProduct?: boolean
    treatmentDate?: boolean
    storageLocation?: boolean
    storageConditions?: boolean
    notes?: boolean
    notesAr?: boolean
    photos?: boolean
    documents?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeedLotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    germplasm?: boolean | GermplasmDefaultArgs<ExtArgs>
    plantings?: boolean | SeedLot$plantingsArgs<ExtArgs>
    _count?: boolean | SeedLotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeedLotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    germplasm?: boolean | GermplasmDefaultArgs<ExtArgs>
  }

  export type $SeedLotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeedLot"
    objects: {
      germplasm: Prisma.$GermplasmPayload<ExtArgs>
      plantings: Prisma.$PlantingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      germplasmId: string
      lotNumber: string
      initialQuantity: Prisma.Decimal
      currentQuantity: Prisma.Decimal
      quantityUnit: string
      seedCount: number | null
      thousandSeedWeight: Prisma.Decimal | null
      qualityGrade: $Enums.SeedQualityGrade
      germinationRate: Prisma.Decimal | null
      germinationTestDate: Date | null
      purityPercentage: Prisma.Decimal | null
      moistureContent: Prisma.Decimal | null
      vigorIndex: Prisma.Decimal | null
      productionDate: Date | null
      harvestDate: Date | null
      productionLocation: string | null
      productionSeason: string | null
      producedBy: string | null
      certificationNumber: string | null
      certifiedBy: string | null
      certificationDate: Date | null
      expiryDate: Date | null
      isTreated: boolean
      treatmentType: string | null
      treatmentProduct: string | null
      treatmentDate: Date | null
      storageLocation: string | null
      storageConditions: string | null
      notes: string | null
      notesAr: string | null
      photos: string[]
      documents: string[]
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seedLot"]>
    composites: {}
  }

  type SeedLotGetPayload<S extends boolean | null | undefined | SeedLotDefaultArgs> = $Result.GetResult<Prisma.$SeedLotPayload, S>

  type SeedLotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeedLotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeedLotCountAggregateInputType | true
    }

  export interface SeedLotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeedLot'], meta: { name: 'SeedLot' } }
    /**
     * Find zero or one SeedLot that matches the filter.
     * @param {SeedLotFindUniqueArgs} args - Arguments to find a SeedLot
     * @example
     * // Get one SeedLot
     * const seedLot = await prisma.seedLot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeedLotFindUniqueArgs>(args: SelectSubset<T, SeedLotFindUniqueArgs<ExtArgs>>): Prisma__SeedLotClient<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeedLot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeedLotFindUniqueOrThrowArgs} args - Arguments to find a SeedLot
     * @example
     * // Get one SeedLot
     * const seedLot = await prisma.seedLot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeedLotFindUniqueOrThrowArgs>(args: SelectSubset<T, SeedLotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeedLotClient<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeedLot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedLotFindFirstArgs} args - Arguments to find a SeedLot
     * @example
     * // Get one SeedLot
     * const seedLot = await prisma.seedLot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeedLotFindFirstArgs>(args?: SelectSubset<T, SeedLotFindFirstArgs<ExtArgs>>): Prisma__SeedLotClient<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeedLot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedLotFindFirstOrThrowArgs} args - Arguments to find a SeedLot
     * @example
     * // Get one SeedLot
     * const seedLot = await prisma.seedLot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeedLotFindFirstOrThrowArgs>(args?: SelectSubset<T, SeedLotFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeedLotClient<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeedLots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedLotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeedLots
     * const seedLots = await prisma.seedLot.findMany()
     * 
     * // Get first 10 SeedLots
     * const seedLots = await prisma.seedLot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seedLotWithIdOnly = await prisma.seedLot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeedLotFindManyArgs>(args?: SelectSubset<T, SeedLotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeedLot.
     * @param {SeedLotCreateArgs} args - Arguments to create a SeedLot.
     * @example
     * // Create one SeedLot
     * const SeedLot = await prisma.seedLot.create({
     *   data: {
     *     // ... data to create a SeedLot
     *   }
     * })
     * 
     */
    create<T extends SeedLotCreateArgs>(args: SelectSubset<T, SeedLotCreateArgs<ExtArgs>>): Prisma__SeedLotClient<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeedLots.
     * @param {SeedLotCreateManyArgs} args - Arguments to create many SeedLots.
     * @example
     * // Create many SeedLots
     * const seedLot = await prisma.seedLot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeedLotCreateManyArgs>(args?: SelectSubset<T, SeedLotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeedLots and returns the data saved in the database.
     * @param {SeedLotCreateManyAndReturnArgs} args - Arguments to create many SeedLots.
     * @example
     * // Create many SeedLots
     * const seedLot = await prisma.seedLot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeedLots and only return the `id`
     * const seedLotWithIdOnly = await prisma.seedLot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeedLotCreateManyAndReturnArgs>(args?: SelectSubset<T, SeedLotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeedLot.
     * @param {SeedLotDeleteArgs} args - Arguments to delete one SeedLot.
     * @example
     * // Delete one SeedLot
     * const SeedLot = await prisma.seedLot.delete({
     *   where: {
     *     // ... filter to delete one SeedLot
     *   }
     * })
     * 
     */
    delete<T extends SeedLotDeleteArgs>(args: SelectSubset<T, SeedLotDeleteArgs<ExtArgs>>): Prisma__SeedLotClient<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeedLot.
     * @param {SeedLotUpdateArgs} args - Arguments to update one SeedLot.
     * @example
     * // Update one SeedLot
     * const seedLot = await prisma.seedLot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeedLotUpdateArgs>(args: SelectSubset<T, SeedLotUpdateArgs<ExtArgs>>): Prisma__SeedLotClient<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeedLots.
     * @param {SeedLotDeleteManyArgs} args - Arguments to filter SeedLots to delete.
     * @example
     * // Delete a few SeedLots
     * const { count } = await prisma.seedLot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeedLotDeleteManyArgs>(args?: SelectSubset<T, SeedLotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeedLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedLotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeedLots
     * const seedLot = await prisma.seedLot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeedLotUpdateManyArgs>(args: SelectSubset<T, SeedLotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeedLot.
     * @param {SeedLotUpsertArgs} args - Arguments to update or create a SeedLot.
     * @example
     * // Update or create a SeedLot
     * const seedLot = await prisma.seedLot.upsert({
     *   create: {
     *     // ... data to create a SeedLot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeedLot we want to update
     *   }
     * })
     */
    upsert<T extends SeedLotUpsertArgs>(args: SelectSubset<T, SeedLotUpsertArgs<ExtArgs>>): Prisma__SeedLotClient<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeedLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedLotCountArgs} args - Arguments to filter SeedLots to count.
     * @example
     * // Count the number of SeedLots
     * const count = await prisma.seedLot.count({
     *   where: {
     *     // ... the filter for the SeedLots we want to count
     *   }
     * })
    **/
    count<T extends SeedLotCountArgs>(
      args?: Subset<T, SeedLotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeedLotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeedLot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedLotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeedLotAggregateArgs>(args: Subset<T, SeedLotAggregateArgs>): Prisma.PrismaPromise<GetSeedLotAggregateType<T>>

    /**
     * Group by SeedLot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeedLotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeedLotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeedLotGroupByArgs['orderBy'] }
        : { orderBy?: SeedLotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeedLotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeedLotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeedLot model
   */
  readonly fields: SeedLotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeedLot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeedLotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    germplasm<T extends GermplasmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GermplasmDefaultArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plantings<T extends SeedLot$plantingsArgs<ExtArgs> = {}>(args?: Subset<T, SeedLot$plantingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeedLot model
   */ 
  interface SeedLotFieldRefs {
    readonly id: FieldRef<"SeedLot", 'String'>
    readonly germplasmId: FieldRef<"SeedLot", 'String'>
    readonly lotNumber: FieldRef<"SeedLot", 'String'>
    readonly initialQuantity: FieldRef<"SeedLot", 'Decimal'>
    readonly currentQuantity: FieldRef<"SeedLot", 'Decimal'>
    readonly quantityUnit: FieldRef<"SeedLot", 'String'>
    readonly seedCount: FieldRef<"SeedLot", 'Int'>
    readonly thousandSeedWeight: FieldRef<"SeedLot", 'Decimal'>
    readonly qualityGrade: FieldRef<"SeedLot", 'SeedQualityGrade'>
    readonly germinationRate: FieldRef<"SeedLot", 'Decimal'>
    readonly germinationTestDate: FieldRef<"SeedLot", 'DateTime'>
    readonly purityPercentage: FieldRef<"SeedLot", 'Decimal'>
    readonly moistureContent: FieldRef<"SeedLot", 'Decimal'>
    readonly vigorIndex: FieldRef<"SeedLot", 'Decimal'>
    readonly productionDate: FieldRef<"SeedLot", 'DateTime'>
    readonly harvestDate: FieldRef<"SeedLot", 'DateTime'>
    readonly productionLocation: FieldRef<"SeedLot", 'String'>
    readonly productionSeason: FieldRef<"SeedLot", 'String'>
    readonly producedBy: FieldRef<"SeedLot", 'String'>
    readonly certificationNumber: FieldRef<"SeedLot", 'String'>
    readonly certifiedBy: FieldRef<"SeedLot", 'String'>
    readonly certificationDate: FieldRef<"SeedLot", 'DateTime'>
    readonly expiryDate: FieldRef<"SeedLot", 'DateTime'>
    readonly isTreated: FieldRef<"SeedLot", 'Boolean'>
    readonly treatmentType: FieldRef<"SeedLot", 'String'>
    readonly treatmentProduct: FieldRef<"SeedLot", 'String'>
    readonly treatmentDate: FieldRef<"SeedLot", 'DateTime'>
    readonly storageLocation: FieldRef<"SeedLot", 'String'>
    readonly storageConditions: FieldRef<"SeedLot", 'String'>
    readonly notes: FieldRef<"SeedLot", 'String'>
    readonly notesAr: FieldRef<"SeedLot", 'String'>
    readonly photos: FieldRef<"SeedLot", 'String[]'>
    readonly documents: FieldRef<"SeedLot", 'String[]'>
    readonly metadata: FieldRef<"SeedLot", 'Json'>
    readonly createdAt: FieldRef<"SeedLot", 'DateTime'>
    readonly updatedAt: FieldRef<"SeedLot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeedLot findUnique
   */
  export type SeedLotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    /**
     * Filter, which SeedLot to fetch.
     */
    where: SeedLotWhereUniqueInput
  }

  /**
   * SeedLot findUniqueOrThrow
   */
  export type SeedLotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    /**
     * Filter, which SeedLot to fetch.
     */
    where: SeedLotWhereUniqueInput
  }

  /**
   * SeedLot findFirst
   */
  export type SeedLotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    /**
     * Filter, which SeedLot to fetch.
     */
    where?: SeedLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeedLots to fetch.
     */
    orderBy?: SeedLotOrderByWithRelationInput | SeedLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeedLots.
     */
    cursor?: SeedLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeedLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeedLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeedLots.
     */
    distinct?: SeedLotScalarFieldEnum | SeedLotScalarFieldEnum[]
  }

  /**
   * SeedLot findFirstOrThrow
   */
  export type SeedLotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    /**
     * Filter, which SeedLot to fetch.
     */
    where?: SeedLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeedLots to fetch.
     */
    orderBy?: SeedLotOrderByWithRelationInput | SeedLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeedLots.
     */
    cursor?: SeedLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeedLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeedLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeedLots.
     */
    distinct?: SeedLotScalarFieldEnum | SeedLotScalarFieldEnum[]
  }

  /**
   * SeedLot findMany
   */
  export type SeedLotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    /**
     * Filter, which SeedLots to fetch.
     */
    where?: SeedLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeedLots to fetch.
     */
    orderBy?: SeedLotOrderByWithRelationInput | SeedLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeedLots.
     */
    cursor?: SeedLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeedLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeedLots.
     */
    skip?: number
    distinct?: SeedLotScalarFieldEnum | SeedLotScalarFieldEnum[]
  }

  /**
   * SeedLot create
   */
  export type SeedLotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    /**
     * The data needed to create a SeedLot.
     */
    data: XOR<SeedLotCreateInput, SeedLotUncheckedCreateInput>
  }

  /**
   * SeedLot createMany
   */
  export type SeedLotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeedLots.
     */
    data: SeedLotCreateManyInput | SeedLotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeedLot createManyAndReturn
   */
  export type SeedLotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeedLots.
     */
    data: SeedLotCreateManyInput | SeedLotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeedLot update
   */
  export type SeedLotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    /**
     * The data needed to update a SeedLot.
     */
    data: XOR<SeedLotUpdateInput, SeedLotUncheckedUpdateInput>
    /**
     * Choose, which SeedLot to update.
     */
    where: SeedLotWhereUniqueInput
  }

  /**
   * SeedLot updateMany
   */
  export type SeedLotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeedLots.
     */
    data: XOR<SeedLotUpdateManyMutationInput, SeedLotUncheckedUpdateManyInput>
    /**
     * Filter which SeedLots to update
     */
    where?: SeedLotWhereInput
  }

  /**
   * SeedLot upsert
   */
  export type SeedLotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    /**
     * The filter to search for the SeedLot to update in case it exists.
     */
    where: SeedLotWhereUniqueInput
    /**
     * In case the SeedLot found by the `where` argument doesn't exist, create a new SeedLot with this data.
     */
    create: XOR<SeedLotCreateInput, SeedLotUncheckedCreateInput>
    /**
     * In case the SeedLot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeedLotUpdateInput, SeedLotUncheckedUpdateInput>
  }

  /**
   * SeedLot delete
   */
  export type SeedLotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    /**
     * Filter which SeedLot to delete.
     */
    where: SeedLotWhereUniqueInput
  }

  /**
   * SeedLot deleteMany
   */
  export type SeedLotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeedLots to delete
     */
    where?: SeedLotWhereInput
  }

  /**
   * SeedLot.plantings
   */
  export type SeedLot$plantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    where?: PlantingWhereInput
    orderBy?: PlantingOrderByWithRelationInput | PlantingOrderByWithRelationInput[]
    cursor?: PlantingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantingScalarFieldEnum | PlantingScalarFieldEnum[]
  }

  /**
   * SeedLot without action
   */
  export type SeedLotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
  }


  /**
   * Model Planting
   */

  export type AggregatePlanting = {
    _count: PlantingCountAggregateOutputType | null
    _avg: PlantingAvgAggregateOutputType | null
    _sum: PlantingSumAggregateOutputType | null
    _min: PlantingMinAggregateOutputType | null
    _max: PlantingMaxAggregateOutputType | null
  }

  export type PlantingAvgAggregateOutputType = {
    seedingRate: Decimal | null
    seedsPerHill: number | null
    seedDepth: Decimal | null
    rowSpacing: Decimal | null
    plantSpacing: Decimal | null
    plantedArea: Decimal | null
    numberOfRows: number | null
    plantsPerRow: number | null
    totalPlantsExpected: number | null
    germinationCount: number | null
    germinationPercentage: Decimal | null
    finalPlantCount: number | null
  }

  export type PlantingSumAggregateOutputType = {
    seedingRate: Decimal | null
    seedsPerHill: number | null
    seedDepth: Decimal | null
    rowSpacing: Decimal | null
    plantSpacing: Decimal | null
    plantedArea: Decimal | null
    numberOfRows: number | null
    plantsPerRow: number | null
    totalPlantsExpected: number | null
    germinationCount: number | null
    germinationPercentage: Decimal | null
    finalPlantCount: number | null
  }

  export type PlantingMinAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotId: string | null
    germplasmId: string | null
    seedLotId: string | null
    plantingDate: Date | null
    plantingMethod: string | null
    seedingRate: Decimal | null
    seedingRateUnit: string | null
    seedsPerHill: number | null
    seedDepth: Decimal | null
    seedDepthUnit: string | null
    rowSpacing: Decimal | null
    plantSpacing: Decimal | null
    spacingUnit: string | null
    plantedArea: Decimal | null
    plantedAreaUnit: string | null
    numberOfRows: number | null
    plantsPerRow: number | null
    totalPlantsExpected: number | null
    germinationDate: Date | null
    emergenceDate: Date | null
    germinationCount: number | null
    germinationPercentage: Decimal | null
    thinningDate: Date | null
    finalPlantCount: number | null
    plantedBy: string | null
    notes: string | null
    notesAr: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlantingMaxAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotId: string | null
    germplasmId: string | null
    seedLotId: string | null
    plantingDate: Date | null
    plantingMethod: string | null
    seedingRate: Decimal | null
    seedingRateUnit: string | null
    seedsPerHill: number | null
    seedDepth: Decimal | null
    seedDepthUnit: string | null
    rowSpacing: Decimal | null
    plantSpacing: Decimal | null
    spacingUnit: string | null
    plantedArea: Decimal | null
    plantedAreaUnit: string | null
    numberOfRows: number | null
    plantsPerRow: number | null
    totalPlantsExpected: number | null
    germinationDate: Date | null
    emergenceDate: Date | null
    germinationCount: number | null
    germinationPercentage: Decimal | null
    thinningDate: Date | null
    finalPlantCount: number | null
    plantedBy: string | null
    notes: string | null
    notesAr: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlantingCountAggregateOutputType = {
    id: number
    experimentId: number
    plotId: number
    germplasmId: number
    seedLotId: number
    plantingDate: number
    plantingMethod: number
    seedingRate: number
    seedingRateUnit: number
    seedsPerHill: number
    seedDepth: number
    seedDepthUnit: number
    rowSpacing: number
    plantSpacing: number
    spacingUnit: number
    plantedArea: number
    plantedAreaUnit: number
    numberOfRows: number
    plantsPerRow: number
    totalPlantsExpected: number
    germinationDate: number
    emergenceDate: number
    germinationCount: number
    germinationPercentage: number
    thinningDate: number
    finalPlantCount: number
    plantedBy: number
    notes: number
    notesAr: number
    photos: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlantingAvgAggregateInputType = {
    seedingRate?: true
    seedsPerHill?: true
    seedDepth?: true
    rowSpacing?: true
    plantSpacing?: true
    plantedArea?: true
    numberOfRows?: true
    plantsPerRow?: true
    totalPlantsExpected?: true
    germinationCount?: true
    germinationPercentage?: true
    finalPlantCount?: true
  }

  export type PlantingSumAggregateInputType = {
    seedingRate?: true
    seedsPerHill?: true
    seedDepth?: true
    rowSpacing?: true
    plantSpacing?: true
    plantedArea?: true
    numberOfRows?: true
    plantsPerRow?: true
    totalPlantsExpected?: true
    germinationCount?: true
    germinationPercentage?: true
    finalPlantCount?: true
  }

  export type PlantingMinAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    germplasmId?: true
    seedLotId?: true
    plantingDate?: true
    plantingMethod?: true
    seedingRate?: true
    seedingRateUnit?: true
    seedsPerHill?: true
    seedDepth?: true
    seedDepthUnit?: true
    rowSpacing?: true
    plantSpacing?: true
    spacingUnit?: true
    plantedArea?: true
    plantedAreaUnit?: true
    numberOfRows?: true
    plantsPerRow?: true
    totalPlantsExpected?: true
    germinationDate?: true
    emergenceDate?: true
    germinationCount?: true
    germinationPercentage?: true
    thinningDate?: true
    finalPlantCount?: true
    plantedBy?: true
    notes?: true
    notesAr?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlantingMaxAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    germplasmId?: true
    seedLotId?: true
    plantingDate?: true
    plantingMethod?: true
    seedingRate?: true
    seedingRateUnit?: true
    seedsPerHill?: true
    seedDepth?: true
    seedDepthUnit?: true
    rowSpacing?: true
    plantSpacing?: true
    spacingUnit?: true
    plantedArea?: true
    plantedAreaUnit?: true
    numberOfRows?: true
    plantsPerRow?: true
    totalPlantsExpected?: true
    germinationDate?: true
    emergenceDate?: true
    germinationCount?: true
    germinationPercentage?: true
    thinningDate?: true
    finalPlantCount?: true
    plantedBy?: true
    notes?: true
    notesAr?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlantingCountAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    germplasmId?: true
    seedLotId?: true
    plantingDate?: true
    plantingMethod?: true
    seedingRate?: true
    seedingRateUnit?: true
    seedsPerHill?: true
    seedDepth?: true
    seedDepthUnit?: true
    rowSpacing?: true
    plantSpacing?: true
    spacingUnit?: true
    plantedArea?: true
    plantedAreaUnit?: true
    numberOfRows?: true
    plantsPerRow?: true
    totalPlantsExpected?: true
    germinationDate?: true
    emergenceDate?: true
    germinationCount?: true
    germinationPercentage?: true
    thinningDate?: true
    finalPlantCount?: true
    plantedBy?: true
    notes?: true
    notesAr?: true
    photos?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlantingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Planting to aggregate.
     */
    where?: PlantingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plantings to fetch.
     */
    orderBy?: PlantingOrderByWithRelationInput | PlantingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plantings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plantings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plantings
    **/
    _count?: true | PlantingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantingMaxAggregateInputType
  }

  export type GetPlantingAggregateType<T extends PlantingAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanting[P]>
      : GetScalarType<T[P], AggregatePlanting[P]>
  }




  export type PlantingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantingWhereInput
    orderBy?: PlantingOrderByWithAggregationInput | PlantingOrderByWithAggregationInput[]
    by: PlantingScalarFieldEnum[] | PlantingScalarFieldEnum
    having?: PlantingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantingCountAggregateInputType | true
    _avg?: PlantingAvgAggregateInputType
    _sum?: PlantingSumAggregateInputType
    _min?: PlantingMinAggregateInputType
    _max?: PlantingMaxAggregateInputType
  }

  export type PlantingGroupByOutputType = {
    id: string
    experimentId: string
    plotId: string | null
    germplasmId: string
    seedLotId: string | null
    plantingDate: Date
    plantingMethod: string | null
    seedingRate: Decimal | null
    seedingRateUnit: string | null
    seedsPerHill: number | null
    seedDepth: Decimal | null
    seedDepthUnit: string | null
    rowSpacing: Decimal | null
    plantSpacing: Decimal | null
    spacingUnit: string | null
    plantedArea: Decimal | null
    plantedAreaUnit: string | null
    numberOfRows: number | null
    plantsPerRow: number | null
    totalPlantsExpected: number | null
    germinationDate: Date | null
    emergenceDate: Date | null
    germinationCount: number | null
    germinationPercentage: Decimal | null
    thinningDate: Date | null
    finalPlantCount: number | null
    plantedBy: string
    notes: string | null
    notesAr: string | null
    photos: string[]
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PlantingCountAggregateOutputType | null
    _avg: PlantingAvgAggregateOutputType | null
    _sum: PlantingSumAggregateOutputType | null
    _min: PlantingMinAggregateOutputType | null
    _max: PlantingMaxAggregateOutputType | null
  }

  type GetPlantingGroupByPayload<T extends PlantingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantingGroupByOutputType[P]>
            : GetScalarType<T[P], PlantingGroupByOutputType[P]>
        }
      >
    >


  export type PlantingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    germplasmId?: boolean
    seedLotId?: boolean
    plantingDate?: boolean
    plantingMethod?: boolean
    seedingRate?: boolean
    seedingRateUnit?: boolean
    seedsPerHill?: boolean
    seedDepth?: boolean
    seedDepthUnit?: boolean
    rowSpacing?: boolean
    plantSpacing?: boolean
    spacingUnit?: boolean
    plantedArea?: boolean
    plantedAreaUnit?: boolean
    numberOfRows?: boolean
    plantsPerRow?: boolean
    totalPlantsExpected?: boolean
    germinationDate?: boolean
    emergenceDate?: boolean
    germinationCount?: boolean
    germinationPercentage?: boolean
    thinningDate?: boolean
    finalPlantCount?: boolean
    plantedBy?: boolean
    notes?: boolean
    notesAr?: boolean
    photos?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    germplasm?: boolean | GermplasmDefaultArgs<ExtArgs>
    seedLot?: boolean | Planting$seedLotArgs<ExtArgs>
  }, ExtArgs["result"]["planting"]>

  export type PlantingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    germplasmId?: boolean
    seedLotId?: boolean
    plantingDate?: boolean
    plantingMethod?: boolean
    seedingRate?: boolean
    seedingRateUnit?: boolean
    seedsPerHill?: boolean
    seedDepth?: boolean
    seedDepthUnit?: boolean
    rowSpacing?: boolean
    plantSpacing?: boolean
    spacingUnit?: boolean
    plantedArea?: boolean
    plantedAreaUnit?: boolean
    numberOfRows?: boolean
    plantsPerRow?: boolean
    totalPlantsExpected?: boolean
    germinationDate?: boolean
    emergenceDate?: boolean
    germinationCount?: boolean
    germinationPercentage?: boolean
    thinningDate?: boolean
    finalPlantCount?: boolean
    plantedBy?: boolean
    notes?: boolean
    notesAr?: boolean
    photos?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    germplasm?: boolean | GermplasmDefaultArgs<ExtArgs>
    seedLot?: boolean | Planting$seedLotArgs<ExtArgs>
  }, ExtArgs["result"]["planting"]>

  export type PlantingSelectScalar = {
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    germplasmId?: boolean
    seedLotId?: boolean
    plantingDate?: boolean
    plantingMethod?: boolean
    seedingRate?: boolean
    seedingRateUnit?: boolean
    seedsPerHill?: boolean
    seedDepth?: boolean
    seedDepthUnit?: boolean
    rowSpacing?: boolean
    plantSpacing?: boolean
    spacingUnit?: boolean
    plantedArea?: boolean
    plantedAreaUnit?: boolean
    numberOfRows?: boolean
    plantsPerRow?: boolean
    totalPlantsExpected?: boolean
    germinationDate?: boolean
    emergenceDate?: boolean
    germinationCount?: boolean
    germinationPercentage?: boolean
    thinningDate?: boolean
    finalPlantCount?: boolean
    plantedBy?: boolean
    notes?: boolean
    notesAr?: boolean
    photos?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlantingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    germplasm?: boolean | GermplasmDefaultArgs<ExtArgs>
    seedLot?: boolean | Planting$seedLotArgs<ExtArgs>
  }
  export type PlantingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    germplasm?: boolean | GermplasmDefaultArgs<ExtArgs>
    seedLot?: boolean | Planting$seedLotArgs<ExtArgs>
  }

  export type $PlantingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Planting"
    objects: {
      experiment: Prisma.$ExperimentPayload<ExtArgs>
      germplasm: Prisma.$GermplasmPayload<ExtArgs>
      seedLot: Prisma.$SeedLotPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experimentId: string
      plotId: string | null
      germplasmId: string
      seedLotId: string | null
      plantingDate: Date
      plantingMethod: string | null
      seedingRate: Prisma.Decimal | null
      seedingRateUnit: string | null
      seedsPerHill: number | null
      seedDepth: Prisma.Decimal | null
      seedDepthUnit: string | null
      rowSpacing: Prisma.Decimal | null
      plantSpacing: Prisma.Decimal | null
      spacingUnit: string | null
      plantedArea: Prisma.Decimal | null
      plantedAreaUnit: string | null
      numberOfRows: number | null
      plantsPerRow: number | null
      totalPlantsExpected: number | null
      germinationDate: Date | null
      emergenceDate: Date | null
      germinationCount: number | null
      germinationPercentage: Prisma.Decimal | null
      thinningDate: Date | null
      finalPlantCount: number | null
      plantedBy: string
      notes: string | null
      notesAr: string | null
      photos: string[]
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planting"]>
    composites: {}
  }

  type PlantingGetPayload<S extends boolean | null | undefined | PlantingDefaultArgs> = $Result.GetResult<Prisma.$PlantingPayload, S>

  type PlantingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlantingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlantingCountAggregateInputType | true
    }

  export interface PlantingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Planting'], meta: { name: 'Planting' } }
    /**
     * Find zero or one Planting that matches the filter.
     * @param {PlantingFindUniqueArgs} args - Arguments to find a Planting
     * @example
     * // Get one Planting
     * const planting = await prisma.planting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantingFindUniqueArgs>(args: SelectSubset<T, PlantingFindUniqueArgs<ExtArgs>>): Prisma__PlantingClient<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Planting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlantingFindUniqueOrThrowArgs} args - Arguments to find a Planting
     * @example
     * // Get one Planting
     * const planting = await prisma.planting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantingFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantingClient<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Planting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantingFindFirstArgs} args - Arguments to find a Planting
     * @example
     * // Get one Planting
     * const planting = await prisma.planting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantingFindFirstArgs>(args?: SelectSubset<T, PlantingFindFirstArgs<ExtArgs>>): Prisma__PlantingClient<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Planting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantingFindFirstOrThrowArgs} args - Arguments to find a Planting
     * @example
     * // Get one Planting
     * const planting = await prisma.planting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantingFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantingClient<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plantings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plantings
     * const plantings = await prisma.planting.findMany()
     * 
     * // Get first 10 Plantings
     * const plantings = await prisma.planting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantingWithIdOnly = await prisma.planting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantingFindManyArgs>(args?: SelectSubset<T, PlantingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Planting.
     * @param {PlantingCreateArgs} args - Arguments to create a Planting.
     * @example
     * // Create one Planting
     * const Planting = await prisma.planting.create({
     *   data: {
     *     // ... data to create a Planting
     *   }
     * })
     * 
     */
    create<T extends PlantingCreateArgs>(args: SelectSubset<T, PlantingCreateArgs<ExtArgs>>): Prisma__PlantingClient<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plantings.
     * @param {PlantingCreateManyArgs} args - Arguments to create many Plantings.
     * @example
     * // Create many Plantings
     * const planting = await prisma.planting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantingCreateManyArgs>(args?: SelectSubset<T, PlantingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plantings and returns the data saved in the database.
     * @param {PlantingCreateManyAndReturnArgs} args - Arguments to create many Plantings.
     * @example
     * // Create many Plantings
     * const planting = await prisma.planting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plantings and only return the `id`
     * const plantingWithIdOnly = await prisma.planting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantingCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Planting.
     * @param {PlantingDeleteArgs} args - Arguments to delete one Planting.
     * @example
     * // Delete one Planting
     * const Planting = await prisma.planting.delete({
     *   where: {
     *     // ... filter to delete one Planting
     *   }
     * })
     * 
     */
    delete<T extends PlantingDeleteArgs>(args: SelectSubset<T, PlantingDeleteArgs<ExtArgs>>): Prisma__PlantingClient<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Planting.
     * @param {PlantingUpdateArgs} args - Arguments to update one Planting.
     * @example
     * // Update one Planting
     * const planting = await prisma.planting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantingUpdateArgs>(args: SelectSubset<T, PlantingUpdateArgs<ExtArgs>>): Prisma__PlantingClient<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plantings.
     * @param {PlantingDeleteManyArgs} args - Arguments to filter Plantings to delete.
     * @example
     * // Delete a few Plantings
     * const { count } = await prisma.planting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantingDeleteManyArgs>(args?: SelectSubset<T, PlantingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plantings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plantings
     * const planting = await prisma.planting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantingUpdateManyArgs>(args: SelectSubset<T, PlantingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Planting.
     * @param {PlantingUpsertArgs} args - Arguments to update or create a Planting.
     * @example
     * // Update or create a Planting
     * const planting = await prisma.planting.upsert({
     *   create: {
     *     // ... data to create a Planting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Planting we want to update
     *   }
     * })
     */
    upsert<T extends PlantingUpsertArgs>(args: SelectSubset<T, PlantingUpsertArgs<ExtArgs>>): Prisma__PlantingClient<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plantings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantingCountArgs} args - Arguments to filter Plantings to count.
     * @example
     * // Count the number of Plantings
     * const count = await prisma.planting.count({
     *   where: {
     *     // ... the filter for the Plantings we want to count
     *   }
     * })
    **/
    count<T extends PlantingCountArgs>(
      args?: Subset<T, PlantingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Planting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantingAggregateArgs>(args: Subset<T, PlantingAggregateArgs>): Prisma.PrismaPromise<GetPlantingAggregateType<T>>

    /**
     * Group by Planting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantingGroupByArgs['orderBy'] }
        : { orderBy?: PlantingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Planting model
   */
  readonly fields: PlantingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Planting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiment<T extends ExperimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperimentDefaultArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    germplasm<T extends GermplasmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GermplasmDefaultArgs<ExtArgs>>): Prisma__GermplasmClient<$Result.GetResult<Prisma.$GermplasmPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    seedLot<T extends Planting$seedLotArgs<ExtArgs> = {}>(args?: Subset<T, Planting$seedLotArgs<ExtArgs>>): Prisma__SeedLotClient<$Result.GetResult<Prisma.$SeedLotPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Planting model
   */ 
  interface PlantingFieldRefs {
    readonly id: FieldRef<"Planting", 'String'>
    readonly experimentId: FieldRef<"Planting", 'String'>
    readonly plotId: FieldRef<"Planting", 'String'>
    readonly germplasmId: FieldRef<"Planting", 'String'>
    readonly seedLotId: FieldRef<"Planting", 'String'>
    readonly plantingDate: FieldRef<"Planting", 'DateTime'>
    readonly plantingMethod: FieldRef<"Planting", 'String'>
    readonly seedingRate: FieldRef<"Planting", 'Decimal'>
    readonly seedingRateUnit: FieldRef<"Planting", 'String'>
    readonly seedsPerHill: FieldRef<"Planting", 'Int'>
    readonly seedDepth: FieldRef<"Planting", 'Decimal'>
    readonly seedDepthUnit: FieldRef<"Planting", 'String'>
    readonly rowSpacing: FieldRef<"Planting", 'Decimal'>
    readonly plantSpacing: FieldRef<"Planting", 'Decimal'>
    readonly spacingUnit: FieldRef<"Planting", 'String'>
    readonly plantedArea: FieldRef<"Planting", 'Decimal'>
    readonly plantedAreaUnit: FieldRef<"Planting", 'String'>
    readonly numberOfRows: FieldRef<"Planting", 'Int'>
    readonly plantsPerRow: FieldRef<"Planting", 'Int'>
    readonly totalPlantsExpected: FieldRef<"Planting", 'Int'>
    readonly germinationDate: FieldRef<"Planting", 'DateTime'>
    readonly emergenceDate: FieldRef<"Planting", 'DateTime'>
    readonly germinationCount: FieldRef<"Planting", 'Int'>
    readonly germinationPercentage: FieldRef<"Planting", 'Decimal'>
    readonly thinningDate: FieldRef<"Planting", 'DateTime'>
    readonly finalPlantCount: FieldRef<"Planting", 'Int'>
    readonly plantedBy: FieldRef<"Planting", 'String'>
    readonly notes: FieldRef<"Planting", 'String'>
    readonly notesAr: FieldRef<"Planting", 'String'>
    readonly photos: FieldRef<"Planting", 'String[]'>
    readonly metadata: FieldRef<"Planting", 'Json'>
    readonly createdAt: FieldRef<"Planting", 'DateTime'>
    readonly updatedAt: FieldRef<"Planting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Planting findUnique
   */
  export type PlantingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    /**
     * Filter, which Planting to fetch.
     */
    where: PlantingWhereUniqueInput
  }

  /**
   * Planting findUniqueOrThrow
   */
  export type PlantingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    /**
     * Filter, which Planting to fetch.
     */
    where: PlantingWhereUniqueInput
  }

  /**
   * Planting findFirst
   */
  export type PlantingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    /**
     * Filter, which Planting to fetch.
     */
    where?: PlantingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plantings to fetch.
     */
    orderBy?: PlantingOrderByWithRelationInput | PlantingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plantings.
     */
    cursor?: PlantingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plantings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plantings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plantings.
     */
    distinct?: PlantingScalarFieldEnum | PlantingScalarFieldEnum[]
  }

  /**
   * Planting findFirstOrThrow
   */
  export type PlantingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    /**
     * Filter, which Planting to fetch.
     */
    where?: PlantingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plantings to fetch.
     */
    orderBy?: PlantingOrderByWithRelationInput | PlantingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plantings.
     */
    cursor?: PlantingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plantings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plantings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plantings.
     */
    distinct?: PlantingScalarFieldEnum | PlantingScalarFieldEnum[]
  }

  /**
   * Planting findMany
   */
  export type PlantingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    /**
     * Filter, which Plantings to fetch.
     */
    where?: PlantingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plantings to fetch.
     */
    orderBy?: PlantingOrderByWithRelationInput | PlantingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plantings.
     */
    cursor?: PlantingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plantings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plantings.
     */
    skip?: number
    distinct?: PlantingScalarFieldEnum | PlantingScalarFieldEnum[]
  }

  /**
   * Planting create
   */
  export type PlantingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    /**
     * The data needed to create a Planting.
     */
    data: XOR<PlantingCreateInput, PlantingUncheckedCreateInput>
  }

  /**
   * Planting createMany
   */
  export type PlantingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plantings.
     */
    data: PlantingCreateManyInput | PlantingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Planting createManyAndReturn
   */
  export type PlantingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Plantings.
     */
    data: PlantingCreateManyInput | PlantingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Planting update
   */
  export type PlantingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    /**
     * The data needed to update a Planting.
     */
    data: XOR<PlantingUpdateInput, PlantingUncheckedUpdateInput>
    /**
     * Choose, which Planting to update.
     */
    where: PlantingWhereUniqueInput
  }

  /**
   * Planting updateMany
   */
  export type PlantingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plantings.
     */
    data: XOR<PlantingUpdateManyMutationInput, PlantingUncheckedUpdateManyInput>
    /**
     * Filter which Plantings to update
     */
    where?: PlantingWhereInput
  }

  /**
   * Planting upsert
   */
  export type PlantingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    /**
     * The filter to search for the Planting to update in case it exists.
     */
    where: PlantingWhereUniqueInput
    /**
     * In case the Planting found by the `where` argument doesn't exist, create a new Planting with this data.
     */
    create: XOR<PlantingCreateInput, PlantingUncheckedCreateInput>
    /**
     * In case the Planting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantingUpdateInput, PlantingUncheckedUpdateInput>
  }

  /**
   * Planting delete
   */
  export type PlantingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    /**
     * Filter which Planting to delete.
     */
    where: PlantingWhereUniqueInput
  }

  /**
   * Planting deleteMany
   */
  export type PlantingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plantings to delete
     */
    where?: PlantingWhereInput
  }

  /**
   * Planting.seedLot
   */
  export type Planting$seedLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeedLot
     */
    select?: SeedLotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeedLotInclude<ExtArgs> | null
    where?: SeedLotWhereInput
  }

  /**
   * Planting without action
   */
  export type PlantingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
  }


  /**
   * Model Experiment
   */

  export type AggregateExperiment = {
    _count: ExperimentCountAggregateOutputType | null
    _avg: ExperimentAvgAggregateOutputType | null
    _sum: ExperimentSumAggregateOutputType | null
    _min: ExperimentMinAggregateOutputType | null
    _max: ExperimentMaxAggregateOutputType | null
  }

  export type ExperimentAvgAggregateOutputType = {
    version: number | null
  }

  export type ExperimentSumAggregateOutputType = {
    version: number | null
  }

  export type ExperimentMinAggregateOutputType = {
    id: string | null
    title: string | null
    titleAr: string | null
    description: string | null
    descriptionAr: string | null
    hypothesis: string | null
    hypothesisAr: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.ExperimentStatus | null
    lockedAt: Date | null
    lockedBy: string | null
    principalResearcherId: string | null
    organizationId: string | null
    farmId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    version: number | null
  }

  export type ExperimentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    titleAr: string | null
    description: string | null
    descriptionAr: string | null
    hypothesis: string | null
    hypothesisAr: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.ExperimentStatus | null
    lockedAt: Date | null
    lockedBy: string | null
    principalResearcherId: string | null
    organizationId: string | null
    farmId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    version: number | null
  }

  export type ExperimentCountAggregateOutputType = {
    id: number
    title: number
    titleAr: number
    description: number
    descriptionAr: number
    hypothesis: number
    hypothesisAr: number
    startDate: number
    endDate: number
    status: number
    lockedAt: number
    lockedBy: number
    principalResearcherId: number
    organizationId: number
    farmId: number
    metadata: number
    tags: number
    createdAt: number
    updatedAt: number
    version: number
    _all: number
  }


  export type ExperimentAvgAggregateInputType = {
    version?: true
  }

  export type ExperimentSumAggregateInputType = {
    version?: true
  }

  export type ExperimentMinAggregateInputType = {
    id?: true
    title?: true
    titleAr?: true
    description?: true
    descriptionAr?: true
    hypothesis?: true
    hypothesisAr?: true
    startDate?: true
    endDate?: true
    status?: true
    lockedAt?: true
    lockedBy?: true
    principalResearcherId?: true
    organizationId?: true
    farmId?: true
    createdAt?: true
    updatedAt?: true
    version?: true
  }

  export type ExperimentMaxAggregateInputType = {
    id?: true
    title?: true
    titleAr?: true
    description?: true
    descriptionAr?: true
    hypothesis?: true
    hypothesisAr?: true
    startDate?: true
    endDate?: true
    status?: true
    lockedAt?: true
    lockedBy?: true
    principalResearcherId?: true
    organizationId?: true
    farmId?: true
    createdAt?: true
    updatedAt?: true
    version?: true
  }

  export type ExperimentCountAggregateInputType = {
    id?: true
    title?: true
    titleAr?: true
    description?: true
    descriptionAr?: true
    hypothesis?: true
    hypothesisAr?: true
    startDate?: true
    endDate?: true
    status?: true
    lockedAt?: true
    lockedBy?: true
    principalResearcherId?: true
    organizationId?: true
    farmId?: true
    metadata?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    version?: true
    _all?: true
  }

  export type ExperimentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Experiment to aggregate.
     */
    where?: ExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiments to fetch.
     */
    orderBy?: ExperimentOrderByWithRelationInput | ExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Experiments
    **/
    _count?: true | ExperimentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExperimentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExperimentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperimentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperimentMaxAggregateInputType
  }

  export type GetExperimentAggregateType<T extends ExperimentAggregateArgs> = {
        [P in keyof T & keyof AggregateExperiment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperiment[P]>
      : GetScalarType<T[P], AggregateExperiment[P]>
  }




  export type ExperimentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperimentWhereInput
    orderBy?: ExperimentOrderByWithAggregationInput | ExperimentOrderByWithAggregationInput[]
    by: ExperimentScalarFieldEnum[] | ExperimentScalarFieldEnum
    having?: ExperimentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperimentCountAggregateInputType | true
    _avg?: ExperimentAvgAggregateInputType
    _sum?: ExperimentSumAggregateInputType
    _min?: ExperimentMinAggregateInputType
    _max?: ExperimentMaxAggregateInputType
  }

  export type ExperimentGroupByOutputType = {
    id: string
    title: string
    titleAr: string | null
    description: string | null
    descriptionAr: string | null
    hypothesis: string | null
    hypothesisAr: string | null
    startDate: Date
    endDate: Date | null
    status: $Enums.ExperimentStatus
    lockedAt: Date | null
    lockedBy: string | null
    principalResearcherId: string
    organizationId: string | null
    farmId: string | null
    metadata: JsonValue
    tags: string[]
    createdAt: Date
    updatedAt: Date
    version: number
    _count: ExperimentCountAggregateOutputType | null
    _avg: ExperimentAvgAggregateOutputType | null
    _sum: ExperimentSumAggregateOutputType | null
    _min: ExperimentMinAggregateOutputType | null
    _max: ExperimentMaxAggregateOutputType | null
  }

  type GetExperimentGroupByPayload<T extends ExperimentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperimentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperimentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperimentGroupByOutputType[P]>
            : GetScalarType<T[P], ExperimentGroupByOutputType[P]>
        }
      >
    >


  export type ExperimentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleAr?: boolean
    description?: boolean
    descriptionAr?: boolean
    hypothesis?: boolean
    hypothesisAr?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
    principalResearcherId?: boolean
    organizationId?: boolean
    farmId?: boolean
    metadata?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
    protocols?: boolean | Experiment$protocolsArgs<ExtArgs>
    plots?: boolean | Experiment$plotsArgs<ExtArgs>
    treatments?: boolean | Experiment$treatmentsArgs<ExtArgs>
    logs?: boolean | Experiment$logsArgs<ExtArgs>
    samples?: boolean | Experiment$samplesArgs<ExtArgs>
    collaborators?: boolean | Experiment$collaboratorsArgs<ExtArgs>
    auditLogs?: boolean | Experiment$auditLogsArgs<ExtArgs>
    plantings?: boolean | Experiment$plantingsArgs<ExtArgs>
    _count?: boolean | ExperimentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experiment"]>

  export type ExperimentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    titleAr?: boolean
    description?: boolean
    descriptionAr?: boolean
    hypothesis?: boolean
    hypothesisAr?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
    principalResearcherId?: boolean
    organizationId?: boolean
    farmId?: boolean
    metadata?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
  }, ExtArgs["result"]["experiment"]>

  export type ExperimentSelectScalar = {
    id?: boolean
    title?: boolean
    titleAr?: boolean
    description?: boolean
    descriptionAr?: boolean
    hypothesis?: boolean
    hypothesisAr?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    lockedAt?: boolean
    lockedBy?: boolean
    principalResearcherId?: boolean
    organizationId?: boolean
    farmId?: boolean
    metadata?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    version?: boolean
  }

  export type ExperimentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocols?: boolean | Experiment$protocolsArgs<ExtArgs>
    plots?: boolean | Experiment$plotsArgs<ExtArgs>
    treatments?: boolean | Experiment$treatmentsArgs<ExtArgs>
    logs?: boolean | Experiment$logsArgs<ExtArgs>
    samples?: boolean | Experiment$samplesArgs<ExtArgs>
    collaborators?: boolean | Experiment$collaboratorsArgs<ExtArgs>
    auditLogs?: boolean | Experiment$auditLogsArgs<ExtArgs>
    plantings?: boolean | Experiment$plantingsArgs<ExtArgs>
    _count?: boolean | ExperimentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExperimentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExperimentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Experiment"
    objects: {
      protocols: Prisma.$ResearchProtocolPayload<ExtArgs>[]
      plots: Prisma.$ResearchPlotPayload<ExtArgs>[]
      treatments: Prisma.$TreatmentPayload<ExtArgs>[]
      logs: Prisma.$ResearchDailyLogPayload<ExtArgs>[]
      samples: Prisma.$LabSamplePayload<ExtArgs>[]
      collaborators: Prisma.$ExperimentCollaboratorPayload<ExtArgs>[]
      auditLogs: Prisma.$ExperimentAuditLogPayload<ExtArgs>[]
      plantings: Prisma.$PlantingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      titleAr: string | null
      description: string | null
      descriptionAr: string | null
      hypothesis: string | null
      hypothesisAr: string | null
      startDate: Date
      endDate: Date | null
      status: $Enums.ExperimentStatus
      lockedAt: Date | null
      lockedBy: string | null
      principalResearcherId: string
      organizationId: string | null
      farmId: string | null
      metadata: Prisma.JsonValue
      tags: string[]
      createdAt: Date
      updatedAt: Date
      version: number
    }, ExtArgs["result"]["experiment"]>
    composites: {}
  }

  type ExperimentGetPayload<S extends boolean | null | undefined | ExperimentDefaultArgs> = $Result.GetResult<Prisma.$ExperimentPayload, S>

  type ExperimentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExperimentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExperimentCountAggregateInputType | true
    }

  export interface ExperimentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Experiment'], meta: { name: 'Experiment' } }
    /**
     * Find zero or one Experiment that matches the filter.
     * @param {ExperimentFindUniqueArgs} args - Arguments to find a Experiment
     * @example
     * // Get one Experiment
     * const experiment = await prisma.experiment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExperimentFindUniqueArgs>(args: SelectSubset<T, ExperimentFindUniqueArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Experiment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExperimentFindUniqueOrThrowArgs} args - Arguments to find a Experiment
     * @example
     * // Get one Experiment
     * const experiment = await prisma.experiment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExperimentFindUniqueOrThrowArgs>(args: SelectSubset<T, ExperimentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Experiment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentFindFirstArgs} args - Arguments to find a Experiment
     * @example
     * // Get one Experiment
     * const experiment = await prisma.experiment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExperimentFindFirstArgs>(args?: SelectSubset<T, ExperimentFindFirstArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Experiment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentFindFirstOrThrowArgs} args - Arguments to find a Experiment
     * @example
     * // Get one Experiment
     * const experiment = await prisma.experiment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExperimentFindFirstOrThrowArgs>(args?: SelectSubset<T, ExperimentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Experiments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Experiments
     * const experiments = await prisma.experiment.findMany()
     * 
     * // Get first 10 Experiments
     * const experiments = await prisma.experiment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experimentWithIdOnly = await prisma.experiment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExperimentFindManyArgs>(args?: SelectSubset<T, ExperimentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Experiment.
     * @param {ExperimentCreateArgs} args - Arguments to create a Experiment.
     * @example
     * // Create one Experiment
     * const Experiment = await prisma.experiment.create({
     *   data: {
     *     // ... data to create a Experiment
     *   }
     * })
     * 
     */
    create<T extends ExperimentCreateArgs>(args: SelectSubset<T, ExperimentCreateArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Experiments.
     * @param {ExperimentCreateManyArgs} args - Arguments to create many Experiments.
     * @example
     * // Create many Experiments
     * const experiment = await prisma.experiment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExperimentCreateManyArgs>(args?: SelectSubset<T, ExperimentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Experiments and returns the data saved in the database.
     * @param {ExperimentCreateManyAndReturnArgs} args - Arguments to create many Experiments.
     * @example
     * // Create many Experiments
     * const experiment = await prisma.experiment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Experiments and only return the `id`
     * const experimentWithIdOnly = await prisma.experiment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExperimentCreateManyAndReturnArgs>(args?: SelectSubset<T, ExperimentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Experiment.
     * @param {ExperimentDeleteArgs} args - Arguments to delete one Experiment.
     * @example
     * // Delete one Experiment
     * const Experiment = await prisma.experiment.delete({
     *   where: {
     *     // ... filter to delete one Experiment
     *   }
     * })
     * 
     */
    delete<T extends ExperimentDeleteArgs>(args: SelectSubset<T, ExperimentDeleteArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Experiment.
     * @param {ExperimentUpdateArgs} args - Arguments to update one Experiment.
     * @example
     * // Update one Experiment
     * const experiment = await prisma.experiment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExperimentUpdateArgs>(args: SelectSubset<T, ExperimentUpdateArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Experiments.
     * @param {ExperimentDeleteManyArgs} args - Arguments to filter Experiments to delete.
     * @example
     * // Delete a few Experiments
     * const { count } = await prisma.experiment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExperimentDeleteManyArgs>(args?: SelectSubset<T, ExperimentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Experiments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Experiments
     * const experiment = await prisma.experiment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExperimentUpdateManyArgs>(args: SelectSubset<T, ExperimentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Experiment.
     * @param {ExperimentUpsertArgs} args - Arguments to update or create a Experiment.
     * @example
     * // Update or create a Experiment
     * const experiment = await prisma.experiment.upsert({
     *   create: {
     *     // ... data to create a Experiment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Experiment we want to update
     *   }
     * })
     */
    upsert<T extends ExperimentUpsertArgs>(args: SelectSubset<T, ExperimentUpsertArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Experiments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentCountArgs} args - Arguments to filter Experiments to count.
     * @example
     * // Count the number of Experiments
     * const count = await prisma.experiment.count({
     *   where: {
     *     // ... the filter for the Experiments we want to count
     *   }
     * })
    **/
    count<T extends ExperimentCountArgs>(
      args?: Subset<T, ExperimentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperimentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Experiment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperimentAggregateArgs>(args: Subset<T, ExperimentAggregateArgs>): Prisma.PrismaPromise<GetExperimentAggregateType<T>>

    /**
     * Group by Experiment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExperimentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExperimentGroupByArgs['orderBy'] }
        : { orderBy?: ExperimentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExperimentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperimentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Experiment model
   */
  readonly fields: ExperimentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Experiment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExperimentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    protocols<T extends Experiment$protocolsArgs<ExtArgs> = {}>(args?: Subset<T, Experiment$protocolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "findMany"> | Null>
    plots<T extends Experiment$plotsArgs<ExtArgs> = {}>(args?: Subset<T, Experiment$plotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "findMany"> | Null>
    treatments<T extends Experiment$treatmentsArgs<ExtArgs> = {}>(args?: Subset<T, Experiment$treatmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends Experiment$logsArgs<ExtArgs> = {}>(args?: Subset<T, Experiment$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "findMany"> | Null>
    samples<T extends Experiment$samplesArgs<ExtArgs> = {}>(args?: Subset<T, Experiment$samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "findMany"> | Null>
    collaborators<T extends Experiment$collaboratorsArgs<ExtArgs> = {}>(args?: Subset<T, Experiment$collaboratorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Experiment$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Experiment$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    plantings<T extends Experiment$plantingsArgs<ExtArgs> = {}>(args?: Subset<T, Experiment$plantingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Experiment model
   */ 
  interface ExperimentFieldRefs {
    readonly id: FieldRef<"Experiment", 'String'>
    readonly title: FieldRef<"Experiment", 'String'>
    readonly titleAr: FieldRef<"Experiment", 'String'>
    readonly description: FieldRef<"Experiment", 'String'>
    readonly descriptionAr: FieldRef<"Experiment", 'String'>
    readonly hypothesis: FieldRef<"Experiment", 'String'>
    readonly hypothesisAr: FieldRef<"Experiment", 'String'>
    readonly startDate: FieldRef<"Experiment", 'DateTime'>
    readonly endDate: FieldRef<"Experiment", 'DateTime'>
    readonly status: FieldRef<"Experiment", 'ExperimentStatus'>
    readonly lockedAt: FieldRef<"Experiment", 'DateTime'>
    readonly lockedBy: FieldRef<"Experiment", 'String'>
    readonly principalResearcherId: FieldRef<"Experiment", 'String'>
    readonly organizationId: FieldRef<"Experiment", 'String'>
    readonly farmId: FieldRef<"Experiment", 'String'>
    readonly metadata: FieldRef<"Experiment", 'Json'>
    readonly tags: FieldRef<"Experiment", 'String[]'>
    readonly createdAt: FieldRef<"Experiment", 'DateTime'>
    readonly updatedAt: FieldRef<"Experiment", 'DateTime'>
    readonly version: FieldRef<"Experiment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Experiment findUnique
   */
  export type ExperimentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    /**
     * Filter, which Experiment to fetch.
     */
    where: ExperimentWhereUniqueInput
  }

  /**
   * Experiment findUniqueOrThrow
   */
  export type ExperimentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    /**
     * Filter, which Experiment to fetch.
     */
    where: ExperimentWhereUniqueInput
  }

  /**
   * Experiment findFirst
   */
  export type ExperimentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    /**
     * Filter, which Experiment to fetch.
     */
    where?: ExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiments to fetch.
     */
    orderBy?: ExperimentOrderByWithRelationInput | ExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Experiments.
     */
    cursor?: ExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Experiments.
     */
    distinct?: ExperimentScalarFieldEnum | ExperimentScalarFieldEnum[]
  }

  /**
   * Experiment findFirstOrThrow
   */
  export type ExperimentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    /**
     * Filter, which Experiment to fetch.
     */
    where?: ExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiments to fetch.
     */
    orderBy?: ExperimentOrderByWithRelationInput | ExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Experiments.
     */
    cursor?: ExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Experiments.
     */
    distinct?: ExperimentScalarFieldEnum | ExperimentScalarFieldEnum[]
  }

  /**
   * Experiment findMany
   */
  export type ExperimentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    /**
     * Filter, which Experiments to fetch.
     */
    where?: ExperimentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiments to fetch.
     */
    orderBy?: ExperimentOrderByWithRelationInput | ExperimentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Experiments.
     */
    cursor?: ExperimentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiments.
     */
    skip?: number
    distinct?: ExperimentScalarFieldEnum | ExperimentScalarFieldEnum[]
  }

  /**
   * Experiment create
   */
  export type ExperimentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    /**
     * The data needed to create a Experiment.
     */
    data: XOR<ExperimentCreateInput, ExperimentUncheckedCreateInput>
  }

  /**
   * Experiment createMany
   */
  export type ExperimentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Experiments.
     */
    data: ExperimentCreateManyInput | ExperimentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Experiment createManyAndReturn
   */
  export type ExperimentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Experiments.
     */
    data: ExperimentCreateManyInput | ExperimentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Experiment update
   */
  export type ExperimentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    /**
     * The data needed to update a Experiment.
     */
    data: XOR<ExperimentUpdateInput, ExperimentUncheckedUpdateInput>
    /**
     * Choose, which Experiment to update.
     */
    where: ExperimentWhereUniqueInput
  }

  /**
   * Experiment updateMany
   */
  export type ExperimentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Experiments.
     */
    data: XOR<ExperimentUpdateManyMutationInput, ExperimentUncheckedUpdateManyInput>
    /**
     * Filter which Experiments to update
     */
    where?: ExperimentWhereInput
  }

  /**
   * Experiment upsert
   */
  export type ExperimentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    /**
     * The filter to search for the Experiment to update in case it exists.
     */
    where: ExperimentWhereUniqueInput
    /**
     * In case the Experiment found by the `where` argument doesn't exist, create a new Experiment with this data.
     */
    create: XOR<ExperimentCreateInput, ExperimentUncheckedCreateInput>
    /**
     * In case the Experiment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExperimentUpdateInput, ExperimentUncheckedUpdateInput>
  }

  /**
   * Experiment delete
   */
  export type ExperimentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    /**
     * Filter which Experiment to delete.
     */
    where: ExperimentWhereUniqueInput
  }

  /**
   * Experiment deleteMany
   */
  export type ExperimentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Experiments to delete
     */
    where?: ExperimentWhereInput
  }

  /**
   * Experiment.protocols
   */
  export type Experiment$protocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    where?: ResearchProtocolWhereInput
    orderBy?: ResearchProtocolOrderByWithRelationInput | ResearchProtocolOrderByWithRelationInput[]
    cursor?: ResearchProtocolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchProtocolScalarFieldEnum | ResearchProtocolScalarFieldEnum[]
  }

  /**
   * Experiment.plots
   */
  export type Experiment$plotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    where?: ResearchPlotWhereInput
    orderBy?: ResearchPlotOrderByWithRelationInput | ResearchPlotOrderByWithRelationInput[]
    cursor?: ResearchPlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchPlotScalarFieldEnum | ResearchPlotScalarFieldEnum[]
  }

  /**
   * Experiment.treatments
   */
  export type Experiment$treatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    cursor?: TreatmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Experiment.logs
   */
  export type Experiment$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    where?: ResearchDailyLogWhereInput
    orderBy?: ResearchDailyLogOrderByWithRelationInput | ResearchDailyLogOrderByWithRelationInput[]
    cursor?: ResearchDailyLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchDailyLogScalarFieldEnum | ResearchDailyLogScalarFieldEnum[]
  }

  /**
   * Experiment.samples
   */
  export type Experiment$samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    where?: LabSampleWhereInput
    orderBy?: LabSampleOrderByWithRelationInput | LabSampleOrderByWithRelationInput[]
    cursor?: LabSampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabSampleScalarFieldEnum | LabSampleScalarFieldEnum[]
  }

  /**
   * Experiment.collaborators
   */
  export type Experiment$collaboratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    where?: ExperimentCollaboratorWhereInput
    orderBy?: ExperimentCollaboratorOrderByWithRelationInput | ExperimentCollaboratorOrderByWithRelationInput[]
    cursor?: ExperimentCollaboratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperimentCollaboratorScalarFieldEnum | ExperimentCollaboratorScalarFieldEnum[]
  }

  /**
   * Experiment.auditLogs
   */
  export type Experiment$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    where?: ExperimentAuditLogWhereInput
    orderBy?: ExperimentAuditLogOrderByWithRelationInput | ExperimentAuditLogOrderByWithRelationInput[]
    cursor?: ExperimentAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperimentAuditLogScalarFieldEnum | ExperimentAuditLogScalarFieldEnum[]
  }

  /**
   * Experiment.plantings
   */
  export type Experiment$plantingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planting
     */
    select?: PlantingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantingInclude<ExtArgs> | null
    where?: PlantingWhereInput
    orderBy?: PlantingOrderByWithRelationInput | PlantingOrderByWithRelationInput[]
    cursor?: PlantingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlantingScalarFieldEnum | PlantingScalarFieldEnum[]
  }

  /**
   * Experiment without action
   */
  export type ExperimentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
  }


  /**
   * Model ResearchProtocol
   */

  export type AggregateResearchProtocol = {
    _count: ResearchProtocolCountAggregateOutputType | null
    _avg: ResearchProtocolAvgAggregateOutputType | null
    _sum: ResearchProtocolSumAggregateOutputType | null
    _min: ResearchProtocolMinAggregateOutputType | null
    _max: ResearchProtocolMaxAggregateOutputType | null
  }

  export type ResearchProtocolAvgAggregateOutputType = {
    version: number | null
  }

  export type ResearchProtocolSumAggregateOutputType = {
    version: number | null
  }

  export type ResearchProtocolMinAggregateOutputType = {
    id: string | null
    experimentId: string | null
    name: string | null
    nameAr: string | null
    description: string | null
    descriptionAr: string | null
    methodology: string | null
    methodologyAr: string | null
    safetyGuidelines: string | null
    version: number | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchProtocolMaxAggregateOutputType = {
    id: string | null
    experimentId: string | null
    name: string | null
    nameAr: string | null
    description: string | null
    descriptionAr: string | null
    methodology: string | null
    methodologyAr: string | null
    safetyGuidelines: string | null
    version: number | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchProtocolCountAggregateOutputType = {
    id: number
    experimentId: number
    name: number
    nameAr: number
    description: number
    descriptionAr: number
    methodology: number
    methodologyAr: number
    variables: number
    measurementSchedule: number
    equipmentRequired: number
    safetyGuidelines: number
    version: number
    approvedBy: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResearchProtocolAvgAggregateInputType = {
    version?: true
  }

  export type ResearchProtocolSumAggregateInputType = {
    version?: true
  }

  export type ResearchProtocolMinAggregateInputType = {
    id?: true
    experimentId?: true
    name?: true
    nameAr?: true
    description?: true
    descriptionAr?: true
    methodology?: true
    methodologyAr?: true
    safetyGuidelines?: true
    version?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchProtocolMaxAggregateInputType = {
    id?: true
    experimentId?: true
    name?: true
    nameAr?: true
    description?: true
    descriptionAr?: true
    methodology?: true
    methodologyAr?: true
    safetyGuidelines?: true
    version?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchProtocolCountAggregateInputType = {
    id?: true
    experimentId?: true
    name?: true
    nameAr?: true
    description?: true
    descriptionAr?: true
    methodology?: true
    methodologyAr?: true
    variables?: true
    measurementSchedule?: true
    equipmentRequired?: true
    safetyGuidelines?: true
    version?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResearchProtocolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchProtocol to aggregate.
     */
    where?: ResearchProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProtocols to fetch.
     */
    orderBy?: ResearchProtocolOrderByWithRelationInput | ResearchProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProtocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProtocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchProtocols
    **/
    _count?: true | ResearchProtocolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchProtocolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchProtocolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchProtocolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchProtocolMaxAggregateInputType
  }

  export type GetResearchProtocolAggregateType<T extends ResearchProtocolAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchProtocol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchProtocol[P]>
      : GetScalarType<T[P], AggregateResearchProtocol[P]>
  }




  export type ResearchProtocolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchProtocolWhereInput
    orderBy?: ResearchProtocolOrderByWithAggregationInput | ResearchProtocolOrderByWithAggregationInput[]
    by: ResearchProtocolScalarFieldEnum[] | ResearchProtocolScalarFieldEnum
    having?: ResearchProtocolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchProtocolCountAggregateInputType | true
    _avg?: ResearchProtocolAvgAggregateInputType
    _sum?: ResearchProtocolSumAggregateInputType
    _min?: ResearchProtocolMinAggregateInputType
    _max?: ResearchProtocolMaxAggregateInputType
  }

  export type ResearchProtocolGroupByOutputType = {
    id: string
    experimentId: string
    name: string
    nameAr: string | null
    description: string | null
    descriptionAr: string | null
    methodology: string
    methodologyAr: string | null
    variables: JsonValue
    measurementSchedule: JsonValue
    equipmentRequired: string[]
    safetyGuidelines: string | null
    version: number
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ResearchProtocolCountAggregateOutputType | null
    _avg: ResearchProtocolAvgAggregateOutputType | null
    _sum: ResearchProtocolSumAggregateOutputType | null
    _min: ResearchProtocolMinAggregateOutputType | null
    _max: ResearchProtocolMaxAggregateOutputType | null
  }

  type GetResearchProtocolGroupByPayload<T extends ResearchProtocolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchProtocolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchProtocolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchProtocolGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchProtocolGroupByOutputType[P]>
        }
      >
    >


  export type ResearchProtocolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    name?: boolean
    nameAr?: boolean
    description?: boolean
    descriptionAr?: boolean
    methodology?: boolean
    methodologyAr?: boolean
    variables?: boolean
    measurementSchedule?: boolean
    equipmentRequired?: boolean
    safetyGuidelines?: boolean
    version?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchProtocol"]>

  export type ResearchProtocolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    name?: boolean
    nameAr?: boolean
    description?: boolean
    descriptionAr?: boolean
    methodology?: boolean
    methodologyAr?: boolean
    variables?: boolean
    measurementSchedule?: boolean
    equipmentRequired?: boolean
    safetyGuidelines?: boolean
    version?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchProtocol"]>

  export type ResearchProtocolSelectScalar = {
    id?: boolean
    experimentId?: boolean
    name?: boolean
    nameAr?: boolean
    description?: boolean
    descriptionAr?: boolean
    methodology?: boolean
    methodologyAr?: boolean
    variables?: boolean
    measurementSchedule?: boolean
    equipmentRequired?: boolean
    safetyGuidelines?: boolean
    version?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResearchProtocolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }
  export type ResearchProtocolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }

  export type $ResearchProtocolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchProtocol"
    objects: {
      experiment: Prisma.$ExperimentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experimentId: string
      name: string
      nameAr: string | null
      description: string | null
      descriptionAr: string | null
      methodology: string
      methodologyAr: string | null
      variables: Prisma.JsonValue
      measurementSchedule: Prisma.JsonValue
      equipmentRequired: string[]
      safetyGuidelines: string | null
      version: number
      approvedBy: string | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["researchProtocol"]>
    composites: {}
  }

  type ResearchProtocolGetPayload<S extends boolean | null | undefined | ResearchProtocolDefaultArgs> = $Result.GetResult<Prisma.$ResearchProtocolPayload, S>

  type ResearchProtocolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResearchProtocolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResearchProtocolCountAggregateInputType | true
    }

  export interface ResearchProtocolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchProtocol'], meta: { name: 'ResearchProtocol' } }
    /**
     * Find zero or one ResearchProtocol that matches the filter.
     * @param {ResearchProtocolFindUniqueArgs} args - Arguments to find a ResearchProtocol
     * @example
     * // Get one ResearchProtocol
     * const researchProtocol = await prisma.researchProtocol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchProtocolFindUniqueArgs>(args: SelectSubset<T, ResearchProtocolFindUniqueArgs<ExtArgs>>): Prisma__ResearchProtocolClient<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResearchProtocol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResearchProtocolFindUniqueOrThrowArgs} args - Arguments to find a ResearchProtocol
     * @example
     * // Get one ResearchProtocol
     * const researchProtocol = await prisma.researchProtocol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchProtocolFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchProtocolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchProtocolClient<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResearchProtocol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProtocolFindFirstArgs} args - Arguments to find a ResearchProtocol
     * @example
     * // Get one ResearchProtocol
     * const researchProtocol = await prisma.researchProtocol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchProtocolFindFirstArgs>(args?: SelectSubset<T, ResearchProtocolFindFirstArgs<ExtArgs>>): Prisma__ResearchProtocolClient<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResearchProtocol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProtocolFindFirstOrThrowArgs} args - Arguments to find a ResearchProtocol
     * @example
     * // Get one ResearchProtocol
     * const researchProtocol = await prisma.researchProtocol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchProtocolFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchProtocolFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchProtocolClient<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResearchProtocols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProtocolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchProtocols
     * const researchProtocols = await prisma.researchProtocol.findMany()
     * 
     * // Get first 10 ResearchProtocols
     * const researchProtocols = await prisma.researchProtocol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchProtocolWithIdOnly = await prisma.researchProtocol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchProtocolFindManyArgs>(args?: SelectSubset<T, ResearchProtocolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResearchProtocol.
     * @param {ResearchProtocolCreateArgs} args - Arguments to create a ResearchProtocol.
     * @example
     * // Create one ResearchProtocol
     * const ResearchProtocol = await prisma.researchProtocol.create({
     *   data: {
     *     // ... data to create a ResearchProtocol
     *   }
     * })
     * 
     */
    create<T extends ResearchProtocolCreateArgs>(args: SelectSubset<T, ResearchProtocolCreateArgs<ExtArgs>>): Prisma__ResearchProtocolClient<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResearchProtocols.
     * @param {ResearchProtocolCreateManyArgs} args - Arguments to create many ResearchProtocols.
     * @example
     * // Create many ResearchProtocols
     * const researchProtocol = await prisma.researchProtocol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchProtocolCreateManyArgs>(args?: SelectSubset<T, ResearchProtocolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchProtocols and returns the data saved in the database.
     * @param {ResearchProtocolCreateManyAndReturnArgs} args - Arguments to create many ResearchProtocols.
     * @example
     * // Create many ResearchProtocols
     * const researchProtocol = await prisma.researchProtocol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchProtocols and only return the `id`
     * const researchProtocolWithIdOnly = await prisma.researchProtocol.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchProtocolCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchProtocolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResearchProtocol.
     * @param {ResearchProtocolDeleteArgs} args - Arguments to delete one ResearchProtocol.
     * @example
     * // Delete one ResearchProtocol
     * const ResearchProtocol = await prisma.researchProtocol.delete({
     *   where: {
     *     // ... filter to delete one ResearchProtocol
     *   }
     * })
     * 
     */
    delete<T extends ResearchProtocolDeleteArgs>(args: SelectSubset<T, ResearchProtocolDeleteArgs<ExtArgs>>): Prisma__ResearchProtocolClient<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResearchProtocol.
     * @param {ResearchProtocolUpdateArgs} args - Arguments to update one ResearchProtocol.
     * @example
     * // Update one ResearchProtocol
     * const researchProtocol = await prisma.researchProtocol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchProtocolUpdateArgs>(args: SelectSubset<T, ResearchProtocolUpdateArgs<ExtArgs>>): Prisma__ResearchProtocolClient<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResearchProtocols.
     * @param {ResearchProtocolDeleteManyArgs} args - Arguments to filter ResearchProtocols to delete.
     * @example
     * // Delete a few ResearchProtocols
     * const { count } = await prisma.researchProtocol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchProtocolDeleteManyArgs>(args?: SelectSubset<T, ResearchProtocolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchProtocols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProtocolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchProtocols
     * const researchProtocol = await prisma.researchProtocol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchProtocolUpdateManyArgs>(args: SelectSubset<T, ResearchProtocolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResearchProtocol.
     * @param {ResearchProtocolUpsertArgs} args - Arguments to update or create a ResearchProtocol.
     * @example
     * // Update or create a ResearchProtocol
     * const researchProtocol = await prisma.researchProtocol.upsert({
     *   create: {
     *     // ... data to create a ResearchProtocol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchProtocol we want to update
     *   }
     * })
     */
    upsert<T extends ResearchProtocolUpsertArgs>(args: SelectSubset<T, ResearchProtocolUpsertArgs<ExtArgs>>): Prisma__ResearchProtocolClient<$Result.GetResult<Prisma.$ResearchProtocolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResearchProtocols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProtocolCountArgs} args - Arguments to filter ResearchProtocols to count.
     * @example
     * // Count the number of ResearchProtocols
     * const count = await prisma.researchProtocol.count({
     *   where: {
     *     // ... the filter for the ResearchProtocols we want to count
     *   }
     * })
    **/
    count<T extends ResearchProtocolCountArgs>(
      args?: Subset<T, ResearchProtocolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchProtocolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchProtocol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProtocolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchProtocolAggregateArgs>(args: Subset<T, ResearchProtocolAggregateArgs>): Prisma.PrismaPromise<GetResearchProtocolAggregateType<T>>

    /**
     * Group by ResearchProtocol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchProtocolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchProtocolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchProtocolGroupByArgs['orderBy'] }
        : { orderBy?: ResearchProtocolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchProtocolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchProtocolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchProtocol model
   */
  readonly fields: ResearchProtocolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchProtocol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchProtocolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiment<T extends ExperimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperimentDefaultArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchProtocol model
   */ 
  interface ResearchProtocolFieldRefs {
    readonly id: FieldRef<"ResearchProtocol", 'String'>
    readonly experimentId: FieldRef<"ResearchProtocol", 'String'>
    readonly name: FieldRef<"ResearchProtocol", 'String'>
    readonly nameAr: FieldRef<"ResearchProtocol", 'String'>
    readonly description: FieldRef<"ResearchProtocol", 'String'>
    readonly descriptionAr: FieldRef<"ResearchProtocol", 'String'>
    readonly methodology: FieldRef<"ResearchProtocol", 'String'>
    readonly methodologyAr: FieldRef<"ResearchProtocol", 'String'>
    readonly variables: FieldRef<"ResearchProtocol", 'Json'>
    readonly measurementSchedule: FieldRef<"ResearchProtocol", 'Json'>
    readonly equipmentRequired: FieldRef<"ResearchProtocol", 'String[]'>
    readonly safetyGuidelines: FieldRef<"ResearchProtocol", 'String'>
    readonly version: FieldRef<"ResearchProtocol", 'Int'>
    readonly approvedBy: FieldRef<"ResearchProtocol", 'String'>
    readonly approvedAt: FieldRef<"ResearchProtocol", 'DateTime'>
    readonly createdAt: FieldRef<"ResearchProtocol", 'DateTime'>
    readonly updatedAt: FieldRef<"ResearchProtocol", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResearchProtocol findUnique
   */
  export type ResearchProtocolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProtocol to fetch.
     */
    where: ResearchProtocolWhereUniqueInput
  }

  /**
   * ResearchProtocol findUniqueOrThrow
   */
  export type ResearchProtocolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProtocol to fetch.
     */
    where: ResearchProtocolWhereUniqueInput
  }

  /**
   * ResearchProtocol findFirst
   */
  export type ResearchProtocolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProtocol to fetch.
     */
    where?: ResearchProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProtocols to fetch.
     */
    orderBy?: ResearchProtocolOrderByWithRelationInput | ResearchProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchProtocols.
     */
    cursor?: ResearchProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProtocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProtocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchProtocols.
     */
    distinct?: ResearchProtocolScalarFieldEnum | ResearchProtocolScalarFieldEnum[]
  }

  /**
   * ResearchProtocol findFirstOrThrow
   */
  export type ResearchProtocolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProtocol to fetch.
     */
    where?: ResearchProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProtocols to fetch.
     */
    orderBy?: ResearchProtocolOrderByWithRelationInput | ResearchProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchProtocols.
     */
    cursor?: ResearchProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProtocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProtocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchProtocols.
     */
    distinct?: ResearchProtocolScalarFieldEnum | ResearchProtocolScalarFieldEnum[]
  }

  /**
   * ResearchProtocol findMany
   */
  export type ResearchProtocolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    /**
     * Filter, which ResearchProtocols to fetch.
     */
    where?: ResearchProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchProtocols to fetch.
     */
    orderBy?: ResearchProtocolOrderByWithRelationInput | ResearchProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchProtocols.
     */
    cursor?: ResearchProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchProtocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchProtocols.
     */
    skip?: number
    distinct?: ResearchProtocolScalarFieldEnum | ResearchProtocolScalarFieldEnum[]
  }

  /**
   * ResearchProtocol create
   */
  export type ResearchProtocolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchProtocol.
     */
    data: XOR<ResearchProtocolCreateInput, ResearchProtocolUncheckedCreateInput>
  }

  /**
   * ResearchProtocol createMany
   */
  export type ResearchProtocolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchProtocols.
     */
    data: ResearchProtocolCreateManyInput | ResearchProtocolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchProtocol createManyAndReturn
   */
  export type ResearchProtocolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResearchProtocols.
     */
    data: ResearchProtocolCreateManyInput | ResearchProtocolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchProtocol update
   */
  export type ResearchProtocolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchProtocol.
     */
    data: XOR<ResearchProtocolUpdateInput, ResearchProtocolUncheckedUpdateInput>
    /**
     * Choose, which ResearchProtocol to update.
     */
    where: ResearchProtocolWhereUniqueInput
  }

  /**
   * ResearchProtocol updateMany
   */
  export type ResearchProtocolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchProtocols.
     */
    data: XOR<ResearchProtocolUpdateManyMutationInput, ResearchProtocolUncheckedUpdateManyInput>
    /**
     * Filter which ResearchProtocols to update
     */
    where?: ResearchProtocolWhereInput
  }

  /**
   * ResearchProtocol upsert
   */
  export type ResearchProtocolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchProtocol to update in case it exists.
     */
    where: ResearchProtocolWhereUniqueInput
    /**
     * In case the ResearchProtocol found by the `where` argument doesn't exist, create a new ResearchProtocol with this data.
     */
    create: XOR<ResearchProtocolCreateInput, ResearchProtocolUncheckedCreateInput>
    /**
     * In case the ResearchProtocol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchProtocolUpdateInput, ResearchProtocolUncheckedUpdateInput>
  }

  /**
   * ResearchProtocol delete
   */
  export type ResearchProtocolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
    /**
     * Filter which ResearchProtocol to delete.
     */
    where: ResearchProtocolWhereUniqueInput
  }

  /**
   * ResearchProtocol deleteMany
   */
  export type ResearchProtocolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchProtocols to delete
     */
    where?: ResearchProtocolWhereInput
  }

  /**
   * ResearchProtocol without action
   */
  export type ResearchProtocolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchProtocol
     */
    select?: ResearchProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchProtocolInclude<ExtArgs> | null
  }


  /**
   * Model ResearchPlot
   */

  export type AggregateResearchPlot = {
    _count: ResearchPlotCountAggregateOutputType | null
    _avg: ResearchPlotAvgAggregateOutputType | null
    _sum: ResearchPlotSumAggregateOutputType | null
    _min: ResearchPlotMinAggregateOutputType | null
    _max: ResearchPlotMaxAggregateOutputType | null
  }

  export type ResearchPlotAvgAggregateOutputType = {
    areaSqm: Decimal | null
    soilPh: Decimal | null
    replicateNumber: number | null
    blockNumber: number | null
    rowNumber: number | null
    columnNumber: number | null
  }

  export type ResearchPlotSumAggregateOutputType = {
    areaSqm: Decimal | null
    soilPh: Decimal | null
    replicateNumber: number | null
    blockNumber: number | null
    rowNumber: number | null
    columnNumber: number | null
  }

  export type ResearchPlotMinAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotCode: string | null
    name: string | null
    nameAr: string | null
    areaSqm: Decimal | null
    soilType: string | null
    soilPh: Decimal | null
    previousCrop: string | null
    replicateNumber: number | null
    blockNumber: number | null
    rowNumber: number | null
    columnNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchPlotMaxAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotCode: string | null
    name: string | null
    nameAr: string | null
    areaSqm: Decimal | null
    soilType: string | null
    soilPh: Decimal | null
    previousCrop: string | null
    replicateNumber: number | null
    blockNumber: number | null
    rowNumber: number | null
    columnNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchPlotCountAggregateOutputType = {
    id: number
    experimentId: number
    plotCode: number
    name: number
    nameAr: number
    areaSqm: number
    soilType: number
    soilPh: number
    previousCrop: number
    replicateNumber: number
    blockNumber: number
    rowNumber: number
    columnNumber: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResearchPlotAvgAggregateInputType = {
    areaSqm?: true
    soilPh?: true
    replicateNumber?: true
    blockNumber?: true
    rowNumber?: true
    columnNumber?: true
  }

  export type ResearchPlotSumAggregateInputType = {
    areaSqm?: true
    soilPh?: true
    replicateNumber?: true
    blockNumber?: true
    rowNumber?: true
    columnNumber?: true
  }

  export type ResearchPlotMinAggregateInputType = {
    id?: true
    experimentId?: true
    plotCode?: true
    name?: true
    nameAr?: true
    areaSqm?: true
    soilType?: true
    soilPh?: true
    previousCrop?: true
    replicateNumber?: true
    blockNumber?: true
    rowNumber?: true
    columnNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchPlotMaxAggregateInputType = {
    id?: true
    experimentId?: true
    plotCode?: true
    name?: true
    nameAr?: true
    areaSqm?: true
    soilType?: true
    soilPh?: true
    previousCrop?: true
    replicateNumber?: true
    blockNumber?: true
    rowNumber?: true
    columnNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchPlotCountAggregateInputType = {
    id?: true
    experimentId?: true
    plotCode?: true
    name?: true
    nameAr?: true
    areaSqm?: true
    soilType?: true
    soilPh?: true
    previousCrop?: true
    replicateNumber?: true
    blockNumber?: true
    rowNumber?: true
    columnNumber?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResearchPlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchPlot to aggregate.
     */
    where?: ResearchPlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchPlots to fetch.
     */
    orderBy?: ResearchPlotOrderByWithRelationInput | ResearchPlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchPlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchPlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchPlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchPlots
    **/
    _count?: true | ResearchPlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchPlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchPlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchPlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchPlotMaxAggregateInputType
  }

  export type GetResearchPlotAggregateType<T extends ResearchPlotAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchPlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchPlot[P]>
      : GetScalarType<T[P], AggregateResearchPlot[P]>
  }




  export type ResearchPlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchPlotWhereInput
    orderBy?: ResearchPlotOrderByWithAggregationInput | ResearchPlotOrderByWithAggregationInput[]
    by: ResearchPlotScalarFieldEnum[] | ResearchPlotScalarFieldEnum
    having?: ResearchPlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchPlotCountAggregateInputType | true
    _avg?: ResearchPlotAvgAggregateInputType
    _sum?: ResearchPlotSumAggregateInputType
    _min?: ResearchPlotMinAggregateInputType
    _max?: ResearchPlotMaxAggregateInputType
  }

  export type ResearchPlotGroupByOutputType = {
    id: string
    experimentId: string
    plotCode: string
    name: string | null
    nameAr: string | null
    areaSqm: Decimal | null
    soilType: string | null
    soilPh: Decimal | null
    previousCrop: string | null
    replicateNumber: number
    blockNumber: number | null
    rowNumber: number | null
    columnNumber: number | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ResearchPlotCountAggregateOutputType | null
    _avg: ResearchPlotAvgAggregateOutputType | null
    _sum: ResearchPlotSumAggregateOutputType | null
    _min: ResearchPlotMinAggregateOutputType | null
    _max: ResearchPlotMaxAggregateOutputType | null
  }

  type GetResearchPlotGroupByPayload<T extends ResearchPlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchPlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchPlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchPlotGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchPlotGroupByOutputType[P]>
        }
      >
    >


  export type ResearchPlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotCode?: boolean
    name?: boolean
    nameAr?: boolean
    areaSqm?: boolean
    soilType?: boolean
    soilPh?: boolean
    previousCrop?: boolean
    replicateNumber?: boolean
    blockNumber?: boolean
    rowNumber?: boolean
    columnNumber?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    treatments?: boolean | ResearchPlot$treatmentsArgs<ExtArgs>
    logs?: boolean | ResearchPlot$logsArgs<ExtArgs>
    samples?: boolean | ResearchPlot$samplesArgs<ExtArgs>
    _count?: boolean | ResearchPlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchPlot"]>

  export type ResearchPlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotCode?: boolean
    name?: boolean
    nameAr?: boolean
    areaSqm?: boolean
    soilType?: boolean
    soilPh?: boolean
    previousCrop?: boolean
    replicateNumber?: boolean
    blockNumber?: boolean
    rowNumber?: boolean
    columnNumber?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchPlot"]>

  export type ResearchPlotSelectScalar = {
    id?: boolean
    experimentId?: boolean
    plotCode?: boolean
    name?: boolean
    nameAr?: boolean
    areaSqm?: boolean
    soilType?: boolean
    soilPh?: boolean
    previousCrop?: boolean
    replicateNumber?: boolean
    blockNumber?: boolean
    rowNumber?: boolean
    columnNumber?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResearchPlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    treatments?: boolean | ResearchPlot$treatmentsArgs<ExtArgs>
    logs?: boolean | ResearchPlot$logsArgs<ExtArgs>
    samples?: boolean | ResearchPlot$samplesArgs<ExtArgs>
    _count?: boolean | ResearchPlotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResearchPlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }

  export type $ResearchPlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchPlot"
    objects: {
      experiment: Prisma.$ExperimentPayload<ExtArgs>
      treatments: Prisma.$TreatmentPayload<ExtArgs>[]
      logs: Prisma.$ResearchDailyLogPayload<ExtArgs>[]
      samples: Prisma.$LabSamplePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experimentId: string
      plotCode: string
      name: string | null
      nameAr: string | null
      areaSqm: Prisma.Decimal | null
      soilType: string | null
      soilPh: Prisma.Decimal | null
      previousCrop: string | null
      replicateNumber: number
      blockNumber: number | null
      rowNumber: number | null
      columnNumber: number | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["researchPlot"]>
    composites: {}
  }

  type ResearchPlotGetPayload<S extends boolean | null | undefined | ResearchPlotDefaultArgs> = $Result.GetResult<Prisma.$ResearchPlotPayload, S>

  type ResearchPlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResearchPlotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResearchPlotCountAggregateInputType | true
    }

  export interface ResearchPlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchPlot'], meta: { name: 'ResearchPlot' } }
    /**
     * Find zero or one ResearchPlot that matches the filter.
     * @param {ResearchPlotFindUniqueArgs} args - Arguments to find a ResearchPlot
     * @example
     * // Get one ResearchPlot
     * const researchPlot = await prisma.researchPlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchPlotFindUniqueArgs>(args: SelectSubset<T, ResearchPlotFindUniqueArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResearchPlot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResearchPlotFindUniqueOrThrowArgs} args - Arguments to find a ResearchPlot
     * @example
     * // Get one ResearchPlot
     * const researchPlot = await prisma.researchPlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchPlotFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchPlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResearchPlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchPlotFindFirstArgs} args - Arguments to find a ResearchPlot
     * @example
     * // Get one ResearchPlot
     * const researchPlot = await prisma.researchPlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchPlotFindFirstArgs>(args?: SelectSubset<T, ResearchPlotFindFirstArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResearchPlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchPlotFindFirstOrThrowArgs} args - Arguments to find a ResearchPlot
     * @example
     * // Get one ResearchPlot
     * const researchPlot = await prisma.researchPlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchPlotFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchPlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResearchPlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchPlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchPlots
     * const researchPlots = await prisma.researchPlot.findMany()
     * 
     * // Get first 10 ResearchPlots
     * const researchPlots = await prisma.researchPlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchPlotWithIdOnly = await prisma.researchPlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchPlotFindManyArgs>(args?: SelectSubset<T, ResearchPlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResearchPlot.
     * @param {ResearchPlotCreateArgs} args - Arguments to create a ResearchPlot.
     * @example
     * // Create one ResearchPlot
     * const ResearchPlot = await prisma.researchPlot.create({
     *   data: {
     *     // ... data to create a ResearchPlot
     *   }
     * })
     * 
     */
    create<T extends ResearchPlotCreateArgs>(args: SelectSubset<T, ResearchPlotCreateArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResearchPlots.
     * @param {ResearchPlotCreateManyArgs} args - Arguments to create many ResearchPlots.
     * @example
     * // Create many ResearchPlots
     * const researchPlot = await prisma.researchPlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchPlotCreateManyArgs>(args?: SelectSubset<T, ResearchPlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchPlots and returns the data saved in the database.
     * @param {ResearchPlotCreateManyAndReturnArgs} args - Arguments to create many ResearchPlots.
     * @example
     * // Create many ResearchPlots
     * const researchPlot = await prisma.researchPlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchPlots and only return the `id`
     * const researchPlotWithIdOnly = await prisma.researchPlot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchPlotCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchPlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResearchPlot.
     * @param {ResearchPlotDeleteArgs} args - Arguments to delete one ResearchPlot.
     * @example
     * // Delete one ResearchPlot
     * const ResearchPlot = await prisma.researchPlot.delete({
     *   where: {
     *     // ... filter to delete one ResearchPlot
     *   }
     * })
     * 
     */
    delete<T extends ResearchPlotDeleteArgs>(args: SelectSubset<T, ResearchPlotDeleteArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResearchPlot.
     * @param {ResearchPlotUpdateArgs} args - Arguments to update one ResearchPlot.
     * @example
     * // Update one ResearchPlot
     * const researchPlot = await prisma.researchPlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchPlotUpdateArgs>(args: SelectSubset<T, ResearchPlotUpdateArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResearchPlots.
     * @param {ResearchPlotDeleteManyArgs} args - Arguments to filter ResearchPlots to delete.
     * @example
     * // Delete a few ResearchPlots
     * const { count } = await prisma.researchPlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchPlotDeleteManyArgs>(args?: SelectSubset<T, ResearchPlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchPlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchPlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchPlots
     * const researchPlot = await prisma.researchPlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchPlotUpdateManyArgs>(args: SelectSubset<T, ResearchPlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResearchPlot.
     * @param {ResearchPlotUpsertArgs} args - Arguments to update or create a ResearchPlot.
     * @example
     * // Update or create a ResearchPlot
     * const researchPlot = await prisma.researchPlot.upsert({
     *   create: {
     *     // ... data to create a ResearchPlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchPlot we want to update
     *   }
     * })
     */
    upsert<T extends ResearchPlotUpsertArgs>(args: SelectSubset<T, ResearchPlotUpsertArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResearchPlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchPlotCountArgs} args - Arguments to filter ResearchPlots to count.
     * @example
     * // Count the number of ResearchPlots
     * const count = await prisma.researchPlot.count({
     *   where: {
     *     // ... the filter for the ResearchPlots we want to count
     *   }
     * })
    **/
    count<T extends ResearchPlotCountArgs>(
      args?: Subset<T, ResearchPlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchPlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchPlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchPlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchPlotAggregateArgs>(args: Subset<T, ResearchPlotAggregateArgs>): Prisma.PrismaPromise<GetResearchPlotAggregateType<T>>

    /**
     * Group by ResearchPlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchPlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchPlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchPlotGroupByArgs['orderBy'] }
        : { orderBy?: ResearchPlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchPlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchPlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchPlot model
   */
  readonly fields: ResearchPlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchPlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchPlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiment<T extends ExperimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperimentDefaultArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    treatments<T extends ResearchPlot$treatmentsArgs<ExtArgs> = {}>(args?: Subset<T, ResearchPlot$treatmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends ResearchPlot$logsArgs<ExtArgs> = {}>(args?: Subset<T, ResearchPlot$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "findMany"> | Null>
    samples<T extends ResearchPlot$samplesArgs<ExtArgs> = {}>(args?: Subset<T, ResearchPlot$samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchPlot model
   */ 
  interface ResearchPlotFieldRefs {
    readonly id: FieldRef<"ResearchPlot", 'String'>
    readonly experimentId: FieldRef<"ResearchPlot", 'String'>
    readonly plotCode: FieldRef<"ResearchPlot", 'String'>
    readonly name: FieldRef<"ResearchPlot", 'String'>
    readonly nameAr: FieldRef<"ResearchPlot", 'String'>
    readonly areaSqm: FieldRef<"ResearchPlot", 'Decimal'>
    readonly soilType: FieldRef<"ResearchPlot", 'String'>
    readonly soilPh: FieldRef<"ResearchPlot", 'Decimal'>
    readonly previousCrop: FieldRef<"ResearchPlot", 'String'>
    readonly replicateNumber: FieldRef<"ResearchPlot", 'Int'>
    readonly blockNumber: FieldRef<"ResearchPlot", 'Int'>
    readonly rowNumber: FieldRef<"ResearchPlot", 'Int'>
    readonly columnNumber: FieldRef<"ResearchPlot", 'Int'>
    readonly metadata: FieldRef<"ResearchPlot", 'Json'>
    readonly createdAt: FieldRef<"ResearchPlot", 'DateTime'>
    readonly updatedAt: FieldRef<"ResearchPlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResearchPlot findUnique
   */
  export type ResearchPlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    /**
     * Filter, which ResearchPlot to fetch.
     */
    where: ResearchPlotWhereUniqueInput
  }

  /**
   * ResearchPlot findUniqueOrThrow
   */
  export type ResearchPlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    /**
     * Filter, which ResearchPlot to fetch.
     */
    where: ResearchPlotWhereUniqueInput
  }

  /**
   * ResearchPlot findFirst
   */
  export type ResearchPlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    /**
     * Filter, which ResearchPlot to fetch.
     */
    where?: ResearchPlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchPlots to fetch.
     */
    orderBy?: ResearchPlotOrderByWithRelationInput | ResearchPlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchPlots.
     */
    cursor?: ResearchPlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchPlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchPlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchPlots.
     */
    distinct?: ResearchPlotScalarFieldEnum | ResearchPlotScalarFieldEnum[]
  }

  /**
   * ResearchPlot findFirstOrThrow
   */
  export type ResearchPlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    /**
     * Filter, which ResearchPlot to fetch.
     */
    where?: ResearchPlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchPlots to fetch.
     */
    orderBy?: ResearchPlotOrderByWithRelationInput | ResearchPlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchPlots.
     */
    cursor?: ResearchPlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchPlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchPlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchPlots.
     */
    distinct?: ResearchPlotScalarFieldEnum | ResearchPlotScalarFieldEnum[]
  }

  /**
   * ResearchPlot findMany
   */
  export type ResearchPlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    /**
     * Filter, which ResearchPlots to fetch.
     */
    where?: ResearchPlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchPlots to fetch.
     */
    orderBy?: ResearchPlotOrderByWithRelationInput | ResearchPlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchPlots.
     */
    cursor?: ResearchPlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchPlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchPlots.
     */
    skip?: number
    distinct?: ResearchPlotScalarFieldEnum | ResearchPlotScalarFieldEnum[]
  }

  /**
   * ResearchPlot create
   */
  export type ResearchPlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchPlot.
     */
    data: XOR<ResearchPlotCreateInput, ResearchPlotUncheckedCreateInput>
  }

  /**
   * ResearchPlot createMany
   */
  export type ResearchPlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchPlots.
     */
    data: ResearchPlotCreateManyInput | ResearchPlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchPlot createManyAndReturn
   */
  export type ResearchPlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResearchPlots.
     */
    data: ResearchPlotCreateManyInput | ResearchPlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchPlot update
   */
  export type ResearchPlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchPlot.
     */
    data: XOR<ResearchPlotUpdateInput, ResearchPlotUncheckedUpdateInput>
    /**
     * Choose, which ResearchPlot to update.
     */
    where: ResearchPlotWhereUniqueInput
  }

  /**
   * ResearchPlot updateMany
   */
  export type ResearchPlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchPlots.
     */
    data: XOR<ResearchPlotUpdateManyMutationInput, ResearchPlotUncheckedUpdateManyInput>
    /**
     * Filter which ResearchPlots to update
     */
    where?: ResearchPlotWhereInput
  }

  /**
   * ResearchPlot upsert
   */
  export type ResearchPlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchPlot to update in case it exists.
     */
    where: ResearchPlotWhereUniqueInput
    /**
     * In case the ResearchPlot found by the `where` argument doesn't exist, create a new ResearchPlot with this data.
     */
    create: XOR<ResearchPlotCreateInput, ResearchPlotUncheckedCreateInput>
    /**
     * In case the ResearchPlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchPlotUpdateInput, ResearchPlotUncheckedUpdateInput>
  }

  /**
   * ResearchPlot delete
   */
  export type ResearchPlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    /**
     * Filter which ResearchPlot to delete.
     */
    where: ResearchPlotWhereUniqueInput
  }

  /**
   * ResearchPlot deleteMany
   */
  export type ResearchPlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchPlots to delete
     */
    where?: ResearchPlotWhereInput
  }

  /**
   * ResearchPlot.treatments
   */
  export type ResearchPlot$treatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    cursor?: TreatmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * ResearchPlot.logs
   */
  export type ResearchPlot$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    where?: ResearchDailyLogWhereInput
    orderBy?: ResearchDailyLogOrderByWithRelationInput | ResearchDailyLogOrderByWithRelationInput[]
    cursor?: ResearchDailyLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchDailyLogScalarFieldEnum | ResearchDailyLogScalarFieldEnum[]
  }

  /**
   * ResearchPlot.samples
   */
  export type ResearchPlot$samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    where?: LabSampleWhereInput
    orderBy?: LabSampleOrderByWithRelationInput | LabSampleOrderByWithRelationInput[]
    cursor?: LabSampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabSampleScalarFieldEnum | LabSampleScalarFieldEnum[]
  }

  /**
   * ResearchPlot without action
   */
  export type ResearchPlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
  }


  /**
   * Model Treatment
   */

  export type AggregateTreatment = {
    _count: TreatmentCountAggregateOutputType | null
    _min: TreatmentMinAggregateOutputType | null
    _max: TreatmentMaxAggregateOutputType | null
  }

  export type TreatmentMinAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotId: string | null
    treatmentCode: string | null
    name: string | null
    nameAr: string | null
    type: $Enums.TreatmentType | null
    description: string | null
    descriptionAr: string | null
    dosage: string | null
    dosageUnit: string | null
    applicationMethod: string | null
    applicationFrequency: string | null
    startDate: Date | null
    endDate: Date | null
    isControl: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TreatmentMaxAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotId: string | null
    treatmentCode: string | null
    name: string | null
    nameAr: string | null
    type: $Enums.TreatmentType | null
    description: string | null
    descriptionAr: string | null
    dosage: string | null
    dosageUnit: string | null
    applicationMethod: string | null
    applicationFrequency: string | null
    startDate: Date | null
    endDate: Date | null
    isControl: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TreatmentCountAggregateOutputType = {
    id: number
    experimentId: number
    plotId: number
    treatmentCode: number
    name: number
    nameAr: number
    type: number
    description: number
    descriptionAr: number
    dosage: number
    dosageUnit: number
    applicationMethod: number
    applicationFrequency: number
    startDate: number
    endDate: number
    isControl: number
    parameters: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TreatmentMinAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    treatmentCode?: true
    name?: true
    nameAr?: true
    type?: true
    description?: true
    descriptionAr?: true
    dosage?: true
    dosageUnit?: true
    applicationMethod?: true
    applicationFrequency?: true
    startDate?: true
    endDate?: true
    isControl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TreatmentMaxAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    treatmentCode?: true
    name?: true
    nameAr?: true
    type?: true
    description?: true
    descriptionAr?: true
    dosage?: true
    dosageUnit?: true
    applicationMethod?: true
    applicationFrequency?: true
    startDate?: true
    endDate?: true
    isControl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TreatmentCountAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    treatmentCode?: true
    name?: true
    nameAr?: true
    type?: true
    description?: true
    descriptionAr?: true
    dosage?: true
    dosageUnit?: true
    applicationMethod?: true
    applicationFrequency?: true
    startDate?: true
    endDate?: true
    isControl?: true
    parameters?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TreatmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Treatment to aggregate.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Treatments
    **/
    _count?: true | TreatmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreatmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreatmentMaxAggregateInputType
  }

  export type GetTreatmentAggregateType<T extends TreatmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTreatment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreatment[P]>
      : GetScalarType<T[P], AggregateTreatment[P]>
  }




  export type TreatmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithAggregationInput | TreatmentOrderByWithAggregationInput[]
    by: TreatmentScalarFieldEnum[] | TreatmentScalarFieldEnum
    having?: TreatmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreatmentCountAggregateInputType | true
    _min?: TreatmentMinAggregateInputType
    _max?: TreatmentMaxAggregateInputType
  }

  export type TreatmentGroupByOutputType = {
    id: string
    experimentId: string
    plotId: string | null
    treatmentCode: string
    name: string
    nameAr: string | null
    type: $Enums.TreatmentType
    description: string | null
    descriptionAr: string | null
    dosage: string | null
    dosageUnit: string | null
    applicationMethod: string | null
    applicationFrequency: string | null
    startDate: Date | null
    endDate: Date | null
    isControl: boolean
    parameters: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: TreatmentCountAggregateOutputType | null
    _min: TreatmentMinAggregateOutputType | null
    _max: TreatmentMaxAggregateOutputType | null
  }

  type GetTreatmentGroupByPayload<T extends TreatmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreatmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreatmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreatmentGroupByOutputType[P]>
            : GetScalarType<T[P], TreatmentGroupByOutputType[P]>
        }
      >
    >


  export type TreatmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    treatmentCode?: boolean
    name?: boolean
    nameAr?: boolean
    type?: boolean
    description?: boolean
    descriptionAr?: boolean
    dosage?: boolean
    dosageUnit?: boolean
    applicationMethod?: boolean
    applicationFrequency?: boolean
    startDate?: boolean
    endDate?: boolean
    isControl?: boolean
    parameters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | Treatment$plotArgs<ExtArgs>
    logs?: boolean | Treatment$logsArgs<ExtArgs>
    _count?: boolean | TreatmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatment"]>

  export type TreatmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    treatmentCode?: boolean
    name?: boolean
    nameAr?: boolean
    type?: boolean
    description?: boolean
    descriptionAr?: boolean
    dosage?: boolean
    dosageUnit?: boolean
    applicationMethod?: boolean
    applicationFrequency?: boolean
    startDate?: boolean
    endDate?: boolean
    isControl?: boolean
    parameters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | Treatment$plotArgs<ExtArgs>
  }, ExtArgs["result"]["treatment"]>

  export type TreatmentSelectScalar = {
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    treatmentCode?: boolean
    name?: boolean
    nameAr?: boolean
    type?: boolean
    description?: boolean
    descriptionAr?: boolean
    dosage?: boolean
    dosageUnit?: boolean
    applicationMethod?: boolean
    applicationFrequency?: boolean
    startDate?: boolean
    endDate?: boolean
    isControl?: boolean
    parameters?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TreatmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | Treatment$plotArgs<ExtArgs>
    logs?: boolean | Treatment$logsArgs<ExtArgs>
    _count?: boolean | TreatmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TreatmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | Treatment$plotArgs<ExtArgs>
  }

  export type $TreatmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Treatment"
    objects: {
      experiment: Prisma.$ExperimentPayload<ExtArgs>
      plot: Prisma.$ResearchPlotPayload<ExtArgs> | null
      logs: Prisma.$ResearchDailyLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experimentId: string
      plotId: string | null
      treatmentCode: string
      name: string
      nameAr: string | null
      type: $Enums.TreatmentType
      description: string | null
      descriptionAr: string | null
      dosage: string | null
      dosageUnit: string | null
      applicationMethod: string | null
      applicationFrequency: string | null
      startDate: Date | null
      endDate: Date | null
      isControl: boolean
      parameters: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["treatment"]>
    composites: {}
  }

  type TreatmentGetPayload<S extends boolean | null | undefined | TreatmentDefaultArgs> = $Result.GetResult<Prisma.$TreatmentPayload, S>

  type TreatmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TreatmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TreatmentCountAggregateInputType | true
    }

  export interface TreatmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Treatment'], meta: { name: 'Treatment' } }
    /**
     * Find zero or one Treatment that matches the filter.
     * @param {TreatmentFindUniqueArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreatmentFindUniqueArgs>(args: SelectSubset<T, TreatmentFindUniqueArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Treatment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TreatmentFindUniqueOrThrowArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreatmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TreatmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Treatment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentFindFirstArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreatmentFindFirstArgs>(args?: SelectSubset<T, TreatmentFindFirstArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Treatment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentFindFirstOrThrowArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreatmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TreatmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Treatments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Treatments
     * const treatments = await prisma.treatment.findMany()
     * 
     * // Get first 10 Treatments
     * const treatments = await prisma.treatment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treatmentWithIdOnly = await prisma.treatment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreatmentFindManyArgs>(args?: SelectSubset<T, TreatmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Treatment.
     * @param {TreatmentCreateArgs} args - Arguments to create a Treatment.
     * @example
     * // Create one Treatment
     * const Treatment = await prisma.treatment.create({
     *   data: {
     *     // ... data to create a Treatment
     *   }
     * })
     * 
     */
    create<T extends TreatmentCreateArgs>(args: SelectSubset<T, TreatmentCreateArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Treatments.
     * @param {TreatmentCreateManyArgs} args - Arguments to create many Treatments.
     * @example
     * // Create many Treatments
     * const treatment = await prisma.treatment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreatmentCreateManyArgs>(args?: SelectSubset<T, TreatmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Treatments and returns the data saved in the database.
     * @param {TreatmentCreateManyAndReturnArgs} args - Arguments to create many Treatments.
     * @example
     * // Create many Treatments
     * const treatment = await prisma.treatment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Treatments and only return the `id`
     * const treatmentWithIdOnly = await prisma.treatment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TreatmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TreatmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Treatment.
     * @param {TreatmentDeleteArgs} args - Arguments to delete one Treatment.
     * @example
     * // Delete one Treatment
     * const Treatment = await prisma.treatment.delete({
     *   where: {
     *     // ... filter to delete one Treatment
     *   }
     * })
     * 
     */
    delete<T extends TreatmentDeleteArgs>(args: SelectSubset<T, TreatmentDeleteArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Treatment.
     * @param {TreatmentUpdateArgs} args - Arguments to update one Treatment.
     * @example
     * // Update one Treatment
     * const treatment = await prisma.treatment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreatmentUpdateArgs>(args: SelectSubset<T, TreatmentUpdateArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Treatments.
     * @param {TreatmentDeleteManyArgs} args - Arguments to filter Treatments to delete.
     * @example
     * // Delete a few Treatments
     * const { count } = await prisma.treatment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreatmentDeleteManyArgs>(args?: SelectSubset<T, TreatmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Treatments
     * const treatment = await prisma.treatment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreatmentUpdateManyArgs>(args: SelectSubset<T, TreatmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Treatment.
     * @param {TreatmentUpsertArgs} args - Arguments to update or create a Treatment.
     * @example
     * // Update or create a Treatment
     * const treatment = await prisma.treatment.upsert({
     *   create: {
     *     // ... data to create a Treatment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Treatment we want to update
     *   }
     * })
     */
    upsert<T extends TreatmentUpsertArgs>(args: SelectSubset<T, TreatmentUpsertArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentCountArgs} args - Arguments to filter Treatments to count.
     * @example
     * // Count the number of Treatments
     * const count = await prisma.treatment.count({
     *   where: {
     *     // ... the filter for the Treatments we want to count
     *   }
     * })
    **/
    count<T extends TreatmentCountArgs>(
      args?: Subset<T, TreatmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreatmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Treatment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreatmentAggregateArgs>(args: Subset<T, TreatmentAggregateArgs>): Prisma.PrismaPromise<GetTreatmentAggregateType<T>>

    /**
     * Group by Treatment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreatmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreatmentGroupByArgs['orderBy'] }
        : { orderBy?: TreatmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreatmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreatmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Treatment model
   */
  readonly fields: TreatmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Treatment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreatmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiment<T extends ExperimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperimentDefaultArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plot<T extends Treatment$plotArgs<ExtArgs> = {}>(args?: Subset<T, Treatment$plotArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logs<T extends Treatment$logsArgs<ExtArgs> = {}>(args?: Subset<T, Treatment$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Treatment model
   */ 
  interface TreatmentFieldRefs {
    readonly id: FieldRef<"Treatment", 'String'>
    readonly experimentId: FieldRef<"Treatment", 'String'>
    readonly plotId: FieldRef<"Treatment", 'String'>
    readonly treatmentCode: FieldRef<"Treatment", 'String'>
    readonly name: FieldRef<"Treatment", 'String'>
    readonly nameAr: FieldRef<"Treatment", 'String'>
    readonly type: FieldRef<"Treatment", 'TreatmentType'>
    readonly description: FieldRef<"Treatment", 'String'>
    readonly descriptionAr: FieldRef<"Treatment", 'String'>
    readonly dosage: FieldRef<"Treatment", 'String'>
    readonly dosageUnit: FieldRef<"Treatment", 'String'>
    readonly applicationMethod: FieldRef<"Treatment", 'String'>
    readonly applicationFrequency: FieldRef<"Treatment", 'String'>
    readonly startDate: FieldRef<"Treatment", 'DateTime'>
    readonly endDate: FieldRef<"Treatment", 'DateTime'>
    readonly isControl: FieldRef<"Treatment", 'Boolean'>
    readonly parameters: FieldRef<"Treatment", 'Json'>
    readonly createdAt: FieldRef<"Treatment", 'DateTime'>
    readonly updatedAt: FieldRef<"Treatment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Treatment findUnique
   */
  export type TreatmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment findUniqueOrThrow
   */
  export type TreatmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment findFirst
   */
  export type TreatmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Treatments.
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Treatments.
     */
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Treatment findFirstOrThrow
   */
  export type TreatmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Treatments.
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Treatments.
     */
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Treatment findMany
   */
  export type TreatmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatments to fetch.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Treatments.
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Treatment create
   */
  export type TreatmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Treatment.
     */
    data: XOR<TreatmentCreateInput, TreatmentUncheckedCreateInput>
  }

  /**
   * Treatment createMany
   */
  export type TreatmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Treatments.
     */
    data: TreatmentCreateManyInput | TreatmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Treatment createManyAndReturn
   */
  export type TreatmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Treatments.
     */
    data: TreatmentCreateManyInput | TreatmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Treatment update
   */
  export type TreatmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Treatment.
     */
    data: XOR<TreatmentUpdateInput, TreatmentUncheckedUpdateInput>
    /**
     * Choose, which Treatment to update.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment updateMany
   */
  export type TreatmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Treatments.
     */
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyInput>
    /**
     * Filter which Treatments to update
     */
    where?: TreatmentWhereInput
  }

  /**
   * Treatment upsert
   */
  export type TreatmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Treatment to update in case it exists.
     */
    where: TreatmentWhereUniqueInput
    /**
     * In case the Treatment found by the `where` argument doesn't exist, create a new Treatment with this data.
     */
    create: XOR<TreatmentCreateInput, TreatmentUncheckedCreateInput>
    /**
     * In case the Treatment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreatmentUpdateInput, TreatmentUncheckedUpdateInput>
  }

  /**
   * Treatment delete
   */
  export type TreatmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter which Treatment to delete.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment deleteMany
   */
  export type TreatmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Treatments to delete
     */
    where?: TreatmentWhereInput
  }

  /**
   * Treatment.plot
   */
  export type Treatment$plotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    where?: ResearchPlotWhereInput
  }

  /**
   * Treatment.logs
   */
  export type Treatment$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    where?: ResearchDailyLogWhereInput
    orderBy?: ResearchDailyLogOrderByWithRelationInput | ResearchDailyLogOrderByWithRelationInput[]
    cursor?: ResearchDailyLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchDailyLogScalarFieldEnum | ResearchDailyLogScalarFieldEnum[]
  }

  /**
   * Treatment without action
   */
  export type TreatmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
  }


  /**
   * Model ResearchDailyLog
   */

  export type AggregateResearchDailyLog = {
    _count: ResearchDailyLogCountAggregateOutputType | null
    _min: ResearchDailyLogMinAggregateOutputType | null
    _max: ResearchDailyLogMaxAggregateOutputType | null
  }

  export type ResearchDailyLogMinAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotId: string | null
    treatmentId: string | null
    logDate: Date | null
    logTime: string | null
    category: $Enums.LogCategory | null
    title: string | null
    titleAr: string | null
    notes: string | null
    notesAr: string | null
    recordedBy: string | null
    deviceId: string | null
    offlineId: string | null
    hash: string | null
    syncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchDailyLogMaxAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotId: string | null
    treatmentId: string | null
    logDate: Date | null
    logTime: string | null
    category: $Enums.LogCategory | null
    title: string | null
    titleAr: string | null
    notes: string | null
    notesAr: string | null
    recordedBy: string | null
    deviceId: string | null
    offlineId: string | null
    hash: string | null
    syncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResearchDailyLogCountAggregateOutputType = {
    id: number
    experimentId: number
    plotId: number
    treatmentId: number
    logDate: number
    logTime: number
    category: number
    title: number
    titleAr: number
    notes: number
    notesAr: number
    measurements: number
    weatherConditions: number
    photos: number
    attachments: number
    recordedBy: number
    deviceId: number
    offlineId: number
    hash: number
    syncedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResearchDailyLogMinAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    treatmentId?: true
    logDate?: true
    logTime?: true
    category?: true
    title?: true
    titleAr?: true
    notes?: true
    notesAr?: true
    recordedBy?: true
    deviceId?: true
    offlineId?: true
    hash?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchDailyLogMaxAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    treatmentId?: true
    logDate?: true
    logTime?: true
    category?: true
    title?: true
    titleAr?: true
    notes?: true
    notesAr?: true
    recordedBy?: true
    deviceId?: true
    offlineId?: true
    hash?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResearchDailyLogCountAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    treatmentId?: true
    logDate?: true
    logTime?: true
    category?: true
    title?: true
    titleAr?: true
    notes?: true
    notesAr?: true
    measurements?: true
    weatherConditions?: true
    photos?: true
    attachments?: true
    recordedBy?: true
    deviceId?: true
    offlineId?: true
    hash?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResearchDailyLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchDailyLog to aggregate.
     */
    where?: ResearchDailyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchDailyLogs to fetch.
     */
    orderBy?: ResearchDailyLogOrderByWithRelationInput | ResearchDailyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchDailyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchDailyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchDailyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchDailyLogs
    **/
    _count?: true | ResearchDailyLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchDailyLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchDailyLogMaxAggregateInputType
  }

  export type GetResearchDailyLogAggregateType<T extends ResearchDailyLogAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchDailyLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchDailyLog[P]>
      : GetScalarType<T[P], AggregateResearchDailyLog[P]>
  }




  export type ResearchDailyLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchDailyLogWhereInput
    orderBy?: ResearchDailyLogOrderByWithAggregationInput | ResearchDailyLogOrderByWithAggregationInput[]
    by: ResearchDailyLogScalarFieldEnum[] | ResearchDailyLogScalarFieldEnum
    having?: ResearchDailyLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchDailyLogCountAggregateInputType | true
    _min?: ResearchDailyLogMinAggregateInputType
    _max?: ResearchDailyLogMaxAggregateInputType
  }

  export type ResearchDailyLogGroupByOutputType = {
    id: string
    experimentId: string
    plotId: string | null
    treatmentId: string | null
    logDate: Date
    logTime: string | null
    category: $Enums.LogCategory
    title: string
    titleAr: string | null
    notes: string | null
    notesAr: string | null
    measurements: JsonValue
    weatherConditions: JsonValue
    photos: string[]
    attachments: string[]
    recordedBy: string
    deviceId: string | null
    offlineId: string | null
    hash: string | null
    syncedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ResearchDailyLogCountAggregateOutputType | null
    _min: ResearchDailyLogMinAggregateOutputType | null
    _max: ResearchDailyLogMaxAggregateOutputType | null
  }

  type GetResearchDailyLogGroupByPayload<T extends ResearchDailyLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchDailyLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchDailyLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchDailyLogGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchDailyLogGroupByOutputType[P]>
        }
      >
    >


  export type ResearchDailyLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    treatmentId?: boolean
    logDate?: boolean
    logTime?: boolean
    category?: boolean
    title?: boolean
    titleAr?: boolean
    notes?: boolean
    notesAr?: boolean
    measurements?: boolean
    weatherConditions?: boolean
    photos?: boolean
    attachments?: boolean
    recordedBy?: boolean
    deviceId?: boolean
    offlineId?: boolean
    hash?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | ResearchDailyLog$plotArgs<ExtArgs>
    treatment?: boolean | ResearchDailyLog$treatmentArgs<ExtArgs>
    samples?: boolean | ResearchDailyLog$samplesArgs<ExtArgs>
    _count?: boolean | ResearchDailyLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchDailyLog"]>

  export type ResearchDailyLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    treatmentId?: boolean
    logDate?: boolean
    logTime?: boolean
    category?: boolean
    title?: boolean
    titleAr?: boolean
    notes?: boolean
    notesAr?: boolean
    measurements?: boolean
    weatherConditions?: boolean
    photos?: boolean
    attachments?: boolean
    recordedBy?: boolean
    deviceId?: boolean
    offlineId?: boolean
    hash?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | ResearchDailyLog$plotArgs<ExtArgs>
    treatment?: boolean | ResearchDailyLog$treatmentArgs<ExtArgs>
  }, ExtArgs["result"]["researchDailyLog"]>

  export type ResearchDailyLogSelectScalar = {
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    treatmentId?: boolean
    logDate?: boolean
    logTime?: boolean
    category?: boolean
    title?: boolean
    titleAr?: boolean
    notes?: boolean
    notesAr?: boolean
    measurements?: boolean
    weatherConditions?: boolean
    photos?: boolean
    attachments?: boolean
    recordedBy?: boolean
    deviceId?: boolean
    offlineId?: boolean
    hash?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResearchDailyLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | ResearchDailyLog$plotArgs<ExtArgs>
    treatment?: boolean | ResearchDailyLog$treatmentArgs<ExtArgs>
    samples?: boolean | ResearchDailyLog$samplesArgs<ExtArgs>
    _count?: boolean | ResearchDailyLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResearchDailyLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | ResearchDailyLog$plotArgs<ExtArgs>
    treatment?: boolean | ResearchDailyLog$treatmentArgs<ExtArgs>
  }

  export type $ResearchDailyLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchDailyLog"
    objects: {
      experiment: Prisma.$ExperimentPayload<ExtArgs>
      plot: Prisma.$ResearchPlotPayload<ExtArgs> | null
      treatment: Prisma.$TreatmentPayload<ExtArgs> | null
      samples: Prisma.$LabSamplePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experimentId: string
      plotId: string | null
      treatmentId: string | null
      logDate: Date
      logTime: string | null
      category: $Enums.LogCategory
      title: string
      titleAr: string | null
      notes: string | null
      notesAr: string | null
      measurements: Prisma.JsonValue
      weatherConditions: Prisma.JsonValue
      photos: string[]
      attachments: string[]
      recordedBy: string
      deviceId: string | null
      offlineId: string | null
      hash: string | null
      syncedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["researchDailyLog"]>
    composites: {}
  }

  type ResearchDailyLogGetPayload<S extends boolean | null | undefined | ResearchDailyLogDefaultArgs> = $Result.GetResult<Prisma.$ResearchDailyLogPayload, S>

  type ResearchDailyLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResearchDailyLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResearchDailyLogCountAggregateInputType | true
    }

  export interface ResearchDailyLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchDailyLog'], meta: { name: 'ResearchDailyLog' } }
    /**
     * Find zero or one ResearchDailyLog that matches the filter.
     * @param {ResearchDailyLogFindUniqueArgs} args - Arguments to find a ResearchDailyLog
     * @example
     * // Get one ResearchDailyLog
     * const researchDailyLog = await prisma.researchDailyLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchDailyLogFindUniqueArgs>(args: SelectSubset<T, ResearchDailyLogFindUniqueArgs<ExtArgs>>): Prisma__ResearchDailyLogClient<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResearchDailyLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResearchDailyLogFindUniqueOrThrowArgs} args - Arguments to find a ResearchDailyLog
     * @example
     * // Get one ResearchDailyLog
     * const researchDailyLog = await prisma.researchDailyLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchDailyLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchDailyLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchDailyLogClient<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResearchDailyLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDailyLogFindFirstArgs} args - Arguments to find a ResearchDailyLog
     * @example
     * // Get one ResearchDailyLog
     * const researchDailyLog = await prisma.researchDailyLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchDailyLogFindFirstArgs>(args?: SelectSubset<T, ResearchDailyLogFindFirstArgs<ExtArgs>>): Prisma__ResearchDailyLogClient<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResearchDailyLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDailyLogFindFirstOrThrowArgs} args - Arguments to find a ResearchDailyLog
     * @example
     * // Get one ResearchDailyLog
     * const researchDailyLog = await prisma.researchDailyLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchDailyLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchDailyLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchDailyLogClient<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResearchDailyLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDailyLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchDailyLogs
     * const researchDailyLogs = await prisma.researchDailyLog.findMany()
     * 
     * // Get first 10 ResearchDailyLogs
     * const researchDailyLogs = await prisma.researchDailyLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchDailyLogWithIdOnly = await prisma.researchDailyLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchDailyLogFindManyArgs>(args?: SelectSubset<T, ResearchDailyLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResearchDailyLog.
     * @param {ResearchDailyLogCreateArgs} args - Arguments to create a ResearchDailyLog.
     * @example
     * // Create one ResearchDailyLog
     * const ResearchDailyLog = await prisma.researchDailyLog.create({
     *   data: {
     *     // ... data to create a ResearchDailyLog
     *   }
     * })
     * 
     */
    create<T extends ResearchDailyLogCreateArgs>(args: SelectSubset<T, ResearchDailyLogCreateArgs<ExtArgs>>): Prisma__ResearchDailyLogClient<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResearchDailyLogs.
     * @param {ResearchDailyLogCreateManyArgs} args - Arguments to create many ResearchDailyLogs.
     * @example
     * // Create many ResearchDailyLogs
     * const researchDailyLog = await prisma.researchDailyLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchDailyLogCreateManyArgs>(args?: SelectSubset<T, ResearchDailyLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchDailyLogs and returns the data saved in the database.
     * @param {ResearchDailyLogCreateManyAndReturnArgs} args - Arguments to create many ResearchDailyLogs.
     * @example
     * // Create many ResearchDailyLogs
     * const researchDailyLog = await prisma.researchDailyLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchDailyLogs and only return the `id`
     * const researchDailyLogWithIdOnly = await prisma.researchDailyLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchDailyLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchDailyLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResearchDailyLog.
     * @param {ResearchDailyLogDeleteArgs} args - Arguments to delete one ResearchDailyLog.
     * @example
     * // Delete one ResearchDailyLog
     * const ResearchDailyLog = await prisma.researchDailyLog.delete({
     *   where: {
     *     // ... filter to delete one ResearchDailyLog
     *   }
     * })
     * 
     */
    delete<T extends ResearchDailyLogDeleteArgs>(args: SelectSubset<T, ResearchDailyLogDeleteArgs<ExtArgs>>): Prisma__ResearchDailyLogClient<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResearchDailyLog.
     * @param {ResearchDailyLogUpdateArgs} args - Arguments to update one ResearchDailyLog.
     * @example
     * // Update one ResearchDailyLog
     * const researchDailyLog = await prisma.researchDailyLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchDailyLogUpdateArgs>(args: SelectSubset<T, ResearchDailyLogUpdateArgs<ExtArgs>>): Prisma__ResearchDailyLogClient<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResearchDailyLogs.
     * @param {ResearchDailyLogDeleteManyArgs} args - Arguments to filter ResearchDailyLogs to delete.
     * @example
     * // Delete a few ResearchDailyLogs
     * const { count } = await prisma.researchDailyLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchDailyLogDeleteManyArgs>(args?: SelectSubset<T, ResearchDailyLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchDailyLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDailyLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchDailyLogs
     * const researchDailyLog = await prisma.researchDailyLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchDailyLogUpdateManyArgs>(args: SelectSubset<T, ResearchDailyLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResearchDailyLog.
     * @param {ResearchDailyLogUpsertArgs} args - Arguments to update or create a ResearchDailyLog.
     * @example
     * // Update or create a ResearchDailyLog
     * const researchDailyLog = await prisma.researchDailyLog.upsert({
     *   create: {
     *     // ... data to create a ResearchDailyLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchDailyLog we want to update
     *   }
     * })
     */
    upsert<T extends ResearchDailyLogUpsertArgs>(args: SelectSubset<T, ResearchDailyLogUpsertArgs<ExtArgs>>): Prisma__ResearchDailyLogClient<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResearchDailyLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDailyLogCountArgs} args - Arguments to filter ResearchDailyLogs to count.
     * @example
     * // Count the number of ResearchDailyLogs
     * const count = await prisma.researchDailyLog.count({
     *   where: {
     *     // ... the filter for the ResearchDailyLogs we want to count
     *   }
     * })
    **/
    count<T extends ResearchDailyLogCountArgs>(
      args?: Subset<T, ResearchDailyLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchDailyLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchDailyLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDailyLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchDailyLogAggregateArgs>(args: Subset<T, ResearchDailyLogAggregateArgs>): Prisma.PrismaPromise<GetResearchDailyLogAggregateType<T>>

    /**
     * Group by ResearchDailyLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDailyLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchDailyLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchDailyLogGroupByArgs['orderBy'] }
        : { orderBy?: ResearchDailyLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchDailyLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchDailyLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchDailyLog model
   */
  readonly fields: ResearchDailyLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchDailyLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchDailyLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiment<T extends ExperimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperimentDefaultArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plot<T extends ResearchDailyLog$plotArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDailyLog$plotArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    treatment<T extends ResearchDailyLog$treatmentArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDailyLog$treatmentArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    samples<T extends ResearchDailyLog$samplesArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDailyLog$samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchDailyLog model
   */ 
  interface ResearchDailyLogFieldRefs {
    readonly id: FieldRef<"ResearchDailyLog", 'String'>
    readonly experimentId: FieldRef<"ResearchDailyLog", 'String'>
    readonly plotId: FieldRef<"ResearchDailyLog", 'String'>
    readonly treatmentId: FieldRef<"ResearchDailyLog", 'String'>
    readonly logDate: FieldRef<"ResearchDailyLog", 'DateTime'>
    readonly logTime: FieldRef<"ResearchDailyLog", 'String'>
    readonly category: FieldRef<"ResearchDailyLog", 'LogCategory'>
    readonly title: FieldRef<"ResearchDailyLog", 'String'>
    readonly titleAr: FieldRef<"ResearchDailyLog", 'String'>
    readonly notes: FieldRef<"ResearchDailyLog", 'String'>
    readonly notesAr: FieldRef<"ResearchDailyLog", 'String'>
    readonly measurements: FieldRef<"ResearchDailyLog", 'Json'>
    readonly weatherConditions: FieldRef<"ResearchDailyLog", 'Json'>
    readonly photos: FieldRef<"ResearchDailyLog", 'String[]'>
    readonly attachments: FieldRef<"ResearchDailyLog", 'String[]'>
    readonly recordedBy: FieldRef<"ResearchDailyLog", 'String'>
    readonly deviceId: FieldRef<"ResearchDailyLog", 'String'>
    readonly offlineId: FieldRef<"ResearchDailyLog", 'String'>
    readonly hash: FieldRef<"ResearchDailyLog", 'String'>
    readonly syncedAt: FieldRef<"ResearchDailyLog", 'DateTime'>
    readonly createdAt: FieldRef<"ResearchDailyLog", 'DateTime'>
    readonly updatedAt: FieldRef<"ResearchDailyLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResearchDailyLog findUnique
   */
  export type ResearchDailyLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDailyLog to fetch.
     */
    where: ResearchDailyLogWhereUniqueInput
  }

  /**
   * ResearchDailyLog findUniqueOrThrow
   */
  export type ResearchDailyLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDailyLog to fetch.
     */
    where: ResearchDailyLogWhereUniqueInput
  }

  /**
   * ResearchDailyLog findFirst
   */
  export type ResearchDailyLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDailyLog to fetch.
     */
    where?: ResearchDailyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchDailyLogs to fetch.
     */
    orderBy?: ResearchDailyLogOrderByWithRelationInput | ResearchDailyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchDailyLogs.
     */
    cursor?: ResearchDailyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchDailyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchDailyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchDailyLogs.
     */
    distinct?: ResearchDailyLogScalarFieldEnum | ResearchDailyLogScalarFieldEnum[]
  }

  /**
   * ResearchDailyLog findFirstOrThrow
   */
  export type ResearchDailyLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDailyLog to fetch.
     */
    where?: ResearchDailyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchDailyLogs to fetch.
     */
    orderBy?: ResearchDailyLogOrderByWithRelationInput | ResearchDailyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchDailyLogs.
     */
    cursor?: ResearchDailyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchDailyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchDailyLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchDailyLogs.
     */
    distinct?: ResearchDailyLogScalarFieldEnum | ResearchDailyLogScalarFieldEnum[]
  }

  /**
   * ResearchDailyLog findMany
   */
  export type ResearchDailyLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDailyLogs to fetch.
     */
    where?: ResearchDailyLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchDailyLogs to fetch.
     */
    orderBy?: ResearchDailyLogOrderByWithRelationInput | ResearchDailyLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchDailyLogs.
     */
    cursor?: ResearchDailyLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchDailyLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchDailyLogs.
     */
    skip?: number
    distinct?: ResearchDailyLogScalarFieldEnum | ResearchDailyLogScalarFieldEnum[]
  }

  /**
   * ResearchDailyLog create
   */
  export type ResearchDailyLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchDailyLog.
     */
    data: XOR<ResearchDailyLogCreateInput, ResearchDailyLogUncheckedCreateInput>
  }

  /**
   * ResearchDailyLog createMany
   */
  export type ResearchDailyLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchDailyLogs.
     */
    data: ResearchDailyLogCreateManyInput | ResearchDailyLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchDailyLog createManyAndReturn
   */
  export type ResearchDailyLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResearchDailyLogs.
     */
    data: ResearchDailyLogCreateManyInput | ResearchDailyLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchDailyLog update
   */
  export type ResearchDailyLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchDailyLog.
     */
    data: XOR<ResearchDailyLogUpdateInput, ResearchDailyLogUncheckedUpdateInput>
    /**
     * Choose, which ResearchDailyLog to update.
     */
    where: ResearchDailyLogWhereUniqueInput
  }

  /**
   * ResearchDailyLog updateMany
   */
  export type ResearchDailyLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchDailyLogs.
     */
    data: XOR<ResearchDailyLogUpdateManyMutationInput, ResearchDailyLogUncheckedUpdateManyInput>
    /**
     * Filter which ResearchDailyLogs to update
     */
    where?: ResearchDailyLogWhereInput
  }

  /**
   * ResearchDailyLog upsert
   */
  export type ResearchDailyLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchDailyLog to update in case it exists.
     */
    where: ResearchDailyLogWhereUniqueInput
    /**
     * In case the ResearchDailyLog found by the `where` argument doesn't exist, create a new ResearchDailyLog with this data.
     */
    create: XOR<ResearchDailyLogCreateInput, ResearchDailyLogUncheckedCreateInput>
    /**
     * In case the ResearchDailyLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchDailyLogUpdateInput, ResearchDailyLogUncheckedUpdateInput>
  }

  /**
   * ResearchDailyLog delete
   */
  export type ResearchDailyLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    /**
     * Filter which ResearchDailyLog to delete.
     */
    where: ResearchDailyLogWhereUniqueInput
  }

  /**
   * ResearchDailyLog deleteMany
   */
  export type ResearchDailyLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchDailyLogs to delete
     */
    where?: ResearchDailyLogWhereInput
  }

  /**
   * ResearchDailyLog.plot
   */
  export type ResearchDailyLog$plotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    where?: ResearchPlotWhereInput
  }

  /**
   * ResearchDailyLog.treatment
   */
  export type ResearchDailyLog$treatmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    where?: TreatmentWhereInput
  }

  /**
   * ResearchDailyLog.samples
   */
  export type ResearchDailyLog$samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    where?: LabSampleWhereInput
    orderBy?: LabSampleOrderByWithRelationInput | LabSampleOrderByWithRelationInput[]
    cursor?: LabSampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabSampleScalarFieldEnum | LabSampleScalarFieldEnum[]
  }

  /**
   * ResearchDailyLog without action
   */
  export type ResearchDailyLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
  }


  /**
   * Model LabSample
   */

  export type AggregateLabSample = {
    _count: LabSampleCountAggregateOutputType | null
    _avg: LabSampleAvgAggregateOutputType | null
    _sum: LabSampleSumAggregateOutputType | null
    _min: LabSampleMinAggregateOutputType | null
    _max: LabSampleMaxAggregateOutputType | null
  }

  export type LabSampleAvgAggregateOutputType = {
    quantity: Decimal | null
  }

  export type LabSampleSumAggregateOutputType = {
    quantity: Decimal | null
  }

  export type LabSampleMinAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotId: string | null
    logId: string | null
    sampleCode: string | null
    type: $Enums.SampleType | null
    description: string | null
    descriptionAr: string | null
    collectionDate: Date | null
    collectionTime: string | null
    collectedBy: string | null
    storageLocation: string | null
    storageConditions: string | null
    quantity: Decimal | null
    quantityUnit: string | null
    analysisStatus: string | null
    analyzedBy: string | null
    analyzedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabSampleMaxAggregateOutputType = {
    id: string | null
    experimentId: string | null
    plotId: string | null
    logId: string | null
    sampleCode: string | null
    type: $Enums.SampleType | null
    description: string | null
    descriptionAr: string | null
    collectionDate: Date | null
    collectionTime: string | null
    collectedBy: string | null
    storageLocation: string | null
    storageConditions: string | null
    quantity: Decimal | null
    quantityUnit: string | null
    analysisStatus: string | null
    analyzedBy: string | null
    analyzedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabSampleCountAggregateOutputType = {
    id: number
    experimentId: number
    plotId: number
    logId: number
    sampleCode: number
    type: number
    description: number
    descriptionAr: number
    collectionDate: number
    collectionTime: number
    collectedBy: number
    storageLocation: number
    storageConditions: number
    quantity: number
    quantityUnit: number
    analysisStatus: number
    analysisResults: number
    analyzedBy: number
    analyzedAt: number
    photos: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LabSampleAvgAggregateInputType = {
    quantity?: true
  }

  export type LabSampleSumAggregateInputType = {
    quantity?: true
  }

  export type LabSampleMinAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    logId?: true
    sampleCode?: true
    type?: true
    description?: true
    descriptionAr?: true
    collectionDate?: true
    collectionTime?: true
    collectedBy?: true
    storageLocation?: true
    storageConditions?: true
    quantity?: true
    quantityUnit?: true
    analysisStatus?: true
    analyzedBy?: true
    analyzedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabSampleMaxAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    logId?: true
    sampleCode?: true
    type?: true
    description?: true
    descriptionAr?: true
    collectionDate?: true
    collectionTime?: true
    collectedBy?: true
    storageLocation?: true
    storageConditions?: true
    quantity?: true
    quantityUnit?: true
    analysisStatus?: true
    analyzedBy?: true
    analyzedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabSampleCountAggregateInputType = {
    id?: true
    experimentId?: true
    plotId?: true
    logId?: true
    sampleCode?: true
    type?: true
    description?: true
    descriptionAr?: true
    collectionDate?: true
    collectionTime?: true
    collectedBy?: true
    storageLocation?: true
    storageConditions?: true
    quantity?: true
    quantityUnit?: true
    analysisStatus?: true
    analysisResults?: true
    analyzedBy?: true
    analyzedAt?: true
    photos?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LabSampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabSample to aggregate.
     */
    where?: LabSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabSamples to fetch.
     */
    orderBy?: LabSampleOrderByWithRelationInput | LabSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabSamples
    **/
    _count?: true | LabSampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabSampleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabSampleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabSampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabSampleMaxAggregateInputType
  }

  export type GetLabSampleAggregateType<T extends LabSampleAggregateArgs> = {
        [P in keyof T & keyof AggregateLabSample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabSample[P]>
      : GetScalarType<T[P], AggregateLabSample[P]>
  }




  export type LabSampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabSampleWhereInput
    orderBy?: LabSampleOrderByWithAggregationInput | LabSampleOrderByWithAggregationInput[]
    by: LabSampleScalarFieldEnum[] | LabSampleScalarFieldEnum
    having?: LabSampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabSampleCountAggregateInputType | true
    _avg?: LabSampleAvgAggregateInputType
    _sum?: LabSampleSumAggregateInputType
    _min?: LabSampleMinAggregateInputType
    _max?: LabSampleMaxAggregateInputType
  }

  export type LabSampleGroupByOutputType = {
    id: string
    experimentId: string
    plotId: string | null
    logId: string | null
    sampleCode: string
    type: $Enums.SampleType
    description: string | null
    descriptionAr: string | null
    collectionDate: Date
    collectionTime: string | null
    collectedBy: string
    storageLocation: string | null
    storageConditions: string | null
    quantity: Decimal | null
    quantityUnit: string | null
    analysisStatus: string
    analysisResults: JsonValue
    analyzedBy: string | null
    analyzedAt: Date | null
    photos: string[]
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: LabSampleCountAggregateOutputType | null
    _avg: LabSampleAvgAggregateOutputType | null
    _sum: LabSampleSumAggregateOutputType | null
    _min: LabSampleMinAggregateOutputType | null
    _max: LabSampleMaxAggregateOutputType | null
  }

  type GetLabSampleGroupByPayload<T extends LabSampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabSampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabSampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabSampleGroupByOutputType[P]>
            : GetScalarType<T[P], LabSampleGroupByOutputType[P]>
        }
      >
    >


  export type LabSampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    logId?: boolean
    sampleCode?: boolean
    type?: boolean
    description?: boolean
    descriptionAr?: boolean
    collectionDate?: boolean
    collectionTime?: boolean
    collectedBy?: boolean
    storageLocation?: boolean
    storageConditions?: boolean
    quantity?: boolean
    quantityUnit?: boolean
    analysisStatus?: boolean
    analysisResults?: boolean
    analyzedBy?: boolean
    analyzedAt?: boolean
    photos?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | LabSample$plotArgs<ExtArgs>
    log?: boolean | LabSample$logArgs<ExtArgs>
  }, ExtArgs["result"]["labSample"]>

  export type LabSampleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    logId?: boolean
    sampleCode?: boolean
    type?: boolean
    description?: boolean
    descriptionAr?: boolean
    collectionDate?: boolean
    collectionTime?: boolean
    collectedBy?: boolean
    storageLocation?: boolean
    storageConditions?: boolean
    quantity?: boolean
    quantityUnit?: boolean
    analysisStatus?: boolean
    analysisResults?: boolean
    analyzedBy?: boolean
    analyzedAt?: boolean
    photos?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | LabSample$plotArgs<ExtArgs>
    log?: boolean | LabSample$logArgs<ExtArgs>
  }, ExtArgs["result"]["labSample"]>

  export type LabSampleSelectScalar = {
    id?: boolean
    experimentId?: boolean
    plotId?: boolean
    logId?: boolean
    sampleCode?: boolean
    type?: boolean
    description?: boolean
    descriptionAr?: boolean
    collectionDate?: boolean
    collectionTime?: boolean
    collectedBy?: boolean
    storageLocation?: boolean
    storageConditions?: boolean
    quantity?: boolean
    quantityUnit?: boolean
    analysisStatus?: boolean
    analysisResults?: boolean
    analyzedBy?: boolean
    analyzedAt?: boolean
    photos?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LabSampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | LabSample$plotArgs<ExtArgs>
    log?: boolean | LabSample$logArgs<ExtArgs>
  }
  export type LabSampleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
    plot?: boolean | LabSample$plotArgs<ExtArgs>
    log?: boolean | LabSample$logArgs<ExtArgs>
  }

  export type $LabSamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabSample"
    objects: {
      experiment: Prisma.$ExperimentPayload<ExtArgs>
      plot: Prisma.$ResearchPlotPayload<ExtArgs> | null
      log: Prisma.$ResearchDailyLogPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experimentId: string
      plotId: string | null
      logId: string | null
      sampleCode: string
      type: $Enums.SampleType
      description: string | null
      descriptionAr: string | null
      collectionDate: Date
      collectionTime: string | null
      collectedBy: string
      storageLocation: string | null
      storageConditions: string | null
      quantity: Prisma.Decimal | null
      quantityUnit: string | null
      analysisStatus: string
      analysisResults: Prisma.JsonValue
      analyzedBy: string | null
      analyzedAt: Date | null
      photos: string[]
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["labSample"]>
    composites: {}
  }

  type LabSampleGetPayload<S extends boolean | null | undefined | LabSampleDefaultArgs> = $Result.GetResult<Prisma.$LabSamplePayload, S>

  type LabSampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LabSampleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LabSampleCountAggregateInputType | true
    }

  export interface LabSampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabSample'], meta: { name: 'LabSample' } }
    /**
     * Find zero or one LabSample that matches the filter.
     * @param {LabSampleFindUniqueArgs} args - Arguments to find a LabSample
     * @example
     * // Get one LabSample
     * const labSample = await prisma.labSample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabSampleFindUniqueArgs>(args: SelectSubset<T, LabSampleFindUniqueArgs<ExtArgs>>): Prisma__LabSampleClient<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LabSample that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LabSampleFindUniqueOrThrowArgs} args - Arguments to find a LabSample
     * @example
     * // Get one LabSample
     * const labSample = await prisma.labSample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabSampleFindUniqueOrThrowArgs>(args: SelectSubset<T, LabSampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabSampleClient<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LabSample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabSampleFindFirstArgs} args - Arguments to find a LabSample
     * @example
     * // Get one LabSample
     * const labSample = await prisma.labSample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabSampleFindFirstArgs>(args?: SelectSubset<T, LabSampleFindFirstArgs<ExtArgs>>): Prisma__LabSampleClient<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LabSample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabSampleFindFirstOrThrowArgs} args - Arguments to find a LabSample
     * @example
     * // Get one LabSample
     * const labSample = await prisma.labSample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabSampleFindFirstOrThrowArgs>(args?: SelectSubset<T, LabSampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabSampleClient<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LabSamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabSampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabSamples
     * const labSamples = await prisma.labSample.findMany()
     * 
     * // Get first 10 LabSamples
     * const labSamples = await prisma.labSample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labSampleWithIdOnly = await prisma.labSample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabSampleFindManyArgs>(args?: SelectSubset<T, LabSampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LabSample.
     * @param {LabSampleCreateArgs} args - Arguments to create a LabSample.
     * @example
     * // Create one LabSample
     * const LabSample = await prisma.labSample.create({
     *   data: {
     *     // ... data to create a LabSample
     *   }
     * })
     * 
     */
    create<T extends LabSampleCreateArgs>(args: SelectSubset<T, LabSampleCreateArgs<ExtArgs>>): Prisma__LabSampleClient<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LabSamples.
     * @param {LabSampleCreateManyArgs} args - Arguments to create many LabSamples.
     * @example
     * // Create many LabSamples
     * const labSample = await prisma.labSample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabSampleCreateManyArgs>(args?: SelectSubset<T, LabSampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabSamples and returns the data saved in the database.
     * @param {LabSampleCreateManyAndReturnArgs} args - Arguments to create many LabSamples.
     * @example
     * // Create many LabSamples
     * const labSample = await prisma.labSample.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabSamples and only return the `id`
     * const labSampleWithIdOnly = await prisma.labSample.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabSampleCreateManyAndReturnArgs>(args?: SelectSubset<T, LabSampleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LabSample.
     * @param {LabSampleDeleteArgs} args - Arguments to delete one LabSample.
     * @example
     * // Delete one LabSample
     * const LabSample = await prisma.labSample.delete({
     *   where: {
     *     // ... filter to delete one LabSample
     *   }
     * })
     * 
     */
    delete<T extends LabSampleDeleteArgs>(args: SelectSubset<T, LabSampleDeleteArgs<ExtArgs>>): Prisma__LabSampleClient<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LabSample.
     * @param {LabSampleUpdateArgs} args - Arguments to update one LabSample.
     * @example
     * // Update one LabSample
     * const labSample = await prisma.labSample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabSampleUpdateArgs>(args: SelectSubset<T, LabSampleUpdateArgs<ExtArgs>>): Prisma__LabSampleClient<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LabSamples.
     * @param {LabSampleDeleteManyArgs} args - Arguments to filter LabSamples to delete.
     * @example
     * // Delete a few LabSamples
     * const { count } = await prisma.labSample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabSampleDeleteManyArgs>(args?: SelectSubset<T, LabSampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabSampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabSamples
     * const labSample = await prisma.labSample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabSampleUpdateManyArgs>(args: SelectSubset<T, LabSampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LabSample.
     * @param {LabSampleUpsertArgs} args - Arguments to update or create a LabSample.
     * @example
     * // Update or create a LabSample
     * const labSample = await prisma.labSample.upsert({
     *   create: {
     *     // ... data to create a LabSample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabSample we want to update
     *   }
     * })
     */
    upsert<T extends LabSampleUpsertArgs>(args: SelectSubset<T, LabSampleUpsertArgs<ExtArgs>>): Prisma__LabSampleClient<$Result.GetResult<Prisma.$LabSamplePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LabSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabSampleCountArgs} args - Arguments to filter LabSamples to count.
     * @example
     * // Count the number of LabSamples
     * const count = await prisma.labSample.count({
     *   where: {
     *     // ... the filter for the LabSamples we want to count
     *   }
     * })
    **/
    count<T extends LabSampleCountArgs>(
      args?: Subset<T, LabSampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabSampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabSampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabSampleAggregateArgs>(args: Subset<T, LabSampleAggregateArgs>): Prisma.PrismaPromise<GetLabSampleAggregateType<T>>

    /**
     * Group by LabSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabSampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabSampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabSampleGroupByArgs['orderBy'] }
        : { orderBy?: LabSampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabSampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabSampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabSample model
   */
  readonly fields: LabSampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabSample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabSampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiment<T extends ExperimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperimentDefaultArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plot<T extends LabSample$plotArgs<ExtArgs> = {}>(args?: Subset<T, LabSample$plotArgs<ExtArgs>>): Prisma__ResearchPlotClient<$Result.GetResult<Prisma.$ResearchPlotPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    log<T extends LabSample$logArgs<ExtArgs> = {}>(args?: Subset<T, LabSample$logArgs<ExtArgs>>): Prisma__ResearchDailyLogClient<$Result.GetResult<Prisma.$ResearchDailyLogPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabSample model
   */ 
  interface LabSampleFieldRefs {
    readonly id: FieldRef<"LabSample", 'String'>
    readonly experimentId: FieldRef<"LabSample", 'String'>
    readonly plotId: FieldRef<"LabSample", 'String'>
    readonly logId: FieldRef<"LabSample", 'String'>
    readonly sampleCode: FieldRef<"LabSample", 'String'>
    readonly type: FieldRef<"LabSample", 'SampleType'>
    readonly description: FieldRef<"LabSample", 'String'>
    readonly descriptionAr: FieldRef<"LabSample", 'String'>
    readonly collectionDate: FieldRef<"LabSample", 'DateTime'>
    readonly collectionTime: FieldRef<"LabSample", 'String'>
    readonly collectedBy: FieldRef<"LabSample", 'String'>
    readonly storageLocation: FieldRef<"LabSample", 'String'>
    readonly storageConditions: FieldRef<"LabSample", 'String'>
    readonly quantity: FieldRef<"LabSample", 'Decimal'>
    readonly quantityUnit: FieldRef<"LabSample", 'String'>
    readonly analysisStatus: FieldRef<"LabSample", 'String'>
    readonly analysisResults: FieldRef<"LabSample", 'Json'>
    readonly analyzedBy: FieldRef<"LabSample", 'String'>
    readonly analyzedAt: FieldRef<"LabSample", 'DateTime'>
    readonly photos: FieldRef<"LabSample", 'String[]'>
    readonly metadata: FieldRef<"LabSample", 'Json'>
    readonly createdAt: FieldRef<"LabSample", 'DateTime'>
    readonly updatedAt: FieldRef<"LabSample", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabSample findUnique
   */
  export type LabSampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    /**
     * Filter, which LabSample to fetch.
     */
    where: LabSampleWhereUniqueInput
  }

  /**
   * LabSample findUniqueOrThrow
   */
  export type LabSampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    /**
     * Filter, which LabSample to fetch.
     */
    where: LabSampleWhereUniqueInput
  }

  /**
   * LabSample findFirst
   */
  export type LabSampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    /**
     * Filter, which LabSample to fetch.
     */
    where?: LabSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabSamples to fetch.
     */
    orderBy?: LabSampleOrderByWithRelationInput | LabSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabSamples.
     */
    cursor?: LabSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabSamples.
     */
    distinct?: LabSampleScalarFieldEnum | LabSampleScalarFieldEnum[]
  }

  /**
   * LabSample findFirstOrThrow
   */
  export type LabSampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    /**
     * Filter, which LabSample to fetch.
     */
    where?: LabSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabSamples to fetch.
     */
    orderBy?: LabSampleOrderByWithRelationInput | LabSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabSamples.
     */
    cursor?: LabSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabSamples.
     */
    distinct?: LabSampleScalarFieldEnum | LabSampleScalarFieldEnum[]
  }

  /**
   * LabSample findMany
   */
  export type LabSampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    /**
     * Filter, which LabSamples to fetch.
     */
    where?: LabSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabSamples to fetch.
     */
    orderBy?: LabSampleOrderByWithRelationInput | LabSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabSamples.
     */
    cursor?: LabSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabSamples.
     */
    skip?: number
    distinct?: LabSampleScalarFieldEnum | LabSampleScalarFieldEnum[]
  }

  /**
   * LabSample create
   */
  export type LabSampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    /**
     * The data needed to create a LabSample.
     */
    data: XOR<LabSampleCreateInput, LabSampleUncheckedCreateInput>
  }

  /**
   * LabSample createMany
   */
  export type LabSampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabSamples.
     */
    data: LabSampleCreateManyInput | LabSampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabSample createManyAndReturn
   */
  export type LabSampleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LabSamples.
     */
    data: LabSampleCreateManyInput | LabSampleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabSample update
   */
  export type LabSampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    /**
     * The data needed to update a LabSample.
     */
    data: XOR<LabSampleUpdateInput, LabSampleUncheckedUpdateInput>
    /**
     * Choose, which LabSample to update.
     */
    where: LabSampleWhereUniqueInput
  }

  /**
   * LabSample updateMany
   */
  export type LabSampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabSamples.
     */
    data: XOR<LabSampleUpdateManyMutationInput, LabSampleUncheckedUpdateManyInput>
    /**
     * Filter which LabSamples to update
     */
    where?: LabSampleWhereInput
  }

  /**
   * LabSample upsert
   */
  export type LabSampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    /**
     * The filter to search for the LabSample to update in case it exists.
     */
    where: LabSampleWhereUniqueInput
    /**
     * In case the LabSample found by the `where` argument doesn't exist, create a new LabSample with this data.
     */
    create: XOR<LabSampleCreateInput, LabSampleUncheckedCreateInput>
    /**
     * In case the LabSample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabSampleUpdateInput, LabSampleUncheckedUpdateInput>
  }

  /**
   * LabSample delete
   */
  export type LabSampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
    /**
     * Filter which LabSample to delete.
     */
    where: LabSampleWhereUniqueInput
  }

  /**
   * LabSample deleteMany
   */
  export type LabSampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabSamples to delete
     */
    where?: LabSampleWhereInput
  }

  /**
   * LabSample.plot
   */
  export type LabSample$plotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchPlot
     */
    select?: ResearchPlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchPlotInclude<ExtArgs> | null
    where?: ResearchPlotWhereInput
  }

  /**
   * LabSample.log
   */
  export type LabSample$logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDailyLog
     */
    select?: ResearchDailyLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDailyLogInclude<ExtArgs> | null
    where?: ResearchDailyLogWhereInput
  }

  /**
   * LabSample without action
   */
  export type LabSampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabSample
     */
    select?: LabSampleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabSampleInclude<ExtArgs> | null
  }


  /**
   * Model DigitalSignature
   */

  export type AggregateDigitalSignature = {
    _count: DigitalSignatureCountAggregateOutputType | null
    _min: DigitalSignatureMinAggregateOutputType | null
    _max: DigitalSignatureMaxAggregateOutputType | null
  }

  export type DigitalSignatureMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    signerId: string | null
    signatureHash: string | null
    algorithm: string | null
    payloadHash: string | null
    timestamp: Date | null
    ipAddress: string | null
    purpose: string | null
    isValid: boolean | null
    invalidatedAt: Date | null
    invalidatedReason: string | null
    createdAt: Date | null
  }

  export type DigitalSignatureMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    signerId: string | null
    signatureHash: string | null
    algorithm: string | null
    payloadHash: string | null
    timestamp: Date | null
    ipAddress: string | null
    purpose: string | null
    isValid: boolean | null
    invalidatedAt: Date | null
    invalidatedReason: string | null
    createdAt: Date | null
  }

  export type DigitalSignatureCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    signerId: number
    signatureHash: number
    algorithm: number
    payloadHash: number
    timestamp: number
    ipAddress: number
    deviceInfo: number
    purpose: number
    isValid: number
    invalidatedAt: number
    invalidatedReason: number
    createdAt: number
    _all: number
  }


  export type DigitalSignatureMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    signerId?: true
    signatureHash?: true
    algorithm?: true
    payloadHash?: true
    timestamp?: true
    ipAddress?: true
    purpose?: true
    isValid?: true
    invalidatedAt?: true
    invalidatedReason?: true
    createdAt?: true
  }

  export type DigitalSignatureMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    signerId?: true
    signatureHash?: true
    algorithm?: true
    payloadHash?: true
    timestamp?: true
    ipAddress?: true
    purpose?: true
    isValid?: true
    invalidatedAt?: true
    invalidatedReason?: true
    createdAt?: true
  }

  export type DigitalSignatureCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    signerId?: true
    signatureHash?: true
    algorithm?: true
    payloadHash?: true
    timestamp?: true
    ipAddress?: true
    deviceInfo?: true
    purpose?: true
    isValid?: true
    invalidatedAt?: true
    invalidatedReason?: true
    createdAt?: true
    _all?: true
  }

  export type DigitalSignatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalSignature to aggregate.
     */
    where?: DigitalSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalSignatures to fetch.
     */
    orderBy?: DigitalSignatureOrderByWithRelationInput | DigitalSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DigitalSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DigitalSignatures
    **/
    _count?: true | DigitalSignatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DigitalSignatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DigitalSignatureMaxAggregateInputType
  }

  export type GetDigitalSignatureAggregateType<T extends DigitalSignatureAggregateArgs> = {
        [P in keyof T & keyof AggregateDigitalSignature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDigitalSignature[P]>
      : GetScalarType<T[P], AggregateDigitalSignature[P]>
  }




  export type DigitalSignatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DigitalSignatureWhereInput
    orderBy?: DigitalSignatureOrderByWithAggregationInput | DigitalSignatureOrderByWithAggregationInput[]
    by: DigitalSignatureScalarFieldEnum[] | DigitalSignatureScalarFieldEnum
    having?: DigitalSignatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DigitalSignatureCountAggregateInputType | true
    _min?: DigitalSignatureMinAggregateInputType
    _max?: DigitalSignatureMaxAggregateInputType
  }

  export type DigitalSignatureGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    signerId: string
    signatureHash: string
    algorithm: string
    payloadHash: string
    timestamp: Date
    ipAddress: string | null
    deviceInfo: JsonValue
    purpose: string | null
    isValid: boolean
    invalidatedAt: Date | null
    invalidatedReason: string | null
    createdAt: Date
    _count: DigitalSignatureCountAggregateOutputType | null
    _min: DigitalSignatureMinAggregateOutputType | null
    _max: DigitalSignatureMaxAggregateOutputType | null
  }

  type GetDigitalSignatureGroupByPayload<T extends DigitalSignatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DigitalSignatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DigitalSignatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DigitalSignatureGroupByOutputType[P]>
            : GetScalarType<T[P], DigitalSignatureGroupByOutputType[P]>
        }
      >
    >


  export type DigitalSignatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    signerId?: boolean
    signatureHash?: boolean
    algorithm?: boolean
    payloadHash?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    purpose?: boolean
    isValid?: boolean
    invalidatedAt?: boolean
    invalidatedReason?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["digitalSignature"]>

  export type DigitalSignatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    signerId?: boolean
    signatureHash?: boolean
    algorithm?: boolean
    payloadHash?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    purpose?: boolean
    isValid?: boolean
    invalidatedAt?: boolean
    invalidatedReason?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["digitalSignature"]>

  export type DigitalSignatureSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    signerId?: boolean
    signatureHash?: boolean
    algorithm?: boolean
    payloadHash?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    purpose?: boolean
    isValid?: boolean
    invalidatedAt?: boolean
    invalidatedReason?: boolean
    createdAt?: boolean
  }


  export type $DigitalSignaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DigitalSignature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      signerId: string
      signatureHash: string
      algorithm: string
      payloadHash: string
      timestamp: Date
      ipAddress: string | null
      deviceInfo: Prisma.JsonValue
      purpose: string | null
      isValid: boolean
      invalidatedAt: Date | null
      invalidatedReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["digitalSignature"]>
    composites: {}
  }

  type DigitalSignatureGetPayload<S extends boolean | null | undefined | DigitalSignatureDefaultArgs> = $Result.GetResult<Prisma.$DigitalSignaturePayload, S>

  type DigitalSignatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DigitalSignatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DigitalSignatureCountAggregateInputType | true
    }

  export interface DigitalSignatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DigitalSignature'], meta: { name: 'DigitalSignature' } }
    /**
     * Find zero or one DigitalSignature that matches the filter.
     * @param {DigitalSignatureFindUniqueArgs} args - Arguments to find a DigitalSignature
     * @example
     * // Get one DigitalSignature
     * const digitalSignature = await prisma.digitalSignature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DigitalSignatureFindUniqueArgs>(args: SelectSubset<T, DigitalSignatureFindUniqueArgs<ExtArgs>>): Prisma__DigitalSignatureClient<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DigitalSignature that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DigitalSignatureFindUniqueOrThrowArgs} args - Arguments to find a DigitalSignature
     * @example
     * // Get one DigitalSignature
     * const digitalSignature = await prisma.digitalSignature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DigitalSignatureFindUniqueOrThrowArgs>(args: SelectSubset<T, DigitalSignatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DigitalSignatureClient<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DigitalSignature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFindFirstArgs} args - Arguments to find a DigitalSignature
     * @example
     * // Get one DigitalSignature
     * const digitalSignature = await prisma.digitalSignature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DigitalSignatureFindFirstArgs>(args?: SelectSubset<T, DigitalSignatureFindFirstArgs<ExtArgs>>): Prisma__DigitalSignatureClient<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DigitalSignature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFindFirstOrThrowArgs} args - Arguments to find a DigitalSignature
     * @example
     * // Get one DigitalSignature
     * const digitalSignature = await prisma.digitalSignature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DigitalSignatureFindFirstOrThrowArgs>(args?: SelectSubset<T, DigitalSignatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__DigitalSignatureClient<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DigitalSignatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DigitalSignatures
     * const digitalSignatures = await prisma.digitalSignature.findMany()
     * 
     * // Get first 10 DigitalSignatures
     * const digitalSignatures = await prisma.digitalSignature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const digitalSignatureWithIdOnly = await prisma.digitalSignature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DigitalSignatureFindManyArgs>(args?: SelectSubset<T, DigitalSignatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DigitalSignature.
     * @param {DigitalSignatureCreateArgs} args - Arguments to create a DigitalSignature.
     * @example
     * // Create one DigitalSignature
     * const DigitalSignature = await prisma.digitalSignature.create({
     *   data: {
     *     // ... data to create a DigitalSignature
     *   }
     * })
     * 
     */
    create<T extends DigitalSignatureCreateArgs>(args: SelectSubset<T, DigitalSignatureCreateArgs<ExtArgs>>): Prisma__DigitalSignatureClient<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DigitalSignatures.
     * @param {DigitalSignatureCreateManyArgs} args - Arguments to create many DigitalSignatures.
     * @example
     * // Create many DigitalSignatures
     * const digitalSignature = await prisma.digitalSignature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DigitalSignatureCreateManyArgs>(args?: SelectSubset<T, DigitalSignatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DigitalSignatures and returns the data saved in the database.
     * @param {DigitalSignatureCreateManyAndReturnArgs} args - Arguments to create many DigitalSignatures.
     * @example
     * // Create many DigitalSignatures
     * const digitalSignature = await prisma.digitalSignature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DigitalSignatures and only return the `id`
     * const digitalSignatureWithIdOnly = await prisma.digitalSignature.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DigitalSignatureCreateManyAndReturnArgs>(args?: SelectSubset<T, DigitalSignatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DigitalSignature.
     * @param {DigitalSignatureDeleteArgs} args - Arguments to delete one DigitalSignature.
     * @example
     * // Delete one DigitalSignature
     * const DigitalSignature = await prisma.digitalSignature.delete({
     *   where: {
     *     // ... filter to delete one DigitalSignature
     *   }
     * })
     * 
     */
    delete<T extends DigitalSignatureDeleteArgs>(args: SelectSubset<T, DigitalSignatureDeleteArgs<ExtArgs>>): Prisma__DigitalSignatureClient<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DigitalSignature.
     * @param {DigitalSignatureUpdateArgs} args - Arguments to update one DigitalSignature.
     * @example
     * // Update one DigitalSignature
     * const digitalSignature = await prisma.digitalSignature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DigitalSignatureUpdateArgs>(args: SelectSubset<T, DigitalSignatureUpdateArgs<ExtArgs>>): Prisma__DigitalSignatureClient<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DigitalSignatures.
     * @param {DigitalSignatureDeleteManyArgs} args - Arguments to filter DigitalSignatures to delete.
     * @example
     * // Delete a few DigitalSignatures
     * const { count } = await prisma.digitalSignature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DigitalSignatureDeleteManyArgs>(args?: SelectSubset<T, DigitalSignatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DigitalSignatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DigitalSignatures
     * const digitalSignature = await prisma.digitalSignature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DigitalSignatureUpdateManyArgs>(args: SelectSubset<T, DigitalSignatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DigitalSignature.
     * @param {DigitalSignatureUpsertArgs} args - Arguments to update or create a DigitalSignature.
     * @example
     * // Update or create a DigitalSignature
     * const digitalSignature = await prisma.digitalSignature.upsert({
     *   create: {
     *     // ... data to create a DigitalSignature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DigitalSignature we want to update
     *   }
     * })
     */
    upsert<T extends DigitalSignatureUpsertArgs>(args: SelectSubset<T, DigitalSignatureUpsertArgs<ExtArgs>>): Prisma__DigitalSignatureClient<$Result.GetResult<Prisma.$DigitalSignaturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DigitalSignatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureCountArgs} args - Arguments to filter DigitalSignatures to count.
     * @example
     * // Count the number of DigitalSignatures
     * const count = await prisma.digitalSignature.count({
     *   where: {
     *     // ... the filter for the DigitalSignatures we want to count
     *   }
     * })
    **/
    count<T extends DigitalSignatureCountArgs>(
      args?: Subset<T, DigitalSignatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DigitalSignatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DigitalSignature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DigitalSignatureAggregateArgs>(args: Subset<T, DigitalSignatureAggregateArgs>): Prisma.PrismaPromise<GetDigitalSignatureAggregateType<T>>

    /**
     * Group by DigitalSignature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalSignatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DigitalSignatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DigitalSignatureGroupByArgs['orderBy'] }
        : { orderBy?: DigitalSignatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DigitalSignatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDigitalSignatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DigitalSignature model
   */
  readonly fields: DigitalSignatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DigitalSignature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DigitalSignatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DigitalSignature model
   */ 
  interface DigitalSignatureFieldRefs {
    readonly id: FieldRef<"DigitalSignature", 'String'>
    readonly entityType: FieldRef<"DigitalSignature", 'String'>
    readonly entityId: FieldRef<"DigitalSignature", 'String'>
    readonly signerId: FieldRef<"DigitalSignature", 'String'>
    readonly signatureHash: FieldRef<"DigitalSignature", 'String'>
    readonly algorithm: FieldRef<"DigitalSignature", 'String'>
    readonly payloadHash: FieldRef<"DigitalSignature", 'String'>
    readonly timestamp: FieldRef<"DigitalSignature", 'DateTime'>
    readonly ipAddress: FieldRef<"DigitalSignature", 'String'>
    readonly deviceInfo: FieldRef<"DigitalSignature", 'Json'>
    readonly purpose: FieldRef<"DigitalSignature", 'String'>
    readonly isValid: FieldRef<"DigitalSignature", 'Boolean'>
    readonly invalidatedAt: FieldRef<"DigitalSignature", 'DateTime'>
    readonly invalidatedReason: FieldRef<"DigitalSignature", 'String'>
    readonly createdAt: FieldRef<"DigitalSignature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DigitalSignature findUnique
   */
  export type DigitalSignatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
    /**
     * Filter, which DigitalSignature to fetch.
     */
    where: DigitalSignatureWhereUniqueInput
  }

  /**
   * DigitalSignature findUniqueOrThrow
   */
  export type DigitalSignatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
    /**
     * Filter, which DigitalSignature to fetch.
     */
    where: DigitalSignatureWhereUniqueInput
  }

  /**
   * DigitalSignature findFirst
   */
  export type DigitalSignatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
    /**
     * Filter, which DigitalSignature to fetch.
     */
    where?: DigitalSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalSignatures to fetch.
     */
    orderBy?: DigitalSignatureOrderByWithRelationInput | DigitalSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalSignatures.
     */
    cursor?: DigitalSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalSignatures.
     */
    distinct?: DigitalSignatureScalarFieldEnum | DigitalSignatureScalarFieldEnum[]
  }

  /**
   * DigitalSignature findFirstOrThrow
   */
  export type DigitalSignatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
    /**
     * Filter, which DigitalSignature to fetch.
     */
    where?: DigitalSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalSignatures to fetch.
     */
    orderBy?: DigitalSignatureOrderByWithRelationInput | DigitalSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalSignatures.
     */
    cursor?: DigitalSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalSignatures.
     */
    distinct?: DigitalSignatureScalarFieldEnum | DigitalSignatureScalarFieldEnum[]
  }

  /**
   * DigitalSignature findMany
   */
  export type DigitalSignatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
    /**
     * Filter, which DigitalSignatures to fetch.
     */
    where?: DigitalSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalSignatures to fetch.
     */
    orderBy?: DigitalSignatureOrderByWithRelationInput | DigitalSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DigitalSignatures.
     */
    cursor?: DigitalSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalSignatures.
     */
    skip?: number
    distinct?: DigitalSignatureScalarFieldEnum | DigitalSignatureScalarFieldEnum[]
  }

  /**
   * DigitalSignature create
   */
  export type DigitalSignatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
    /**
     * The data needed to create a DigitalSignature.
     */
    data: XOR<DigitalSignatureCreateInput, DigitalSignatureUncheckedCreateInput>
  }

  /**
   * DigitalSignature createMany
   */
  export type DigitalSignatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DigitalSignatures.
     */
    data: DigitalSignatureCreateManyInput | DigitalSignatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DigitalSignature createManyAndReturn
   */
  export type DigitalSignatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DigitalSignatures.
     */
    data: DigitalSignatureCreateManyInput | DigitalSignatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DigitalSignature update
   */
  export type DigitalSignatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
    /**
     * The data needed to update a DigitalSignature.
     */
    data: XOR<DigitalSignatureUpdateInput, DigitalSignatureUncheckedUpdateInput>
    /**
     * Choose, which DigitalSignature to update.
     */
    where: DigitalSignatureWhereUniqueInput
  }

  /**
   * DigitalSignature updateMany
   */
  export type DigitalSignatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DigitalSignatures.
     */
    data: XOR<DigitalSignatureUpdateManyMutationInput, DigitalSignatureUncheckedUpdateManyInput>
    /**
     * Filter which DigitalSignatures to update
     */
    where?: DigitalSignatureWhereInput
  }

  /**
   * DigitalSignature upsert
   */
  export type DigitalSignatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
    /**
     * The filter to search for the DigitalSignature to update in case it exists.
     */
    where: DigitalSignatureWhereUniqueInput
    /**
     * In case the DigitalSignature found by the `where` argument doesn't exist, create a new DigitalSignature with this data.
     */
    create: XOR<DigitalSignatureCreateInput, DigitalSignatureUncheckedCreateInput>
    /**
     * In case the DigitalSignature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DigitalSignatureUpdateInput, DigitalSignatureUncheckedUpdateInput>
  }

  /**
   * DigitalSignature delete
   */
  export type DigitalSignatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
    /**
     * Filter which DigitalSignature to delete.
     */
    where: DigitalSignatureWhereUniqueInput
  }

  /**
   * DigitalSignature deleteMany
   */
  export type DigitalSignatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalSignatures to delete
     */
    where?: DigitalSignatureWhereInput
  }

  /**
   * DigitalSignature without action
   */
  export type DigitalSignatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalSignature
     */
    select?: DigitalSignatureSelect<ExtArgs> | null
  }


  /**
   * Model ExperimentCollaborator
   */

  export type AggregateExperimentCollaborator = {
    _count: ExperimentCollaboratorCountAggregateOutputType | null
    _min: ExperimentCollaboratorMinAggregateOutputType | null
    _max: ExperimentCollaboratorMaxAggregateOutputType | null
  }

  export type ExperimentCollaboratorMinAggregateOutputType = {
    id: string | null
    experimentId: string | null
    userId: string | null
    role: string | null
    invitedBy: string | null
    acceptedAt: Date | null
    createdAt: Date | null
  }

  export type ExperimentCollaboratorMaxAggregateOutputType = {
    id: string | null
    experimentId: string | null
    userId: string | null
    role: string | null
    invitedBy: string | null
    acceptedAt: Date | null
    createdAt: Date | null
  }

  export type ExperimentCollaboratorCountAggregateOutputType = {
    id: number
    experimentId: number
    userId: number
    role: number
    permissions: number
    invitedBy: number
    acceptedAt: number
    createdAt: number
    _all: number
  }


  export type ExperimentCollaboratorMinAggregateInputType = {
    id?: true
    experimentId?: true
    userId?: true
    role?: true
    invitedBy?: true
    acceptedAt?: true
    createdAt?: true
  }

  export type ExperimentCollaboratorMaxAggregateInputType = {
    id?: true
    experimentId?: true
    userId?: true
    role?: true
    invitedBy?: true
    acceptedAt?: true
    createdAt?: true
  }

  export type ExperimentCollaboratorCountAggregateInputType = {
    id?: true
    experimentId?: true
    userId?: true
    role?: true
    permissions?: true
    invitedBy?: true
    acceptedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ExperimentCollaboratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperimentCollaborator to aggregate.
     */
    where?: ExperimentCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperimentCollaborators to fetch.
     */
    orderBy?: ExperimentCollaboratorOrderByWithRelationInput | ExperimentCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExperimentCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperimentCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperimentCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExperimentCollaborators
    **/
    _count?: true | ExperimentCollaboratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperimentCollaboratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperimentCollaboratorMaxAggregateInputType
  }

  export type GetExperimentCollaboratorAggregateType<T extends ExperimentCollaboratorAggregateArgs> = {
        [P in keyof T & keyof AggregateExperimentCollaborator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperimentCollaborator[P]>
      : GetScalarType<T[P], AggregateExperimentCollaborator[P]>
  }




  export type ExperimentCollaboratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperimentCollaboratorWhereInput
    orderBy?: ExperimentCollaboratorOrderByWithAggregationInput | ExperimentCollaboratorOrderByWithAggregationInput[]
    by: ExperimentCollaboratorScalarFieldEnum[] | ExperimentCollaboratorScalarFieldEnum
    having?: ExperimentCollaboratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperimentCollaboratorCountAggregateInputType | true
    _min?: ExperimentCollaboratorMinAggregateInputType
    _max?: ExperimentCollaboratorMaxAggregateInputType
  }

  export type ExperimentCollaboratorGroupByOutputType = {
    id: string
    experimentId: string
    userId: string
    role: string
    permissions: JsonValue
    invitedBy: string | null
    acceptedAt: Date | null
    createdAt: Date
    _count: ExperimentCollaboratorCountAggregateOutputType | null
    _min: ExperimentCollaboratorMinAggregateOutputType | null
    _max: ExperimentCollaboratorMaxAggregateOutputType | null
  }

  type GetExperimentCollaboratorGroupByPayload<T extends ExperimentCollaboratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperimentCollaboratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperimentCollaboratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperimentCollaboratorGroupByOutputType[P]>
            : GetScalarType<T[P], ExperimentCollaboratorGroupByOutputType[P]>
        }
      >
    >


  export type ExperimentCollaboratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experimentCollaborator"]>

  export type ExperimentCollaboratorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experimentCollaborator"]>

  export type ExperimentCollaboratorSelectScalar = {
    id?: boolean
    experimentId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
  }

  export type ExperimentCollaboratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }
  export type ExperimentCollaboratorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentDefaultArgs<ExtArgs>
  }

  export type $ExperimentCollaboratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExperimentCollaborator"
    objects: {
      experiment: Prisma.$ExperimentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experimentId: string
      userId: string
      role: string
      permissions: Prisma.JsonValue
      invitedBy: string | null
      acceptedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["experimentCollaborator"]>
    composites: {}
  }

  type ExperimentCollaboratorGetPayload<S extends boolean | null | undefined | ExperimentCollaboratorDefaultArgs> = $Result.GetResult<Prisma.$ExperimentCollaboratorPayload, S>

  type ExperimentCollaboratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExperimentCollaboratorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExperimentCollaboratorCountAggregateInputType | true
    }

  export interface ExperimentCollaboratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExperimentCollaborator'], meta: { name: 'ExperimentCollaborator' } }
    /**
     * Find zero or one ExperimentCollaborator that matches the filter.
     * @param {ExperimentCollaboratorFindUniqueArgs} args - Arguments to find a ExperimentCollaborator
     * @example
     * // Get one ExperimentCollaborator
     * const experimentCollaborator = await prisma.experimentCollaborator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExperimentCollaboratorFindUniqueArgs>(args: SelectSubset<T, ExperimentCollaboratorFindUniqueArgs<ExtArgs>>): Prisma__ExperimentCollaboratorClient<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExperimentCollaborator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExperimentCollaboratorFindUniqueOrThrowArgs} args - Arguments to find a ExperimentCollaborator
     * @example
     * // Get one ExperimentCollaborator
     * const experimentCollaborator = await prisma.experimentCollaborator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExperimentCollaboratorFindUniqueOrThrowArgs>(args: SelectSubset<T, ExperimentCollaboratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExperimentCollaboratorClient<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExperimentCollaborator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentCollaboratorFindFirstArgs} args - Arguments to find a ExperimentCollaborator
     * @example
     * // Get one ExperimentCollaborator
     * const experimentCollaborator = await prisma.experimentCollaborator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExperimentCollaboratorFindFirstArgs>(args?: SelectSubset<T, ExperimentCollaboratorFindFirstArgs<ExtArgs>>): Prisma__ExperimentCollaboratorClient<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExperimentCollaborator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentCollaboratorFindFirstOrThrowArgs} args - Arguments to find a ExperimentCollaborator
     * @example
     * // Get one ExperimentCollaborator
     * const experimentCollaborator = await prisma.experimentCollaborator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExperimentCollaboratorFindFirstOrThrowArgs>(args?: SelectSubset<T, ExperimentCollaboratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExperimentCollaboratorClient<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExperimentCollaborators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentCollaboratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExperimentCollaborators
     * const experimentCollaborators = await prisma.experimentCollaborator.findMany()
     * 
     * // Get first 10 ExperimentCollaborators
     * const experimentCollaborators = await prisma.experimentCollaborator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experimentCollaboratorWithIdOnly = await prisma.experimentCollaborator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExperimentCollaboratorFindManyArgs>(args?: SelectSubset<T, ExperimentCollaboratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExperimentCollaborator.
     * @param {ExperimentCollaboratorCreateArgs} args - Arguments to create a ExperimentCollaborator.
     * @example
     * // Create one ExperimentCollaborator
     * const ExperimentCollaborator = await prisma.experimentCollaborator.create({
     *   data: {
     *     // ... data to create a ExperimentCollaborator
     *   }
     * })
     * 
     */
    create<T extends ExperimentCollaboratorCreateArgs>(args: SelectSubset<T, ExperimentCollaboratorCreateArgs<ExtArgs>>): Prisma__ExperimentCollaboratorClient<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExperimentCollaborators.
     * @param {ExperimentCollaboratorCreateManyArgs} args - Arguments to create many ExperimentCollaborators.
     * @example
     * // Create many ExperimentCollaborators
     * const experimentCollaborator = await prisma.experimentCollaborator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExperimentCollaboratorCreateManyArgs>(args?: SelectSubset<T, ExperimentCollaboratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExperimentCollaborators and returns the data saved in the database.
     * @param {ExperimentCollaboratorCreateManyAndReturnArgs} args - Arguments to create many ExperimentCollaborators.
     * @example
     * // Create many ExperimentCollaborators
     * const experimentCollaborator = await prisma.experimentCollaborator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExperimentCollaborators and only return the `id`
     * const experimentCollaboratorWithIdOnly = await prisma.experimentCollaborator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExperimentCollaboratorCreateManyAndReturnArgs>(args?: SelectSubset<T, ExperimentCollaboratorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExperimentCollaborator.
     * @param {ExperimentCollaboratorDeleteArgs} args - Arguments to delete one ExperimentCollaborator.
     * @example
     * // Delete one ExperimentCollaborator
     * const ExperimentCollaborator = await prisma.experimentCollaborator.delete({
     *   where: {
     *     // ... filter to delete one ExperimentCollaborator
     *   }
     * })
     * 
     */
    delete<T extends ExperimentCollaboratorDeleteArgs>(args: SelectSubset<T, ExperimentCollaboratorDeleteArgs<ExtArgs>>): Prisma__ExperimentCollaboratorClient<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExperimentCollaborator.
     * @param {ExperimentCollaboratorUpdateArgs} args - Arguments to update one ExperimentCollaborator.
     * @example
     * // Update one ExperimentCollaborator
     * const experimentCollaborator = await prisma.experimentCollaborator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExperimentCollaboratorUpdateArgs>(args: SelectSubset<T, ExperimentCollaboratorUpdateArgs<ExtArgs>>): Prisma__ExperimentCollaboratorClient<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExperimentCollaborators.
     * @param {ExperimentCollaboratorDeleteManyArgs} args - Arguments to filter ExperimentCollaborators to delete.
     * @example
     * // Delete a few ExperimentCollaborators
     * const { count } = await prisma.experimentCollaborator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExperimentCollaboratorDeleteManyArgs>(args?: SelectSubset<T, ExperimentCollaboratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExperimentCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentCollaboratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExperimentCollaborators
     * const experimentCollaborator = await prisma.experimentCollaborator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExperimentCollaboratorUpdateManyArgs>(args: SelectSubset<T, ExperimentCollaboratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExperimentCollaborator.
     * @param {ExperimentCollaboratorUpsertArgs} args - Arguments to update or create a ExperimentCollaborator.
     * @example
     * // Update or create a ExperimentCollaborator
     * const experimentCollaborator = await prisma.experimentCollaborator.upsert({
     *   create: {
     *     // ... data to create a ExperimentCollaborator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExperimentCollaborator we want to update
     *   }
     * })
     */
    upsert<T extends ExperimentCollaboratorUpsertArgs>(args: SelectSubset<T, ExperimentCollaboratorUpsertArgs<ExtArgs>>): Prisma__ExperimentCollaboratorClient<$Result.GetResult<Prisma.$ExperimentCollaboratorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExperimentCollaborators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentCollaboratorCountArgs} args - Arguments to filter ExperimentCollaborators to count.
     * @example
     * // Count the number of ExperimentCollaborators
     * const count = await prisma.experimentCollaborator.count({
     *   where: {
     *     // ... the filter for the ExperimentCollaborators we want to count
     *   }
     * })
    **/
    count<T extends ExperimentCollaboratorCountArgs>(
      args?: Subset<T, ExperimentCollaboratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperimentCollaboratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExperimentCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentCollaboratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperimentCollaboratorAggregateArgs>(args: Subset<T, ExperimentCollaboratorAggregateArgs>): Prisma.PrismaPromise<GetExperimentCollaboratorAggregateType<T>>

    /**
     * Group by ExperimentCollaborator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentCollaboratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExperimentCollaboratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExperimentCollaboratorGroupByArgs['orderBy'] }
        : { orderBy?: ExperimentCollaboratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExperimentCollaboratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperimentCollaboratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExperimentCollaborator model
   */
  readonly fields: ExperimentCollaboratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExperimentCollaborator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExperimentCollaboratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiment<T extends ExperimentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperimentDefaultArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExperimentCollaborator model
   */ 
  interface ExperimentCollaboratorFieldRefs {
    readonly id: FieldRef<"ExperimentCollaborator", 'String'>
    readonly experimentId: FieldRef<"ExperimentCollaborator", 'String'>
    readonly userId: FieldRef<"ExperimentCollaborator", 'String'>
    readonly role: FieldRef<"ExperimentCollaborator", 'String'>
    readonly permissions: FieldRef<"ExperimentCollaborator", 'Json'>
    readonly invitedBy: FieldRef<"ExperimentCollaborator", 'String'>
    readonly acceptedAt: FieldRef<"ExperimentCollaborator", 'DateTime'>
    readonly createdAt: FieldRef<"ExperimentCollaborator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExperimentCollaborator findUnique
   */
  export type ExperimentCollaboratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentCollaborator to fetch.
     */
    where: ExperimentCollaboratorWhereUniqueInput
  }

  /**
   * ExperimentCollaborator findUniqueOrThrow
   */
  export type ExperimentCollaboratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentCollaborator to fetch.
     */
    where: ExperimentCollaboratorWhereUniqueInput
  }

  /**
   * ExperimentCollaborator findFirst
   */
  export type ExperimentCollaboratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentCollaborator to fetch.
     */
    where?: ExperimentCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperimentCollaborators to fetch.
     */
    orderBy?: ExperimentCollaboratorOrderByWithRelationInput | ExperimentCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperimentCollaborators.
     */
    cursor?: ExperimentCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperimentCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperimentCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperimentCollaborators.
     */
    distinct?: ExperimentCollaboratorScalarFieldEnum | ExperimentCollaboratorScalarFieldEnum[]
  }

  /**
   * ExperimentCollaborator findFirstOrThrow
   */
  export type ExperimentCollaboratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentCollaborator to fetch.
     */
    where?: ExperimentCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperimentCollaborators to fetch.
     */
    orderBy?: ExperimentCollaboratorOrderByWithRelationInput | ExperimentCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperimentCollaborators.
     */
    cursor?: ExperimentCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperimentCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperimentCollaborators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperimentCollaborators.
     */
    distinct?: ExperimentCollaboratorScalarFieldEnum | ExperimentCollaboratorScalarFieldEnum[]
  }

  /**
   * ExperimentCollaborator findMany
   */
  export type ExperimentCollaboratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentCollaborators to fetch.
     */
    where?: ExperimentCollaboratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperimentCollaborators to fetch.
     */
    orderBy?: ExperimentCollaboratorOrderByWithRelationInput | ExperimentCollaboratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExperimentCollaborators.
     */
    cursor?: ExperimentCollaboratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperimentCollaborators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperimentCollaborators.
     */
    skip?: number
    distinct?: ExperimentCollaboratorScalarFieldEnum | ExperimentCollaboratorScalarFieldEnum[]
  }

  /**
   * ExperimentCollaborator create
   */
  export type ExperimentCollaboratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to create a ExperimentCollaborator.
     */
    data: XOR<ExperimentCollaboratorCreateInput, ExperimentCollaboratorUncheckedCreateInput>
  }

  /**
   * ExperimentCollaborator createMany
   */
  export type ExperimentCollaboratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExperimentCollaborators.
     */
    data: ExperimentCollaboratorCreateManyInput | ExperimentCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExperimentCollaborator createManyAndReturn
   */
  export type ExperimentCollaboratorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExperimentCollaborators.
     */
    data: ExperimentCollaboratorCreateManyInput | ExperimentCollaboratorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExperimentCollaborator update
   */
  export type ExperimentCollaboratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    /**
     * The data needed to update a ExperimentCollaborator.
     */
    data: XOR<ExperimentCollaboratorUpdateInput, ExperimentCollaboratorUncheckedUpdateInput>
    /**
     * Choose, which ExperimentCollaborator to update.
     */
    where: ExperimentCollaboratorWhereUniqueInput
  }

  /**
   * ExperimentCollaborator updateMany
   */
  export type ExperimentCollaboratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExperimentCollaborators.
     */
    data: XOR<ExperimentCollaboratorUpdateManyMutationInput, ExperimentCollaboratorUncheckedUpdateManyInput>
    /**
     * Filter which ExperimentCollaborators to update
     */
    where?: ExperimentCollaboratorWhereInput
  }

  /**
   * ExperimentCollaborator upsert
   */
  export type ExperimentCollaboratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    /**
     * The filter to search for the ExperimentCollaborator to update in case it exists.
     */
    where: ExperimentCollaboratorWhereUniqueInput
    /**
     * In case the ExperimentCollaborator found by the `where` argument doesn't exist, create a new ExperimentCollaborator with this data.
     */
    create: XOR<ExperimentCollaboratorCreateInput, ExperimentCollaboratorUncheckedCreateInput>
    /**
     * In case the ExperimentCollaborator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExperimentCollaboratorUpdateInput, ExperimentCollaboratorUncheckedUpdateInput>
  }

  /**
   * ExperimentCollaborator delete
   */
  export type ExperimentCollaboratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
    /**
     * Filter which ExperimentCollaborator to delete.
     */
    where: ExperimentCollaboratorWhereUniqueInput
  }

  /**
   * ExperimentCollaborator deleteMany
   */
  export type ExperimentCollaboratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperimentCollaborators to delete
     */
    where?: ExperimentCollaboratorWhereInput
  }

  /**
   * ExperimentCollaborator without action
   */
  export type ExperimentCollaboratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentCollaborator
     */
    select?: ExperimentCollaboratorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentCollaboratorInclude<ExtArgs> | null
  }


  /**
   * Model ExperimentAuditLog
   */

  export type AggregateExperimentAuditLog = {
    _count: ExperimentAuditLogCountAggregateOutputType | null
    _min: ExperimentAuditLogMinAggregateOutputType | null
    _max: ExperimentAuditLogMaxAggregateOutputType | null
  }

  export type ExperimentAuditLogMinAggregateOutputType = {
    id: string | null
    experimentId: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    changedBy: string | null
    changedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type ExperimentAuditLogMaxAggregateOutputType = {
    id: string | null
    experimentId: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    changedBy: string | null
    changedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type ExperimentAuditLogCountAggregateOutputType = {
    id: number
    experimentId: number
    entityType: number
    entityId: number
    action: number
    oldValues: number
    newValues: number
    changedBy: number
    changedAt: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type ExperimentAuditLogMinAggregateInputType = {
    id?: true
    experimentId?: true
    entityType?: true
    entityId?: true
    action?: true
    changedBy?: true
    changedAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type ExperimentAuditLogMaxAggregateInputType = {
    id?: true
    experimentId?: true
    entityType?: true
    entityId?: true
    action?: true
    changedBy?: true
    changedAt?: true
    ipAddress?: true
    userAgent?: true
  }

  export type ExperimentAuditLogCountAggregateInputType = {
    id?: true
    experimentId?: true
    entityType?: true
    entityId?: true
    action?: true
    oldValues?: true
    newValues?: true
    changedBy?: true
    changedAt?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type ExperimentAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperimentAuditLog to aggregate.
     */
    where?: ExperimentAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperimentAuditLogs to fetch.
     */
    orderBy?: ExperimentAuditLogOrderByWithRelationInput | ExperimentAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExperimentAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperimentAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperimentAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExperimentAuditLogs
    **/
    _count?: true | ExperimentAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperimentAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperimentAuditLogMaxAggregateInputType
  }

  export type GetExperimentAuditLogAggregateType<T extends ExperimentAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateExperimentAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperimentAuditLog[P]>
      : GetScalarType<T[P], AggregateExperimentAuditLog[P]>
  }




  export type ExperimentAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperimentAuditLogWhereInput
    orderBy?: ExperimentAuditLogOrderByWithAggregationInput | ExperimentAuditLogOrderByWithAggregationInput[]
    by: ExperimentAuditLogScalarFieldEnum[] | ExperimentAuditLogScalarFieldEnum
    having?: ExperimentAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperimentAuditLogCountAggregateInputType | true
    _min?: ExperimentAuditLogMinAggregateInputType
    _max?: ExperimentAuditLogMaxAggregateInputType
  }

  export type ExperimentAuditLogGroupByOutputType = {
    id: string
    experimentId: string | null
    entityType: string
    entityId: string
    action: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    changedBy: string
    changedAt: Date
    ipAddress: string | null
    userAgent: string | null
    _count: ExperimentAuditLogCountAggregateOutputType | null
    _min: ExperimentAuditLogMinAggregateOutputType | null
    _max: ExperimentAuditLogMaxAggregateOutputType | null
  }

  type GetExperimentAuditLogGroupByPayload<T extends ExperimentAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperimentAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperimentAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperimentAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], ExperimentAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type ExperimentAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedBy?: boolean
    changedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    experiment?: boolean | ExperimentAuditLog$experimentArgs<ExtArgs>
  }, ExtArgs["result"]["experimentAuditLog"]>

  export type ExperimentAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experimentId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedBy?: boolean
    changedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    experiment?: boolean | ExperimentAuditLog$experimentArgs<ExtArgs>
  }, ExtArgs["result"]["experimentAuditLog"]>

  export type ExperimentAuditLogSelectScalar = {
    id?: boolean
    experimentId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedBy?: boolean
    changedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type ExperimentAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentAuditLog$experimentArgs<ExtArgs>
  }
  export type ExperimentAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiment?: boolean | ExperimentAuditLog$experimentArgs<ExtArgs>
  }

  export type $ExperimentAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExperimentAuditLog"
    objects: {
      experiment: Prisma.$ExperimentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experimentId: string | null
      entityType: string
      entityId: string
      action: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      changedBy: string
      changedAt: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["experimentAuditLog"]>
    composites: {}
  }

  type ExperimentAuditLogGetPayload<S extends boolean | null | undefined | ExperimentAuditLogDefaultArgs> = $Result.GetResult<Prisma.$ExperimentAuditLogPayload, S>

  type ExperimentAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExperimentAuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExperimentAuditLogCountAggregateInputType | true
    }

  export interface ExperimentAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExperimentAuditLog'], meta: { name: 'ExperimentAuditLog' } }
    /**
     * Find zero or one ExperimentAuditLog that matches the filter.
     * @param {ExperimentAuditLogFindUniqueArgs} args - Arguments to find a ExperimentAuditLog
     * @example
     * // Get one ExperimentAuditLog
     * const experimentAuditLog = await prisma.experimentAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExperimentAuditLogFindUniqueArgs>(args: SelectSubset<T, ExperimentAuditLogFindUniqueArgs<ExtArgs>>): Prisma__ExperimentAuditLogClient<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExperimentAuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExperimentAuditLogFindUniqueOrThrowArgs} args - Arguments to find a ExperimentAuditLog
     * @example
     * // Get one ExperimentAuditLog
     * const experimentAuditLog = await prisma.experimentAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExperimentAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ExperimentAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExperimentAuditLogClient<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExperimentAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentAuditLogFindFirstArgs} args - Arguments to find a ExperimentAuditLog
     * @example
     * // Get one ExperimentAuditLog
     * const experimentAuditLog = await prisma.experimentAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExperimentAuditLogFindFirstArgs>(args?: SelectSubset<T, ExperimentAuditLogFindFirstArgs<ExtArgs>>): Prisma__ExperimentAuditLogClient<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExperimentAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentAuditLogFindFirstOrThrowArgs} args - Arguments to find a ExperimentAuditLog
     * @example
     * // Get one ExperimentAuditLog
     * const experimentAuditLog = await prisma.experimentAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExperimentAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ExperimentAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExperimentAuditLogClient<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExperimentAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExperimentAuditLogs
     * const experimentAuditLogs = await prisma.experimentAuditLog.findMany()
     * 
     * // Get first 10 ExperimentAuditLogs
     * const experimentAuditLogs = await prisma.experimentAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experimentAuditLogWithIdOnly = await prisma.experimentAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExperimentAuditLogFindManyArgs>(args?: SelectSubset<T, ExperimentAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExperimentAuditLog.
     * @param {ExperimentAuditLogCreateArgs} args - Arguments to create a ExperimentAuditLog.
     * @example
     * // Create one ExperimentAuditLog
     * const ExperimentAuditLog = await prisma.experimentAuditLog.create({
     *   data: {
     *     // ... data to create a ExperimentAuditLog
     *   }
     * })
     * 
     */
    create<T extends ExperimentAuditLogCreateArgs>(args: SelectSubset<T, ExperimentAuditLogCreateArgs<ExtArgs>>): Prisma__ExperimentAuditLogClient<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExperimentAuditLogs.
     * @param {ExperimentAuditLogCreateManyArgs} args - Arguments to create many ExperimentAuditLogs.
     * @example
     * // Create many ExperimentAuditLogs
     * const experimentAuditLog = await prisma.experimentAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExperimentAuditLogCreateManyArgs>(args?: SelectSubset<T, ExperimentAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExperimentAuditLogs and returns the data saved in the database.
     * @param {ExperimentAuditLogCreateManyAndReturnArgs} args - Arguments to create many ExperimentAuditLogs.
     * @example
     * // Create many ExperimentAuditLogs
     * const experimentAuditLog = await prisma.experimentAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExperimentAuditLogs and only return the `id`
     * const experimentAuditLogWithIdOnly = await prisma.experimentAuditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExperimentAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ExperimentAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExperimentAuditLog.
     * @param {ExperimentAuditLogDeleteArgs} args - Arguments to delete one ExperimentAuditLog.
     * @example
     * // Delete one ExperimentAuditLog
     * const ExperimentAuditLog = await prisma.experimentAuditLog.delete({
     *   where: {
     *     // ... filter to delete one ExperimentAuditLog
     *   }
     * })
     * 
     */
    delete<T extends ExperimentAuditLogDeleteArgs>(args: SelectSubset<T, ExperimentAuditLogDeleteArgs<ExtArgs>>): Prisma__ExperimentAuditLogClient<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExperimentAuditLog.
     * @param {ExperimentAuditLogUpdateArgs} args - Arguments to update one ExperimentAuditLog.
     * @example
     * // Update one ExperimentAuditLog
     * const experimentAuditLog = await prisma.experimentAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExperimentAuditLogUpdateArgs>(args: SelectSubset<T, ExperimentAuditLogUpdateArgs<ExtArgs>>): Prisma__ExperimentAuditLogClient<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExperimentAuditLogs.
     * @param {ExperimentAuditLogDeleteManyArgs} args - Arguments to filter ExperimentAuditLogs to delete.
     * @example
     * // Delete a few ExperimentAuditLogs
     * const { count } = await prisma.experimentAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExperimentAuditLogDeleteManyArgs>(args?: SelectSubset<T, ExperimentAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExperimentAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExperimentAuditLogs
     * const experimentAuditLog = await prisma.experimentAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExperimentAuditLogUpdateManyArgs>(args: SelectSubset<T, ExperimentAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExperimentAuditLog.
     * @param {ExperimentAuditLogUpsertArgs} args - Arguments to update or create a ExperimentAuditLog.
     * @example
     * // Update or create a ExperimentAuditLog
     * const experimentAuditLog = await prisma.experimentAuditLog.upsert({
     *   create: {
     *     // ... data to create a ExperimentAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExperimentAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends ExperimentAuditLogUpsertArgs>(args: SelectSubset<T, ExperimentAuditLogUpsertArgs<ExtArgs>>): Prisma__ExperimentAuditLogClient<$Result.GetResult<Prisma.$ExperimentAuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExperimentAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentAuditLogCountArgs} args - Arguments to filter ExperimentAuditLogs to count.
     * @example
     * // Count the number of ExperimentAuditLogs
     * const count = await prisma.experimentAuditLog.count({
     *   where: {
     *     // ... the filter for the ExperimentAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends ExperimentAuditLogCountArgs>(
      args?: Subset<T, ExperimentAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperimentAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExperimentAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperimentAuditLogAggregateArgs>(args: Subset<T, ExperimentAuditLogAggregateArgs>): Prisma.PrismaPromise<GetExperimentAuditLogAggregateType<T>>

    /**
     * Group by ExperimentAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperimentAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExperimentAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExperimentAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: ExperimentAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExperimentAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperimentAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExperimentAuditLog model
   */
  readonly fields: ExperimentAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExperimentAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExperimentAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiment<T extends ExperimentAuditLog$experimentArgs<ExtArgs> = {}>(args?: Subset<T, ExperimentAuditLog$experimentArgs<ExtArgs>>): Prisma__ExperimentClient<$Result.GetResult<Prisma.$ExperimentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExperimentAuditLog model
   */ 
  interface ExperimentAuditLogFieldRefs {
    readonly id: FieldRef<"ExperimentAuditLog", 'String'>
    readonly experimentId: FieldRef<"ExperimentAuditLog", 'String'>
    readonly entityType: FieldRef<"ExperimentAuditLog", 'String'>
    readonly entityId: FieldRef<"ExperimentAuditLog", 'String'>
    readonly action: FieldRef<"ExperimentAuditLog", 'String'>
    readonly oldValues: FieldRef<"ExperimentAuditLog", 'Json'>
    readonly newValues: FieldRef<"ExperimentAuditLog", 'Json'>
    readonly changedBy: FieldRef<"ExperimentAuditLog", 'String'>
    readonly changedAt: FieldRef<"ExperimentAuditLog", 'DateTime'>
    readonly ipAddress: FieldRef<"ExperimentAuditLog", 'String'>
    readonly userAgent: FieldRef<"ExperimentAuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExperimentAuditLog findUnique
   */
  export type ExperimentAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentAuditLog to fetch.
     */
    where: ExperimentAuditLogWhereUniqueInput
  }

  /**
   * ExperimentAuditLog findUniqueOrThrow
   */
  export type ExperimentAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentAuditLog to fetch.
     */
    where: ExperimentAuditLogWhereUniqueInput
  }

  /**
   * ExperimentAuditLog findFirst
   */
  export type ExperimentAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentAuditLog to fetch.
     */
    where?: ExperimentAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperimentAuditLogs to fetch.
     */
    orderBy?: ExperimentAuditLogOrderByWithRelationInput | ExperimentAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperimentAuditLogs.
     */
    cursor?: ExperimentAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperimentAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperimentAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperimentAuditLogs.
     */
    distinct?: ExperimentAuditLogScalarFieldEnum | ExperimentAuditLogScalarFieldEnum[]
  }

  /**
   * ExperimentAuditLog findFirstOrThrow
   */
  export type ExperimentAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentAuditLog to fetch.
     */
    where?: ExperimentAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperimentAuditLogs to fetch.
     */
    orderBy?: ExperimentAuditLogOrderByWithRelationInput | ExperimentAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExperimentAuditLogs.
     */
    cursor?: ExperimentAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperimentAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperimentAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExperimentAuditLogs.
     */
    distinct?: ExperimentAuditLogScalarFieldEnum | ExperimentAuditLogScalarFieldEnum[]
  }

  /**
   * ExperimentAuditLog findMany
   */
  export type ExperimentAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ExperimentAuditLogs to fetch.
     */
    where?: ExperimentAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExperimentAuditLogs to fetch.
     */
    orderBy?: ExperimentAuditLogOrderByWithRelationInput | ExperimentAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExperimentAuditLogs.
     */
    cursor?: ExperimentAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExperimentAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExperimentAuditLogs.
     */
    skip?: number
    distinct?: ExperimentAuditLogScalarFieldEnum | ExperimentAuditLogScalarFieldEnum[]
  }

  /**
   * ExperimentAuditLog create
   */
  export type ExperimentAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ExperimentAuditLog.
     */
    data: XOR<ExperimentAuditLogCreateInput, ExperimentAuditLogUncheckedCreateInput>
  }

  /**
   * ExperimentAuditLog createMany
   */
  export type ExperimentAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExperimentAuditLogs.
     */
    data: ExperimentAuditLogCreateManyInput | ExperimentAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExperimentAuditLog createManyAndReturn
   */
  export type ExperimentAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExperimentAuditLogs.
     */
    data: ExperimentAuditLogCreateManyInput | ExperimentAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExperimentAuditLog update
   */
  export type ExperimentAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ExperimentAuditLog.
     */
    data: XOR<ExperimentAuditLogUpdateInput, ExperimentAuditLogUncheckedUpdateInput>
    /**
     * Choose, which ExperimentAuditLog to update.
     */
    where: ExperimentAuditLogWhereUniqueInput
  }

  /**
   * ExperimentAuditLog updateMany
   */
  export type ExperimentAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExperimentAuditLogs.
     */
    data: XOR<ExperimentAuditLogUpdateManyMutationInput, ExperimentAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which ExperimentAuditLogs to update
     */
    where?: ExperimentAuditLogWhereInput
  }

  /**
   * ExperimentAuditLog upsert
   */
  export type ExperimentAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ExperimentAuditLog to update in case it exists.
     */
    where: ExperimentAuditLogWhereUniqueInput
    /**
     * In case the ExperimentAuditLog found by the `where` argument doesn't exist, create a new ExperimentAuditLog with this data.
     */
    create: XOR<ExperimentAuditLogCreateInput, ExperimentAuditLogUncheckedCreateInput>
    /**
     * In case the ExperimentAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExperimentAuditLogUpdateInput, ExperimentAuditLogUncheckedUpdateInput>
  }

  /**
   * ExperimentAuditLog delete
   */
  export type ExperimentAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
    /**
     * Filter which ExperimentAuditLog to delete.
     */
    where: ExperimentAuditLogWhereUniqueInput
  }

  /**
   * ExperimentAuditLog deleteMany
   */
  export type ExperimentAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExperimentAuditLogs to delete
     */
    where?: ExperimentAuditLogWhereInput
  }

  /**
   * ExperimentAuditLog.experiment
   */
  export type ExperimentAuditLog$experimentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experiment
     */
    select?: ExperimentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentInclude<ExtArgs> | null
    where?: ExperimentWhereInput
  }

  /**
   * ExperimentAuditLog without action
   */
  export type ExperimentAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperimentAuditLog
     */
    select?: ExperimentAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperimentAuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const GermplasmScalarFieldEnum: {
    id: 'id',
    accessionNumber: 'accessionNumber',
    commonName: 'commonName',
    commonNameAr: 'commonNameAr',
    scientificName: 'scientificName',
    genus: 'genus',
    species: 'species',
    subspecies: 'subspecies',
    cultivar: 'cultivar',
    variety: 'variety',
    pedigree: 'pedigree',
    type: 'type',
    countryOfOrigin: 'countryOfOrigin',
    regionOfOrigin: 'regionOfOrigin',
    collectionSite: 'collectionSite',
    collectionDate: 'collectionDate',
    collectedBy: 'collectedBy',
    donorInstitution: 'donorInstitution',
    donorAccessionNumber: 'donorAccessionNumber',
    growthHabit: 'growthHabit',
    maturityDays: 'maturityDays',
    yieldPotential: 'yieldPotential',
    droughtTolerance: 'droughtTolerance',
    diseaseResistance: 'diseaseResistance',
    pestResistance: 'pestResistance',
    qualityTraits: 'qualityTraits',
    storageLocation: 'storageLocation',
    storageConditions: 'storageConditions',
    storageTemperature: 'storageTemperature',
    storageHumidity: 'storageHumidity',
    isAvailable: 'isAvailable',
    quantityAvailable: 'quantityAvailable',
    quantityUnit: 'quantityUnit',
    description: 'description',
    descriptionAr: 'descriptionAr',
    photos: 'photos',
    documents: 'documents',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GermplasmScalarFieldEnum = (typeof GermplasmScalarFieldEnum)[keyof typeof GermplasmScalarFieldEnum]


  export const SeedLotScalarFieldEnum: {
    id: 'id',
    germplasmId: 'germplasmId',
    lotNumber: 'lotNumber',
    initialQuantity: 'initialQuantity',
    currentQuantity: 'currentQuantity',
    quantityUnit: 'quantityUnit',
    seedCount: 'seedCount',
    thousandSeedWeight: 'thousandSeedWeight',
    qualityGrade: 'qualityGrade',
    germinationRate: 'germinationRate',
    germinationTestDate: 'germinationTestDate',
    purityPercentage: 'purityPercentage',
    moistureContent: 'moistureContent',
    vigorIndex: 'vigorIndex',
    productionDate: 'productionDate',
    harvestDate: 'harvestDate',
    productionLocation: 'productionLocation',
    productionSeason: 'productionSeason',
    producedBy: 'producedBy',
    certificationNumber: 'certificationNumber',
    certifiedBy: 'certifiedBy',
    certificationDate: 'certificationDate',
    expiryDate: 'expiryDate',
    isTreated: 'isTreated',
    treatmentType: 'treatmentType',
    treatmentProduct: 'treatmentProduct',
    treatmentDate: 'treatmentDate',
    storageLocation: 'storageLocation',
    storageConditions: 'storageConditions',
    notes: 'notes',
    notesAr: 'notesAr',
    photos: 'photos',
    documents: 'documents',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeedLotScalarFieldEnum = (typeof SeedLotScalarFieldEnum)[keyof typeof SeedLotScalarFieldEnum]


  export const PlantingScalarFieldEnum: {
    id: 'id',
    experimentId: 'experimentId',
    plotId: 'plotId',
    germplasmId: 'germplasmId',
    seedLotId: 'seedLotId',
    plantingDate: 'plantingDate',
    plantingMethod: 'plantingMethod',
    seedingRate: 'seedingRate',
    seedingRateUnit: 'seedingRateUnit',
    seedsPerHill: 'seedsPerHill',
    seedDepth: 'seedDepth',
    seedDepthUnit: 'seedDepthUnit',
    rowSpacing: 'rowSpacing',
    plantSpacing: 'plantSpacing',
    spacingUnit: 'spacingUnit',
    plantedArea: 'plantedArea',
    plantedAreaUnit: 'plantedAreaUnit',
    numberOfRows: 'numberOfRows',
    plantsPerRow: 'plantsPerRow',
    totalPlantsExpected: 'totalPlantsExpected',
    germinationDate: 'germinationDate',
    emergenceDate: 'emergenceDate',
    germinationCount: 'germinationCount',
    germinationPercentage: 'germinationPercentage',
    thinningDate: 'thinningDate',
    finalPlantCount: 'finalPlantCount',
    plantedBy: 'plantedBy',
    notes: 'notes',
    notesAr: 'notesAr',
    photos: 'photos',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlantingScalarFieldEnum = (typeof PlantingScalarFieldEnum)[keyof typeof PlantingScalarFieldEnum]


  export const ExperimentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    titleAr: 'titleAr',
    description: 'description',
    descriptionAr: 'descriptionAr',
    hypothesis: 'hypothesis',
    hypothesisAr: 'hypothesisAr',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    lockedAt: 'lockedAt',
    lockedBy: 'lockedBy',
    principalResearcherId: 'principalResearcherId',
    organizationId: 'organizationId',
    farmId: 'farmId',
    metadata: 'metadata',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    version: 'version'
  };

  export type ExperimentScalarFieldEnum = (typeof ExperimentScalarFieldEnum)[keyof typeof ExperimentScalarFieldEnum]


  export const ResearchProtocolScalarFieldEnum: {
    id: 'id',
    experimentId: 'experimentId',
    name: 'name',
    nameAr: 'nameAr',
    description: 'description',
    descriptionAr: 'descriptionAr',
    methodology: 'methodology',
    methodologyAr: 'methodologyAr',
    variables: 'variables',
    measurementSchedule: 'measurementSchedule',
    equipmentRequired: 'equipmentRequired',
    safetyGuidelines: 'safetyGuidelines',
    version: 'version',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResearchProtocolScalarFieldEnum = (typeof ResearchProtocolScalarFieldEnum)[keyof typeof ResearchProtocolScalarFieldEnum]


  export const ResearchPlotScalarFieldEnum: {
    id: 'id',
    experimentId: 'experimentId',
    plotCode: 'plotCode',
    name: 'name',
    nameAr: 'nameAr',
    areaSqm: 'areaSqm',
    soilType: 'soilType',
    soilPh: 'soilPh',
    previousCrop: 'previousCrop',
    replicateNumber: 'replicateNumber',
    blockNumber: 'blockNumber',
    rowNumber: 'rowNumber',
    columnNumber: 'columnNumber',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResearchPlotScalarFieldEnum = (typeof ResearchPlotScalarFieldEnum)[keyof typeof ResearchPlotScalarFieldEnum]


  export const TreatmentScalarFieldEnum: {
    id: 'id',
    experimentId: 'experimentId',
    plotId: 'plotId',
    treatmentCode: 'treatmentCode',
    name: 'name',
    nameAr: 'nameAr',
    type: 'type',
    description: 'description',
    descriptionAr: 'descriptionAr',
    dosage: 'dosage',
    dosageUnit: 'dosageUnit',
    applicationMethod: 'applicationMethod',
    applicationFrequency: 'applicationFrequency',
    startDate: 'startDate',
    endDate: 'endDate',
    isControl: 'isControl',
    parameters: 'parameters',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TreatmentScalarFieldEnum = (typeof TreatmentScalarFieldEnum)[keyof typeof TreatmentScalarFieldEnum]


  export const ResearchDailyLogScalarFieldEnum: {
    id: 'id',
    experimentId: 'experimentId',
    plotId: 'plotId',
    treatmentId: 'treatmentId',
    logDate: 'logDate',
    logTime: 'logTime',
    category: 'category',
    title: 'title',
    titleAr: 'titleAr',
    notes: 'notes',
    notesAr: 'notesAr',
    measurements: 'measurements',
    weatherConditions: 'weatherConditions',
    photos: 'photos',
    attachments: 'attachments',
    recordedBy: 'recordedBy',
    deviceId: 'deviceId',
    offlineId: 'offlineId',
    hash: 'hash',
    syncedAt: 'syncedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResearchDailyLogScalarFieldEnum = (typeof ResearchDailyLogScalarFieldEnum)[keyof typeof ResearchDailyLogScalarFieldEnum]


  export const LabSampleScalarFieldEnum: {
    id: 'id',
    experimentId: 'experimentId',
    plotId: 'plotId',
    logId: 'logId',
    sampleCode: 'sampleCode',
    type: 'type',
    description: 'description',
    descriptionAr: 'descriptionAr',
    collectionDate: 'collectionDate',
    collectionTime: 'collectionTime',
    collectedBy: 'collectedBy',
    storageLocation: 'storageLocation',
    storageConditions: 'storageConditions',
    quantity: 'quantity',
    quantityUnit: 'quantityUnit',
    analysisStatus: 'analysisStatus',
    analysisResults: 'analysisResults',
    analyzedBy: 'analyzedBy',
    analyzedAt: 'analyzedAt',
    photos: 'photos',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LabSampleScalarFieldEnum = (typeof LabSampleScalarFieldEnum)[keyof typeof LabSampleScalarFieldEnum]


  export const DigitalSignatureScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    signerId: 'signerId',
    signatureHash: 'signatureHash',
    algorithm: 'algorithm',
    payloadHash: 'payloadHash',
    timestamp: 'timestamp',
    ipAddress: 'ipAddress',
    deviceInfo: 'deviceInfo',
    purpose: 'purpose',
    isValid: 'isValid',
    invalidatedAt: 'invalidatedAt',
    invalidatedReason: 'invalidatedReason',
    createdAt: 'createdAt'
  };

  export type DigitalSignatureScalarFieldEnum = (typeof DigitalSignatureScalarFieldEnum)[keyof typeof DigitalSignatureScalarFieldEnum]


  export const ExperimentCollaboratorScalarFieldEnum: {
    id: 'id',
    experimentId: 'experimentId',
    userId: 'userId',
    role: 'role',
    permissions: 'permissions',
    invitedBy: 'invitedBy',
    acceptedAt: 'acceptedAt',
    createdAt: 'createdAt'
  };

  export type ExperimentCollaboratorScalarFieldEnum = (typeof ExperimentCollaboratorScalarFieldEnum)[keyof typeof ExperimentCollaboratorScalarFieldEnum]


  export const ExperimentAuditLogScalarFieldEnum: {
    id: 'id',
    experimentId: 'experimentId',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    oldValues: 'oldValues',
    newValues: 'newValues',
    changedBy: 'changedBy',
    changedAt: 'changedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type ExperimentAuditLogScalarFieldEnum = (typeof ExperimentAuditLogScalarFieldEnum)[keyof typeof ExperimentAuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'GermplasmType'
   */
  export type EnumGermplasmTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GermplasmType'>
    


  /**
   * Reference to a field of type 'GermplasmType[]'
   */
  export type ListEnumGermplasmTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GermplasmType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SeedQualityGrade'
   */
  export type EnumSeedQualityGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeedQualityGrade'>
    


  /**
   * Reference to a field of type 'SeedQualityGrade[]'
   */
  export type ListEnumSeedQualityGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeedQualityGrade[]'>
    


  /**
   * Reference to a field of type 'ExperimentStatus'
   */
  export type EnumExperimentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExperimentStatus'>
    


  /**
   * Reference to a field of type 'ExperimentStatus[]'
   */
  export type ListEnumExperimentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExperimentStatus[]'>
    


  /**
   * Reference to a field of type 'TreatmentType'
   */
  export type EnumTreatmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreatmentType'>
    


  /**
   * Reference to a field of type 'TreatmentType[]'
   */
  export type ListEnumTreatmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TreatmentType[]'>
    


  /**
   * Reference to a field of type 'LogCategory'
   */
  export type EnumLogCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogCategory'>
    


  /**
   * Reference to a field of type 'LogCategory[]'
   */
  export type ListEnumLogCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogCategory[]'>
    


  /**
   * Reference to a field of type 'SampleType'
   */
  export type EnumSampleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleType'>
    


  /**
   * Reference to a field of type 'SampleType[]'
   */
  export type ListEnumSampleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type GermplasmWhereInput = {
    AND?: GermplasmWhereInput | GermplasmWhereInput[]
    OR?: GermplasmWhereInput[]
    NOT?: GermplasmWhereInput | GermplasmWhereInput[]
    id?: StringFilter<"Germplasm"> | string
    accessionNumber?: StringFilter<"Germplasm"> | string
    commonName?: StringFilter<"Germplasm"> | string
    commonNameAr?: StringNullableFilter<"Germplasm"> | string | null
    scientificName?: StringNullableFilter<"Germplasm"> | string | null
    genus?: StringNullableFilter<"Germplasm"> | string | null
    species?: StringNullableFilter<"Germplasm"> | string | null
    subspecies?: StringNullableFilter<"Germplasm"> | string | null
    cultivar?: StringNullableFilter<"Germplasm"> | string | null
    variety?: StringNullableFilter<"Germplasm"> | string | null
    pedigree?: StringNullableFilter<"Germplasm"> | string | null
    type?: EnumGermplasmTypeFilter<"Germplasm"> | $Enums.GermplasmType
    countryOfOrigin?: StringNullableFilter<"Germplasm"> | string | null
    regionOfOrigin?: StringNullableFilter<"Germplasm"> | string | null
    collectionSite?: StringNullableFilter<"Germplasm"> | string | null
    collectionDate?: DateTimeNullableFilter<"Germplasm"> | Date | string | null
    collectedBy?: StringNullableFilter<"Germplasm"> | string | null
    donorInstitution?: StringNullableFilter<"Germplasm"> | string | null
    donorAccessionNumber?: StringNullableFilter<"Germplasm"> | string | null
    growthHabit?: StringNullableFilter<"Germplasm"> | string | null
    maturityDays?: IntNullableFilter<"Germplasm"> | number | null
    yieldPotential?: StringNullableFilter<"Germplasm"> | string | null
    droughtTolerance?: StringNullableFilter<"Germplasm"> | string | null
    diseaseResistance?: JsonFilter<"Germplasm">
    pestResistance?: JsonFilter<"Germplasm">
    qualityTraits?: JsonFilter<"Germplasm">
    storageLocation?: StringNullableFilter<"Germplasm"> | string | null
    storageConditions?: StringNullableFilter<"Germplasm"> | string | null
    storageTemperature?: DecimalNullableFilter<"Germplasm"> | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: DecimalNullableFilter<"Germplasm"> | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFilter<"Germplasm"> | boolean
    quantityAvailable?: DecimalNullableFilter<"Germplasm"> | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: StringNullableFilter<"Germplasm"> | string | null
    description?: StringNullableFilter<"Germplasm"> | string | null
    descriptionAr?: StringNullableFilter<"Germplasm"> | string | null
    photos?: StringNullableListFilter<"Germplasm">
    documents?: StringNullableListFilter<"Germplasm">
    metadata?: JsonFilter<"Germplasm">
    createdAt?: DateTimeFilter<"Germplasm"> | Date | string
    updatedAt?: DateTimeFilter<"Germplasm"> | Date | string
    seedLots?: SeedLotListRelationFilter
    plantings?: PlantingListRelationFilter
  }

  export type GermplasmOrderByWithRelationInput = {
    id?: SortOrder
    accessionNumber?: SortOrder
    commonName?: SortOrder
    commonNameAr?: SortOrderInput | SortOrder
    scientificName?: SortOrderInput | SortOrder
    genus?: SortOrderInput | SortOrder
    species?: SortOrderInput | SortOrder
    subspecies?: SortOrderInput | SortOrder
    cultivar?: SortOrderInput | SortOrder
    variety?: SortOrderInput | SortOrder
    pedigree?: SortOrderInput | SortOrder
    type?: SortOrder
    countryOfOrigin?: SortOrderInput | SortOrder
    regionOfOrigin?: SortOrderInput | SortOrder
    collectionSite?: SortOrderInput | SortOrder
    collectionDate?: SortOrderInput | SortOrder
    collectedBy?: SortOrderInput | SortOrder
    donorInstitution?: SortOrderInput | SortOrder
    donorAccessionNumber?: SortOrderInput | SortOrder
    growthHabit?: SortOrderInput | SortOrder
    maturityDays?: SortOrderInput | SortOrder
    yieldPotential?: SortOrderInput | SortOrder
    droughtTolerance?: SortOrderInput | SortOrder
    diseaseResistance?: SortOrder
    pestResistance?: SortOrder
    qualityTraits?: SortOrder
    storageLocation?: SortOrderInput | SortOrder
    storageConditions?: SortOrderInput | SortOrder
    storageTemperature?: SortOrderInput | SortOrder
    storageHumidity?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    quantityAvailable?: SortOrderInput | SortOrder
    quantityUnit?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    photos?: SortOrder
    documents?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seedLots?: SeedLotOrderByRelationAggregateInput
    plantings?: PlantingOrderByRelationAggregateInput
  }

  export type GermplasmWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accessionNumber?: string
    AND?: GermplasmWhereInput | GermplasmWhereInput[]
    OR?: GermplasmWhereInput[]
    NOT?: GermplasmWhereInput | GermplasmWhereInput[]
    commonName?: StringFilter<"Germplasm"> | string
    commonNameAr?: StringNullableFilter<"Germplasm"> | string | null
    scientificName?: StringNullableFilter<"Germplasm"> | string | null
    genus?: StringNullableFilter<"Germplasm"> | string | null
    species?: StringNullableFilter<"Germplasm"> | string | null
    subspecies?: StringNullableFilter<"Germplasm"> | string | null
    cultivar?: StringNullableFilter<"Germplasm"> | string | null
    variety?: StringNullableFilter<"Germplasm"> | string | null
    pedigree?: StringNullableFilter<"Germplasm"> | string | null
    type?: EnumGermplasmTypeFilter<"Germplasm"> | $Enums.GermplasmType
    countryOfOrigin?: StringNullableFilter<"Germplasm"> | string | null
    regionOfOrigin?: StringNullableFilter<"Germplasm"> | string | null
    collectionSite?: StringNullableFilter<"Germplasm"> | string | null
    collectionDate?: DateTimeNullableFilter<"Germplasm"> | Date | string | null
    collectedBy?: StringNullableFilter<"Germplasm"> | string | null
    donorInstitution?: StringNullableFilter<"Germplasm"> | string | null
    donorAccessionNumber?: StringNullableFilter<"Germplasm"> | string | null
    growthHabit?: StringNullableFilter<"Germplasm"> | string | null
    maturityDays?: IntNullableFilter<"Germplasm"> | number | null
    yieldPotential?: StringNullableFilter<"Germplasm"> | string | null
    droughtTolerance?: StringNullableFilter<"Germplasm"> | string | null
    diseaseResistance?: JsonFilter<"Germplasm">
    pestResistance?: JsonFilter<"Germplasm">
    qualityTraits?: JsonFilter<"Germplasm">
    storageLocation?: StringNullableFilter<"Germplasm"> | string | null
    storageConditions?: StringNullableFilter<"Germplasm"> | string | null
    storageTemperature?: DecimalNullableFilter<"Germplasm"> | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: DecimalNullableFilter<"Germplasm"> | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFilter<"Germplasm"> | boolean
    quantityAvailable?: DecimalNullableFilter<"Germplasm"> | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: StringNullableFilter<"Germplasm"> | string | null
    description?: StringNullableFilter<"Germplasm"> | string | null
    descriptionAr?: StringNullableFilter<"Germplasm"> | string | null
    photos?: StringNullableListFilter<"Germplasm">
    documents?: StringNullableListFilter<"Germplasm">
    metadata?: JsonFilter<"Germplasm">
    createdAt?: DateTimeFilter<"Germplasm"> | Date | string
    updatedAt?: DateTimeFilter<"Germplasm"> | Date | string
    seedLots?: SeedLotListRelationFilter
    plantings?: PlantingListRelationFilter
  }, "id" | "accessionNumber">

  export type GermplasmOrderByWithAggregationInput = {
    id?: SortOrder
    accessionNumber?: SortOrder
    commonName?: SortOrder
    commonNameAr?: SortOrderInput | SortOrder
    scientificName?: SortOrderInput | SortOrder
    genus?: SortOrderInput | SortOrder
    species?: SortOrderInput | SortOrder
    subspecies?: SortOrderInput | SortOrder
    cultivar?: SortOrderInput | SortOrder
    variety?: SortOrderInput | SortOrder
    pedigree?: SortOrderInput | SortOrder
    type?: SortOrder
    countryOfOrigin?: SortOrderInput | SortOrder
    regionOfOrigin?: SortOrderInput | SortOrder
    collectionSite?: SortOrderInput | SortOrder
    collectionDate?: SortOrderInput | SortOrder
    collectedBy?: SortOrderInput | SortOrder
    donorInstitution?: SortOrderInput | SortOrder
    donorAccessionNumber?: SortOrderInput | SortOrder
    growthHabit?: SortOrderInput | SortOrder
    maturityDays?: SortOrderInput | SortOrder
    yieldPotential?: SortOrderInput | SortOrder
    droughtTolerance?: SortOrderInput | SortOrder
    diseaseResistance?: SortOrder
    pestResistance?: SortOrder
    qualityTraits?: SortOrder
    storageLocation?: SortOrderInput | SortOrder
    storageConditions?: SortOrderInput | SortOrder
    storageTemperature?: SortOrderInput | SortOrder
    storageHumidity?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    quantityAvailable?: SortOrderInput | SortOrder
    quantityUnit?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    photos?: SortOrder
    documents?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GermplasmCountOrderByAggregateInput
    _avg?: GermplasmAvgOrderByAggregateInput
    _max?: GermplasmMaxOrderByAggregateInput
    _min?: GermplasmMinOrderByAggregateInput
    _sum?: GermplasmSumOrderByAggregateInput
  }

  export type GermplasmScalarWhereWithAggregatesInput = {
    AND?: GermplasmScalarWhereWithAggregatesInput | GermplasmScalarWhereWithAggregatesInput[]
    OR?: GermplasmScalarWhereWithAggregatesInput[]
    NOT?: GermplasmScalarWhereWithAggregatesInput | GermplasmScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Germplasm"> | string
    accessionNumber?: StringWithAggregatesFilter<"Germplasm"> | string
    commonName?: StringWithAggregatesFilter<"Germplasm"> | string
    commonNameAr?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    scientificName?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    genus?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    species?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    subspecies?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    cultivar?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    variety?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    pedigree?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    type?: EnumGermplasmTypeWithAggregatesFilter<"Germplasm"> | $Enums.GermplasmType
    countryOfOrigin?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    regionOfOrigin?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    collectionSite?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    collectionDate?: DateTimeNullableWithAggregatesFilter<"Germplasm"> | Date | string | null
    collectedBy?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    donorInstitution?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    donorAccessionNumber?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    growthHabit?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    maturityDays?: IntNullableWithAggregatesFilter<"Germplasm"> | number | null
    yieldPotential?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    droughtTolerance?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    diseaseResistance?: JsonWithAggregatesFilter<"Germplasm">
    pestResistance?: JsonWithAggregatesFilter<"Germplasm">
    qualityTraits?: JsonWithAggregatesFilter<"Germplasm">
    storageLocation?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    storageConditions?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    storageTemperature?: DecimalNullableWithAggregatesFilter<"Germplasm"> | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: DecimalNullableWithAggregatesFilter<"Germplasm"> | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolWithAggregatesFilter<"Germplasm"> | boolean
    quantityAvailable?: DecimalNullableWithAggregatesFilter<"Germplasm"> | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    description?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    descriptionAr?: StringNullableWithAggregatesFilter<"Germplasm"> | string | null
    photos?: StringNullableListFilter<"Germplasm">
    documents?: StringNullableListFilter<"Germplasm">
    metadata?: JsonWithAggregatesFilter<"Germplasm">
    createdAt?: DateTimeWithAggregatesFilter<"Germplasm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Germplasm"> | Date | string
  }

  export type SeedLotWhereInput = {
    AND?: SeedLotWhereInput | SeedLotWhereInput[]
    OR?: SeedLotWhereInput[]
    NOT?: SeedLotWhereInput | SeedLotWhereInput[]
    id?: StringFilter<"SeedLot"> | string
    germplasmId?: StringFilter<"SeedLot"> | string
    lotNumber?: StringFilter<"SeedLot"> | string
    initialQuantity?: DecimalFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFilter<"SeedLot"> | string
    seedCount?: IntNullableFilter<"SeedLot"> | number | null
    thousandSeedWeight?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFilter<"SeedLot"> | $Enums.SeedQualityGrade
    germinationRate?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    purityPercentage?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    moistureContent?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    productionDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    harvestDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    productionLocation?: StringNullableFilter<"SeedLot"> | string | null
    productionSeason?: StringNullableFilter<"SeedLot"> | string | null
    producedBy?: StringNullableFilter<"SeedLot"> | string | null
    certificationNumber?: StringNullableFilter<"SeedLot"> | string | null
    certifiedBy?: StringNullableFilter<"SeedLot"> | string | null
    certificationDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    isTreated?: BoolFilter<"SeedLot"> | boolean
    treatmentType?: StringNullableFilter<"SeedLot"> | string | null
    treatmentProduct?: StringNullableFilter<"SeedLot"> | string | null
    treatmentDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    storageLocation?: StringNullableFilter<"SeedLot"> | string | null
    storageConditions?: StringNullableFilter<"SeedLot"> | string | null
    notes?: StringNullableFilter<"SeedLot"> | string | null
    notesAr?: StringNullableFilter<"SeedLot"> | string | null
    photos?: StringNullableListFilter<"SeedLot">
    documents?: StringNullableListFilter<"SeedLot">
    metadata?: JsonFilter<"SeedLot">
    createdAt?: DateTimeFilter<"SeedLot"> | Date | string
    updatedAt?: DateTimeFilter<"SeedLot"> | Date | string
    germplasm?: XOR<GermplasmRelationFilter, GermplasmWhereInput>
    plantings?: PlantingListRelationFilter
  }

  export type SeedLotOrderByWithRelationInput = {
    id?: SortOrder
    germplasmId?: SortOrder
    lotNumber?: SortOrder
    initialQuantity?: SortOrder
    currentQuantity?: SortOrder
    quantityUnit?: SortOrder
    seedCount?: SortOrderInput | SortOrder
    thousandSeedWeight?: SortOrderInput | SortOrder
    qualityGrade?: SortOrder
    germinationRate?: SortOrderInput | SortOrder
    germinationTestDate?: SortOrderInput | SortOrder
    purityPercentage?: SortOrderInput | SortOrder
    moistureContent?: SortOrderInput | SortOrder
    vigorIndex?: SortOrderInput | SortOrder
    productionDate?: SortOrderInput | SortOrder
    harvestDate?: SortOrderInput | SortOrder
    productionLocation?: SortOrderInput | SortOrder
    productionSeason?: SortOrderInput | SortOrder
    producedBy?: SortOrderInput | SortOrder
    certificationNumber?: SortOrderInput | SortOrder
    certifiedBy?: SortOrderInput | SortOrder
    certificationDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    isTreated?: SortOrder
    treatmentType?: SortOrderInput | SortOrder
    treatmentProduct?: SortOrderInput | SortOrder
    treatmentDate?: SortOrderInput | SortOrder
    storageLocation?: SortOrderInput | SortOrder
    storageConditions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    notesAr?: SortOrderInput | SortOrder
    photos?: SortOrder
    documents?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    germplasm?: GermplasmOrderByWithRelationInput
    plantings?: PlantingOrderByRelationAggregateInput
  }

  export type SeedLotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lotNumber?: string
    AND?: SeedLotWhereInput | SeedLotWhereInput[]
    OR?: SeedLotWhereInput[]
    NOT?: SeedLotWhereInput | SeedLotWhereInput[]
    germplasmId?: StringFilter<"SeedLot"> | string
    initialQuantity?: DecimalFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFilter<"SeedLot"> | string
    seedCount?: IntNullableFilter<"SeedLot"> | number | null
    thousandSeedWeight?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFilter<"SeedLot"> | $Enums.SeedQualityGrade
    germinationRate?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    purityPercentage?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    moistureContent?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    productionDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    harvestDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    productionLocation?: StringNullableFilter<"SeedLot"> | string | null
    productionSeason?: StringNullableFilter<"SeedLot"> | string | null
    producedBy?: StringNullableFilter<"SeedLot"> | string | null
    certificationNumber?: StringNullableFilter<"SeedLot"> | string | null
    certifiedBy?: StringNullableFilter<"SeedLot"> | string | null
    certificationDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    isTreated?: BoolFilter<"SeedLot"> | boolean
    treatmentType?: StringNullableFilter<"SeedLot"> | string | null
    treatmentProduct?: StringNullableFilter<"SeedLot"> | string | null
    treatmentDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    storageLocation?: StringNullableFilter<"SeedLot"> | string | null
    storageConditions?: StringNullableFilter<"SeedLot"> | string | null
    notes?: StringNullableFilter<"SeedLot"> | string | null
    notesAr?: StringNullableFilter<"SeedLot"> | string | null
    photos?: StringNullableListFilter<"SeedLot">
    documents?: StringNullableListFilter<"SeedLot">
    metadata?: JsonFilter<"SeedLot">
    createdAt?: DateTimeFilter<"SeedLot"> | Date | string
    updatedAt?: DateTimeFilter<"SeedLot"> | Date | string
    germplasm?: XOR<GermplasmRelationFilter, GermplasmWhereInput>
    plantings?: PlantingListRelationFilter
  }, "id" | "lotNumber">

  export type SeedLotOrderByWithAggregationInput = {
    id?: SortOrder
    germplasmId?: SortOrder
    lotNumber?: SortOrder
    initialQuantity?: SortOrder
    currentQuantity?: SortOrder
    quantityUnit?: SortOrder
    seedCount?: SortOrderInput | SortOrder
    thousandSeedWeight?: SortOrderInput | SortOrder
    qualityGrade?: SortOrder
    germinationRate?: SortOrderInput | SortOrder
    germinationTestDate?: SortOrderInput | SortOrder
    purityPercentage?: SortOrderInput | SortOrder
    moistureContent?: SortOrderInput | SortOrder
    vigorIndex?: SortOrderInput | SortOrder
    productionDate?: SortOrderInput | SortOrder
    harvestDate?: SortOrderInput | SortOrder
    productionLocation?: SortOrderInput | SortOrder
    productionSeason?: SortOrderInput | SortOrder
    producedBy?: SortOrderInput | SortOrder
    certificationNumber?: SortOrderInput | SortOrder
    certifiedBy?: SortOrderInput | SortOrder
    certificationDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    isTreated?: SortOrder
    treatmentType?: SortOrderInput | SortOrder
    treatmentProduct?: SortOrderInput | SortOrder
    treatmentDate?: SortOrderInput | SortOrder
    storageLocation?: SortOrderInput | SortOrder
    storageConditions?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    notesAr?: SortOrderInput | SortOrder
    photos?: SortOrder
    documents?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeedLotCountOrderByAggregateInput
    _avg?: SeedLotAvgOrderByAggregateInput
    _max?: SeedLotMaxOrderByAggregateInput
    _min?: SeedLotMinOrderByAggregateInput
    _sum?: SeedLotSumOrderByAggregateInput
  }

  export type SeedLotScalarWhereWithAggregatesInput = {
    AND?: SeedLotScalarWhereWithAggregatesInput | SeedLotScalarWhereWithAggregatesInput[]
    OR?: SeedLotScalarWhereWithAggregatesInput[]
    NOT?: SeedLotScalarWhereWithAggregatesInput | SeedLotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SeedLot"> | string
    germplasmId?: StringWithAggregatesFilter<"SeedLot"> | string
    lotNumber?: StringWithAggregatesFilter<"SeedLot"> | string
    initialQuantity?: DecimalWithAggregatesFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalWithAggregatesFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringWithAggregatesFilter<"SeedLot"> | string
    seedCount?: IntNullableWithAggregatesFilter<"SeedLot"> | number | null
    thousandSeedWeight?: DecimalNullableWithAggregatesFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeWithAggregatesFilter<"SeedLot"> | $Enums.SeedQualityGrade
    germinationRate?: DecimalNullableWithAggregatesFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: DateTimeNullableWithAggregatesFilter<"SeedLot"> | Date | string | null
    purityPercentage?: DecimalNullableWithAggregatesFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    moistureContent?: DecimalNullableWithAggregatesFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: DecimalNullableWithAggregatesFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    productionDate?: DateTimeNullableWithAggregatesFilter<"SeedLot"> | Date | string | null
    harvestDate?: DateTimeNullableWithAggregatesFilter<"SeedLot"> | Date | string | null
    productionLocation?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    productionSeason?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    producedBy?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    certificationNumber?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    certifiedBy?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    certificationDate?: DateTimeNullableWithAggregatesFilter<"SeedLot"> | Date | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"SeedLot"> | Date | string | null
    isTreated?: BoolWithAggregatesFilter<"SeedLot"> | boolean
    treatmentType?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    treatmentProduct?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    treatmentDate?: DateTimeNullableWithAggregatesFilter<"SeedLot"> | Date | string | null
    storageLocation?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    storageConditions?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    notes?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    notesAr?: StringNullableWithAggregatesFilter<"SeedLot"> | string | null
    photos?: StringNullableListFilter<"SeedLot">
    documents?: StringNullableListFilter<"SeedLot">
    metadata?: JsonWithAggregatesFilter<"SeedLot">
    createdAt?: DateTimeWithAggregatesFilter<"SeedLot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SeedLot"> | Date | string
  }

  export type PlantingWhereInput = {
    AND?: PlantingWhereInput | PlantingWhereInput[]
    OR?: PlantingWhereInput[]
    NOT?: PlantingWhereInput | PlantingWhereInput[]
    id?: StringFilter<"Planting"> | string
    experimentId?: StringFilter<"Planting"> | string
    plotId?: StringNullableFilter<"Planting"> | string | null
    germplasmId?: StringFilter<"Planting"> | string
    seedLotId?: StringNullableFilter<"Planting"> | string | null
    plantingDate?: DateTimeFilter<"Planting"> | Date | string
    plantingMethod?: StringNullableFilter<"Planting"> | string | null
    seedingRate?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: StringNullableFilter<"Planting"> | string | null
    seedsPerHill?: IntNullableFilter<"Planting"> | number | null
    seedDepth?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: StringNullableFilter<"Planting"> | string | null
    rowSpacing?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: StringNullableFilter<"Planting"> | string | null
    plantedArea?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: StringNullableFilter<"Planting"> | string | null
    numberOfRows?: IntNullableFilter<"Planting"> | number | null
    plantsPerRow?: IntNullableFilter<"Planting"> | number | null
    totalPlantsExpected?: IntNullableFilter<"Planting"> | number | null
    germinationDate?: DateTimeNullableFilter<"Planting"> | Date | string | null
    emergenceDate?: DateTimeNullableFilter<"Planting"> | Date | string | null
    germinationCount?: IntNullableFilter<"Planting"> | number | null
    germinationPercentage?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    thinningDate?: DateTimeNullableFilter<"Planting"> | Date | string | null
    finalPlantCount?: IntNullableFilter<"Planting"> | number | null
    plantedBy?: StringFilter<"Planting"> | string
    notes?: StringNullableFilter<"Planting"> | string | null
    notesAr?: StringNullableFilter<"Planting"> | string | null
    photos?: StringNullableListFilter<"Planting">
    metadata?: JsonFilter<"Planting">
    createdAt?: DateTimeFilter<"Planting"> | Date | string
    updatedAt?: DateTimeFilter<"Planting"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    germplasm?: XOR<GermplasmRelationFilter, GermplasmWhereInput>
    seedLot?: XOR<SeedLotNullableRelationFilter, SeedLotWhereInput> | null
  }

  export type PlantingOrderByWithRelationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrderInput | SortOrder
    germplasmId?: SortOrder
    seedLotId?: SortOrderInput | SortOrder
    plantingDate?: SortOrder
    plantingMethod?: SortOrderInput | SortOrder
    seedingRate?: SortOrderInput | SortOrder
    seedingRateUnit?: SortOrderInput | SortOrder
    seedsPerHill?: SortOrderInput | SortOrder
    seedDepth?: SortOrderInput | SortOrder
    seedDepthUnit?: SortOrderInput | SortOrder
    rowSpacing?: SortOrderInput | SortOrder
    plantSpacing?: SortOrderInput | SortOrder
    spacingUnit?: SortOrderInput | SortOrder
    plantedArea?: SortOrderInput | SortOrder
    plantedAreaUnit?: SortOrderInput | SortOrder
    numberOfRows?: SortOrderInput | SortOrder
    plantsPerRow?: SortOrderInput | SortOrder
    totalPlantsExpected?: SortOrderInput | SortOrder
    germinationDate?: SortOrderInput | SortOrder
    emergenceDate?: SortOrderInput | SortOrder
    germinationCount?: SortOrderInput | SortOrder
    germinationPercentage?: SortOrderInput | SortOrder
    thinningDate?: SortOrderInput | SortOrder
    finalPlantCount?: SortOrderInput | SortOrder
    plantedBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    notesAr?: SortOrderInput | SortOrder
    photos?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    experiment?: ExperimentOrderByWithRelationInput
    germplasm?: GermplasmOrderByWithRelationInput
    seedLot?: SeedLotOrderByWithRelationInput
  }

  export type PlantingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlantingWhereInput | PlantingWhereInput[]
    OR?: PlantingWhereInput[]
    NOT?: PlantingWhereInput | PlantingWhereInput[]
    experimentId?: StringFilter<"Planting"> | string
    plotId?: StringNullableFilter<"Planting"> | string | null
    germplasmId?: StringFilter<"Planting"> | string
    seedLotId?: StringNullableFilter<"Planting"> | string | null
    plantingDate?: DateTimeFilter<"Planting"> | Date | string
    plantingMethod?: StringNullableFilter<"Planting"> | string | null
    seedingRate?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: StringNullableFilter<"Planting"> | string | null
    seedsPerHill?: IntNullableFilter<"Planting"> | number | null
    seedDepth?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: StringNullableFilter<"Planting"> | string | null
    rowSpacing?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: StringNullableFilter<"Planting"> | string | null
    plantedArea?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: StringNullableFilter<"Planting"> | string | null
    numberOfRows?: IntNullableFilter<"Planting"> | number | null
    plantsPerRow?: IntNullableFilter<"Planting"> | number | null
    totalPlantsExpected?: IntNullableFilter<"Planting"> | number | null
    germinationDate?: DateTimeNullableFilter<"Planting"> | Date | string | null
    emergenceDate?: DateTimeNullableFilter<"Planting"> | Date | string | null
    germinationCount?: IntNullableFilter<"Planting"> | number | null
    germinationPercentage?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    thinningDate?: DateTimeNullableFilter<"Planting"> | Date | string | null
    finalPlantCount?: IntNullableFilter<"Planting"> | number | null
    plantedBy?: StringFilter<"Planting"> | string
    notes?: StringNullableFilter<"Planting"> | string | null
    notesAr?: StringNullableFilter<"Planting"> | string | null
    photos?: StringNullableListFilter<"Planting">
    metadata?: JsonFilter<"Planting">
    createdAt?: DateTimeFilter<"Planting"> | Date | string
    updatedAt?: DateTimeFilter<"Planting"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    germplasm?: XOR<GermplasmRelationFilter, GermplasmWhereInput>
    seedLot?: XOR<SeedLotNullableRelationFilter, SeedLotWhereInput> | null
  }, "id">

  export type PlantingOrderByWithAggregationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrderInput | SortOrder
    germplasmId?: SortOrder
    seedLotId?: SortOrderInput | SortOrder
    plantingDate?: SortOrder
    plantingMethod?: SortOrderInput | SortOrder
    seedingRate?: SortOrderInput | SortOrder
    seedingRateUnit?: SortOrderInput | SortOrder
    seedsPerHill?: SortOrderInput | SortOrder
    seedDepth?: SortOrderInput | SortOrder
    seedDepthUnit?: SortOrderInput | SortOrder
    rowSpacing?: SortOrderInput | SortOrder
    plantSpacing?: SortOrderInput | SortOrder
    spacingUnit?: SortOrderInput | SortOrder
    plantedArea?: SortOrderInput | SortOrder
    plantedAreaUnit?: SortOrderInput | SortOrder
    numberOfRows?: SortOrderInput | SortOrder
    plantsPerRow?: SortOrderInput | SortOrder
    totalPlantsExpected?: SortOrderInput | SortOrder
    germinationDate?: SortOrderInput | SortOrder
    emergenceDate?: SortOrderInput | SortOrder
    germinationCount?: SortOrderInput | SortOrder
    germinationPercentage?: SortOrderInput | SortOrder
    thinningDate?: SortOrderInput | SortOrder
    finalPlantCount?: SortOrderInput | SortOrder
    plantedBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    notesAr?: SortOrderInput | SortOrder
    photos?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlantingCountOrderByAggregateInput
    _avg?: PlantingAvgOrderByAggregateInput
    _max?: PlantingMaxOrderByAggregateInput
    _min?: PlantingMinOrderByAggregateInput
    _sum?: PlantingSumOrderByAggregateInput
  }

  export type PlantingScalarWhereWithAggregatesInput = {
    AND?: PlantingScalarWhereWithAggregatesInput | PlantingScalarWhereWithAggregatesInput[]
    OR?: PlantingScalarWhereWithAggregatesInput[]
    NOT?: PlantingScalarWhereWithAggregatesInput | PlantingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Planting"> | string
    experimentId?: StringWithAggregatesFilter<"Planting"> | string
    plotId?: StringNullableWithAggregatesFilter<"Planting"> | string | null
    germplasmId?: StringWithAggregatesFilter<"Planting"> | string
    seedLotId?: StringNullableWithAggregatesFilter<"Planting"> | string | null
    plantingDate?: DateTimeWithAggregatesFilter<"Planting"> | Date | string
    plantingMethod?: StringNullableWithAggregatesFilter<"Planting"> | string | null
    seedingRate?: DecimalNullableWithAggregatesFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: StringNullableWithAggregatesFilter<"Planting"> | string | null
    seedsPerHill?: IntNullableWithAggregatesFilter<"Planting"> | number | null
    seedDepth?: DecimalNullableWithAggregatesFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: StringNullableWithAggregatesFilter<"Planting"> | string | null
    rowSpacing?: DecimalNullableWithAggregatesFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: DecimalNullableWithAggregatesFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: StringNullableWithAggregatesFilter<"Planting"> | string | null
    plantedArea?: DecimalNullableWithAggregatesFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: StringNullableWithAggregatesFilter<"Planting"> | string | null
    numberOfRows?: IntNullableWithAggregatesFilter<"Planting"> | number | null
    plantsPerRow?: IntNullableWithAggregatesFilter<"Planting"> | number | null
    totalPlantsExpected?: IntNullableWithAggregatesFilter<"Planting"> | number | null
    germinationDate?: DateTimeNullableWithAggregatesFilter<"Planting"> | Date | string | null
    emergenceDate?: DateTimeNullableWithAggregatesFilter<"Planting"> | Date | string | null
    germinationCount?: IntNullableWithAggregatesFilter<"Planting"> | number | null
    germinationPercentage?: DecimalNullableWithAggregatesFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    thinningDate?: DateTimeNullableWithAggregatesFilter<"Planting"> | Date | string | null
    finalPlantCount?: IntNullableWithAggregatesFilter<"Planting"> | number | null
    plantedBy?: StringWithAggregatesFilter<"Planting"> | string
    notes?: StringNullableWithAggregatesFilter<"Planting"> | string | null
    notesAr?: StringNullableWithAggregatesFilter<"Planting"> | string | null
    photos?: StringNullableListFilter<"Planting">
    metadata?: JsonWithAggregatesFilter<"Planting">
    createdAt?: DateTimeWithAggregatesFilter<"Planting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Planting"> | Date | string
  }

  export type ExperimentWhereInput = {
    AND?: ExperimentWhereInput | ExperimentWhereInput[]
    OR?: ExperimentWhereInput[]
    NOT?: ExperimentWhereInput | ExperimentWhereInput[]
    id?: StringFilter<"Experiment"> | string
    title?: StringFilter<"Experiment"> | string
    titleAr?: StringNullableFilter<"Experiment"> | string | null
    description?: StringNullableFilter<"Experiment"> | string | null
    descriptionAr?: StringNullableFilter<"Experiment"> | string | null
    hypothesis?: StringNullableFilter<"Experiment"> | string | null
    hypothesisAr?: StringNullableFilter<"Experiment"> | string | null
    startDate?: DateTimeFilter<"Experiment"> | Date | string
    endDate?: DateTimeNullableFilter<"Experiment"> | Date | string | null
    status?: EnumExperimentStatusFilter<"Experiment"> | $Enums.ExperimentStatus
    lockedAt?: DateTimeNullableFilter<"Experiment"> | Date | string | null
    lockedBy?: StringNullableFilter<"Experiment"> | string | null
    principalResearcherId?: StringFilter<"Experiment"> | string
    organizationId?: StringNullableFilter<"Experiment"> | string | null
    farmId?: StringNullableFilter<"Experiment"> | string | null
    metadata?: JsonFilter<"Experiment">
    tags?: StringNullableListFilter<"Experiment">
    createdAt?: DateTimeFilter<"Experiment"> | Date | string
    updatedAt?: DateTimeFilter<"Experiment"> | Date | string
    version?: IntFilter<"Experiment"> | number
    protocols?: ResearchProtocolListRelationFilter
    plots?: ResearchPlotListRelationFilter
    treatments?: TreatmentListRelationFilter
    logs?: ResearchDailyLogListRelationFilter
    samples?: LabSampleListRelationFilter
    collaborators?: ExperimentCollaboratorListRelationFilter
    auditLogs?: ExperimentAuditLogListRelationFilter
    plantings?: PlantingListRelationFilter
  }

  export type ExperimentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    titleAr?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    hypothesis?: SortOrderInput | SortOrder
    hypothesisAr?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    principalResearcherId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    farmId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    protocols?: ResearchProtocolOrderByRelationAggregateInput
    plots?: ResearchPlotOrderByRelationAggregateInput
    treatments?: TreatmentOrderByRelationAggregateInput
    logs?: ResearchDailyLogOrderByRelationAggregateInput
    samples?: LabSampleOrderByRelationAggregateInput
    collaborators?: ExperimentCollaboratorOrderByRelationAggregateInput
    auditLogs?: ExperimentAuditLogOrderByRelationAggregateInput
    plantings?: PlantingOrderByRelationAggregateInput
  }

  export type ExperimentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExperimentWhereInput | ExperimentWhereInput[]
    OR?: ExperimentWhereInput[]
    NOT?: ExperimentWhereInput | ExperimentWhereInput[]
    title?: StringFilter<"Experiment"> | string
    titleAr?: StringNullableFilter<"Experiment"> | string | null
    description?: StringNullableFilter<"Experiment"> | string | null
    descriptionAr?: StringNullableFilter<"Experiment"> | string | null
    hypothesis?: StringNullableFilter<"Experiment"> | string | null
    hypothesisAr?: StringNullableFilter<"Experiment"> | string | null
    startDate?: DateTimeFilter<"Experiment"> | Date | string
    endDate?: DateTimeNullableFilter<"Experiment"> | Date | string | null
    status?: EnumExperimentStatusFilter<"Experiment"> | $Enums.ExperimentStatus
    lockedAt?: DateTimeNullableFilter<"Experiment"> | Date | string | null
    lockedBy?: StringNullableFilter<"Experiment"> | string | null
    principalResearcherId?: StringFilter<"Experiment"> | string
    organizationId?: StringNullableFilter<"Experiment"> | string | null
    farmId?: StringNullableFilter<"Experiment"> | string | null
    metadata?: JsonFilter<"Experiment">
    tags?: StringNullableListFilter<"Experiment">
    createdAt?: DateTimeFilter<"Experiment"> | Date | string
    updatedAt?: DateTimeFilter<"Experiment"> | Date | string
    version?: IntFilter<"Experiment"> | number
    protocols?: ResearchProtocolListRelationFilter
    plots?: ResearchPlotListRelationFilter
    treatments?: TreatmentListRelationFilter
    logs?: ResearchDailyLogListRelationFilter
    samples?: LabSampleListRelationFilter
    collaborators?: ExperimentCollaboratorListRelationFilter
    auditLogs?: ExperimentAuditLogListRelationFilter
    plantings?: PlantingListRelationFilter
  }, "id">

  export type ExperimentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    titleAr?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    hypothesis?: SortOrderInput | SortOrder
    hypothesisAr?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    lockedBy?: SortOrderInput | SortOrder
    principalResearcherId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    farmId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
    _count?: ExperimentCountOrderByAggregateInput
    _avg?: ExperimentAvgOrderByAggregateInput
    _max?: ExperimentMaxOrderByAggregateInput
    _min?: ExperimentMinOrderByAggregateInput
    _sum?: ExperimentSumOrderByAggregateInput
  }

  export type ExperimentScalarWhereWithAggregatesInput = {
    AND?: ExperimentScalarWhereWithAggregatesInput | ExperimentScalarWhereWithAggregatesInput[]
    OR?: ExperimentScalarWhereWithAggregatesInput[]
    NOT?: ExperimentScalarWhereWithAggregatesInput | ExperimentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Experiment"> | string
    title?: StringWithAggregatesFilter<"Experiment"> | string
    titleAr?: StringNullableWithAggregatesFilter<"Experiment"> | string | null
    description?: StringNullableWithAggregatesFilter<"Experiment"> | string | null
    descriptionAr?: StringNullableWithAggregatesFilter<"Experiment"> | string | null
    hypothesis?: StringNullableWithAggregatesFilter<"Experiment"> | string | null
    hypothesisAr?: StringNullableWithAggregatesFilter<"Experiment"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Experiment"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Experiment"> | Date | string | null
    status?: EnumExperimentStatusWithAggregatesFilter<"Experiment"> | $Enums.ExperimentStatus
    lockedAt?: DateTimeNullableWithAggregatesFilter<"Experiment"> | Date | string | null
    lockedBy?: StringNullableWithAggregatesFilter<"Experiment"> | string | null
    principalResearcherId?: StringWithAggregatesFilter<"Experiment"> | string
    organizationId?: StringNullableWithAggregatesFilter<"Experiment"> | string | null
    farmId?: StringNullableWithAggregatesFilter<"Experiment"> | string | null
    metadata?: JsonWithAggregatesFilter<"Experiment">
    tags?: StringNullableListFilter<"Experiment">
    createdAt?: DateTimeWithAggregatesFilter<"Experiment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Experiment"> | Date | string
    version?: IntWithAggregatesFilter<"Experiment"> | number
  }

  export type ResearchProtocolWhereInput = {
    AND?: ResearchProtocolWhereInput | ResearchProtocolWhereInput[]
    OR?: ResearchProtocolWhereInput[]
    NOT?: ResearchProtocolWhereInput | ResearchProtocolWhereInput[]
    id?: StringFilter<"ResearchProtocol"> | string
    experimentId?: StringFilter<"ResearchProtocol"> | string
    name?: StringFilter<"ResearchProtocol"> | string
    nameAr?: StringNullableFilter<"ResearchProtocol"> | string | null
    description?: StringNullableFilter<"ResearchProtocol"> | string | null
    descriptionAr?: StringNullableFilter<"ResearchProtocol"> | string | null
    methodology?: StringFilter<"ResearchProtocol"> | string
    methodologyAr?: StringNullableFilter<"ResearchProtocol"> | string | null
    variables?: JsonFilter<"ResearchProtocol">
    measurementSchedule?: JsonFilter<"ResearchProtocol">
    equipmentRequired?: StringNullableListFilter<"ResearchProtocol">
    safetyGuidelines?: StringNullableFilter<"ResearchProtocol"> | string | null
    version?: IntFilter<"ResearchProtocol"> | number
    approvedBy?: StringNullableFilter<"ResearchProtocol"> | string | null
    approvedAt?: DateTimeNullableFilter<"ResearchProtocol"> | Date | string | null
    createdAt?: DateTimeFilter<"ResearchProtocol"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchProtocol"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
  }

  export type ResearchProtocolOrderByWithRelationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    name?: SortOrder
    nameAr?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    methodology?: SortOrder
    methodologyAr?: SortOrderInput | SortOrder
    variables?: SortOrder
    measurementSchedule?: SortOrder
    equipmentRequired?: SortOrder
    safetyGuidelines?: SortOrderInput | SortOrder
    version?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    experiment?: ExperimentOrderByWithRelationInput
  }

  export type ResearchProtocolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResearchProtocolWhereInput | ResearchProtocolWhereInput[]
    OR?: ResearchProtocolWhereInput[]
    NOT?: ResearchProtocolWhereInput | ResearchProtocolWhereInput[]
    experimentId?: StringFilter<"ResearchProtocol"> | string
    name?: StringFilter<"ResearchProtocol"> | string
    nameAr?: StringNullableFilter<"ResearchProtocol"> | string | null
    description?: StringNullableFilter<"ResearchProtocol"> | string | null
    descriptionAr?: StringNullableFilter<"ResearchProtocol"> | string | null
    methodology?: StringFilter<"ResearchProtocol"> | string
    methodologyAr?: StringNullableFilter<"ResearchProtocol"> | string | null
    variables?: JsonFilter<"ResearchProtocol">
    measurementSchedule?: JsonFilter<"ResearchProtocol">
    equipmentRequired?: StringNullableListFilter<"ResearchProtocol">
    safetyGuidelines?: StringNullableFilter<"ResearchProtocol"> | string | null
    version?: IntFilter<"ResearchProtocol"> | number
    approvedBy?: StringNullableFilter<"ResearchProtocol"> | string | null
    approvedAt?: DateTimeNullableFilter<"ResearchProtocol"> | Date | string | null
    createdAt?: DateTimeFilter<"ResearchProtocol"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchProtocol"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
  }, "id">

  export type ResearchProtocolOrderByWithAggregationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    name?: SortOrder
    nameAr?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    methodology?: SortOrder
    methodologyAr?: SortOrderInput | SortOrder
    variables?: SortOrder
    measurementSchedule?: SortOrder
    equipmentRequired?: SortOrder
    safetyGuidelines?: SortOrderInput | SortOrder
    version?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResearchProtocolCountOrderByAggregateInput
    _avg?: ResearchProtocolAvgOrderByAggregateInput
    _max?: ResearchProtocolMaxOrderByAggregateInput
    _min?: ResearchProtocolMinOrderByAggregateInput
    _sum?: ResearchProtocolSumOrderByAggregateInput
  }

  export type ResearchProtocolScalarWhereWithAggregatesInput = {
    AND?: ResearchProtocolScalarWhereWithAggregatesInput | ResearchProtocolScalarWhereWithAggregatesInput[]
    OR?: ResearchProtocolScalarWhereWithAggregatesInput[]
    NOT?: ResearchProtocolScalarWhereWithAggregatesInput | ResearchProtocolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResearchProtocol"> | string
    experimentId?: StringWithAggregatesFilter<"ResearchProtocol"> | string
    name?: StringWithAggregatesFilter<"ResearchProtocol"> | string
    nameAr?: StringNullableWithAggregatesFilter<"ResearchProtocol"> | string | null
    description?: StringNullableWithAggregatesFilter<"ResearchProtocol"> | string | null
    descriptionAr?: StringNullableWithAggregatesFilter<"ResearchProtocol"> | string | null
    methodology?: StringWithAggregatesFilter<"ResearchProtocol"> | string
    methodologyAr?: StringNullableWithAggregatesFilter<"ResearchProtocol"> | string | null
    variables?: JsonWithAggregatesFilter<"ResearchProtocol">
    measurementSchedule?: JsonWithAggregatesFilter<"ResearchProtocol">
    equipmentRequired?: StringNullableListFilter<"ResearchProtocol">
    safetyGuidelines?: StringNullableWithAggregatesFilter<"ResearchProtocol"> | string | null
    version?: IntWithAggregatesFilter<"ResearchProtocol"> | number
    approvedBy?: StringNullableWithAggregatesFilter<"ResearchProtocol"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"ResearchProtocol"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ResearchProtocol"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResearchProtocol"> | Date | string
  }

  export type ResearchPlotWhereInput = {
    AND?: ResearchPlotWhereInput | ResearchPlotWhereInput[]
    OR?: ResearchPlotWhereInput[]
    NOT?: ResearchPlotWhereInput | ResearchPlotWhereInput[]
    id?: StringFilter<"ResearchPlot"> | string
    experimentId?: StringFilter<"ResearchPlot"> | string
    plotCode?: StringFilter<"ResearchPlot"> | string
    name?: StringNullableFilter<"ResearchPlot"> | string | null
    nameAr?: StringNullableFilter<"ResearchPlot"> | string | null
    areaSqm?: DecimalNullableFilter<"ResearchPlot"> | Decimal | DecimalJsLike | number | string | null
    soilType?: StringNullableFilter<"ResearchPlot"> | string | null
    soilPh?: DecimalNullableFilter<"ResearchPlot"> | Decimal | DecimalJsLike | number | string | null
    previousCrop?: StringNullableFilter<"ResearchPlot"> | string | null
    replicateNumber?: IntFilter<"ResearchPlot"> | number
    blockNumber?: IntNullableFilter<"ResearchPlot"> | number | null
    rowNumber?: IntNullableFilter<"ResearchPlot"> | number | null
    columnNumber?: IntNullableFilter<"ResearchPlot"> | number | null
    metadata?: JsonFilter<"ResearchPlot">
    createdAt?: DateTimeFilter<"ResearchPlot"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchPlot"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    treatments?: TreatmentListRelationFilter
    logs?: ResearchDailyLogListRelationFilter
    samples?: LabSampleListRelationFilter
  }

  export type ResearchPlotOrderByWithRelationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotCode?: SortOrder
    name?: SortOrderInput | SortOrder
    nameAr?: SortOrderInput | SortOrder
    areaSqm?: SortOrderInput | SortOrder
    soilType?: SortOrderInput | SortOrder
    soilPh?: SortOrderInput | SortOrder
    previousCrop?: SortOrderInput | SortOrder
    replicateNumber?: SortOrder
    blockNumber?: SortOrderInput | SortOrder
    rowNumber?: SortOrderInput | SortOrder
    columnNumber?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    experiment?: ExperimentOrderByWithRelationInput
    treatments?: TreatmentOrderByRelationAggregateInput
    logs?: ResearchDailyLogOrderByRelationAggregateInput
    samples?: LabSampleOrderByRelationAggregateInput
  }

  export type ResearchPlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    experimentId_plotCode?: ResearchPlotExperimentIdPlotCodeCompoundUniqueInput
    AND?: ResearchPlotWhereInput | ResearchPlotWhereInput[]
    OR?: ResearchPlotWhereInput[]
    NOT?: ResearchPlotWhereInput | ResearchPlotWhereInput[]
    experimentId?: StringFilter<"ResearchPlot"> | string
    plotCode?: StringFilter<"ResearchPlot"> | string
    name?: StringNullableFilter<"ResearchPlot"> | string | null
    nameAr?: StringNullableFilter<"ResearchPlot"> | string | null
    areaSqm?: DecimalNullableFilter<"ResearchPlot"> | Decimal | DecimalJsLike | number | string | null
    soilType?: StringNullableFilter<"ResearchPlot"> | string | null
    soilPh?: DecimalNullableFilter<"ResearchPlot"> | Decimal | DecimalJsLike | number | string | null
    previousCrop?: StringNullableFilter<"ResearchPlot"> | string | null
    replicateNumber?: IntFilter<"ResearchPlot"> | number
    blockNumber?: IntNullableFilter<"ResearchPlot"> | number | null
    rowNumber?: IntNullableFilter<"ResearchPlot"> | number | null
    columnNumber?: IntNullableFilter<"ResearchPlot"> | number | null
    metadata?: JsonFilter<"ResearchPlot">
    createdAt?: DateTimeFilter<"ResearchPlot"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchPlot"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    treatments?: TreatmentListRelationFilter
    logs?: ResearchDailyLogListRelationFilter
    samples?: LabSampleListRelationFilter
  }, "id" | "experimentId_plotCode">

  export type ResearchPlotOrderByWithAggregationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotCode?: SortOrder
    name?: SortOrderInput | SortOrder
    nameAr?: SortOrderInput | SortOrder
    areaSqm?: SortOrderInput | SortOrder
    soilType?: SortOrderInput | SortOrder
    soilPh?: SortOrderInput | SortOrder
    previousCrop?: SortOrderInput | SortOrder
    replicateNumber?: SortOrder
    blockNumber?: SortOrderInput | SortOrder
    rowNumber?: SortOrderInput | SortOrder
    columnNumber?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResearchPlotCountOrderByAggregateInput
    _avg?: ResearchPlotAvgOrderByAggregateInput
    _max?: ResearchPlotMaxOrderByAggregateInput
    _min?: ResearchPlotMinOrderByAggregateInput
    _sum?: ResearchPlotSumOrderByAggregateInput
  }

  export type ResearchPlotScalarWhereWithAggregatesInput = {
    AND?: ResearchPlotScalarWhereWithAggregatesInput | ResearchPlotScalarWhereWithAggregatesInput[]
    OR?: ResearchPlotScalarWhereWithAggregatesInput[]
    NOT?: ResearchPlotScalarWhereWithAggregatesInput | ResearchPlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResearchPlot"> | string
    experimentId?: StringWithAggregatesFilter<"ResearchPlot"> | string
    plotCode?: StringWithAggregatesFilter<"ResearchPlot"> | string
    name?: StringNullableWithAggregatesFilter<"ResearchPlot"> | string | null
    nameAr?: StringNullableWithAggregatesFilter<"ResearchPlot"> | string | null
    areaSqm?: DecimalNullableWithAggregatesFilter<"ResearchPlot"> | Decimal | DecimalJsLike | number | string | null
    soilType?: StringNullableWithAggregatesFilter<"ResearchPlot"> | string | null
    soilPh?: DecimalNullableWithAggregatesFilter<"ResearchPlot"> | Decimal | DecimalJsLike | number | string | null
    previousCrop?: StringNullableWithAggregatesFilter<"ResearchPlot"> | string | null
    replicateNumber?: IntWithAggregatesFilter<"ResearchPlot"> | number
    blockNumber?: IntNullableWithAggregatesFilter<"ResearchPlot"> | number | null
    rowNumber?: IntNullableWithAggregatesFilter<"ResearchPlot"> | number | null
    columnNumber?: IntNullableWithAggregatesFilter<"ResearchPlot"> | number | null
    metadata?: JsonWithAggregatesFilter<"ResearchPlot">
    createdAt?: DateTimeWithAggregatesFilter<"ResearchPlot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResearchPlot"> | Date | string
  }

  export type TreatmentWhereInput = {
    AND?: TreatmentWhereInput | TreatmentWhereInput[]
    OR?: TreatmentWhereInput[]
    NOT?: TreatmentWhereInput | TreatmentWhereInput[]
    id?: StringFilter<"Treatment"> | string
    experimentId?: StringFilter<"Treatment"> | string
    plotId?: StringNullableFilter<"Treatment"> | string | null
    treatmentCode?: StringFilter<"Treatment"> | string
    name?: StringFilter<"Treatment"> | string
    nameAr?: StringNullableFilter<"Treatment"> | string | null
    type?: EnumTreatmentTypeFilter<"Treatment"> | $Enums.TreatmentType
    description?: StringNullableFilter<"Treatment"> | string | null
    descriptionAr?: StringNullableFilter<"Treatment"> | string | null
    dosage?: StringNullableFilter<"Treatment"> | string | null
    dosageUnit?: StringNullableFilter<"Treatment"> | string | null
    applicationMethod?: StringNullableFilter<"Treatment"> | string | null
    applicationFrequency?: StringNullableFilter<"Treatment"> | string | null
    startDate?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    isControl?: BoolFilter<"Treatment"> | boolean
    parameters?: JsonFilter<"Treatment">
    createdAt?: DateTimeFilter<"Treatment"> | Date | string
    updatedAt?: DateTimeFilter<"Treatment"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    plot?: XOR<ResearchPlotNullableRelationFilter, ResearchPlotWhereInput> | null
    logs?: ResearchDailyLogListRelationFilter
  }

  export type TreatmentOrderByWithRelationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrderInput | SortOrder
    treatmentCode?: SortOrder
    name?: SortOrder
    nameAr?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    dosage?: SortOrderInput | SortOrder
    dosageUnit?: SortOrderInput | SortOrder
    applicationMethod?: SortOrderInput | SortOrder
    applicationFrequency?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isControl?: SortOrder
    parameters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    experiment?: ExperimentOrderByWithRelationInput
    plot?: ResearchPlotOrderByWithRelationInput
    logs?: ResearchDailyLogOrderByRelationAggregateInput
  }

  export type TreatmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TreatmentWhereInput | TreatmentWhereInput[]
    OR?: TreatmentWhereInput[]
    NOT?: TreatmentWhereInput | TreatmentWhereInput[]
    experimentId?: StringFilter<"Treatment"> | string
    plotId?: StringNullableFilter<"Treatment"> | string | null
    treatmentCode?: StringFilter<"Treatment"> | string
    name?: StringFilter<"Treatment"> | string
    nameAr?: StringNullableFilter<"Treatment"> | string | null
    type?: EnumTreatmentTypeFilter<"Treatment"> | $Enums.TreatmentType
    description?: StringNullableFilter<"Treatment"> | string | null
    descriptionAr?: StringNullableFilter<"Treatment"> | string | null
    dosage?: StringNullableFilter<"Treatment"> | string | null
    dosageUnit?: StringNullableFilter<"Treatment"> | string | null
    applicationMethod?: StringNullableFilter<"Treatment"> | string | null
    applicationFrequency?: StringNullableFilter<"Treatment"> | string | null
    startDate?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    isControl?: BoolFilter<"Treatment"> | boolean
    parameters?: JsonFilter<"Treatment">
    createdAt?: DateTimeFilter<"Treatment"> | Date | string
    updatedAt?: DateTimeFilter<"Treatment"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    plot?: XOR<ResearchPlotNullableRelationFilter, ResearchPlotWhereInput> | null
    logs?: ResearchDailyLogListRelationFilter
  }, "id">

  export type TreatmentOrderByWithAggregationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrderInput | SortOrder
    treatmentCode?: SortOrder
    name?: SortOrder
    nameAr?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    dosage?: SortOrderInput | SortOrder
    dosageUnit?: SortOrderInput | SortOrder
    applicationMethod?: SortOrderInput | SortOrder
    applicationFrequency?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isControl?: SortOrder
    parameters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TreatmentCountOrderByAggregateInput
    _max?: TreatmentMaxOrderByAggregateInput
    _min?: TreatmentMinOrderByAggregateInput
  }

  export type TreatmentScalarWhereWithAggregatesInput = {
    AND?: TreatmentScalarWhereWithAggregatesInput | TreatmentScalarWhereWithAggregatesInput[]
    OR?: TreatmentScalarWhereWithAggregatesInput[]
    NOT?: TreatmentScalarWhereWithAggregatesInput | TreatmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Treatment"> | string
    experimentId?: StringWithAggregatesFilter<"Treatment"> | string
    plotId?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    treatmentCode?: StringWithAggregatesFilter<"Treatment"> | string
    name?: StringWithAggregatesFilter<"Treatment"> | string
    nameAr?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    type?: EnumTreatmentTypeWithAggregatesFilter<"Treatment"> | $Enums.TreatmentType
    description?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    descriptionAr?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    dosage?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    dosageUnit?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    applicationMethod?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    applicationFrequency?: StringNullableWithAggregatesFilter<"Treatment"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Treatment"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Treatment"> | Date | string | null
    isControl?: BoolWithAggregatesFilter<"Treatment"> | boolean
    parameters?: JsonWithAggregatesFilter<"Treatment">
    createdAt?: DateTimeWithAggregatesFilter<"Treatment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Treatment"> | Date | string
  }

  export type ResearchDailyLogWhereInput = {
    AND?: ResearchDailyLogWhereInput | ResearchDailyLogWhereInput[]
    OR?: ResearchDailyLogWhereInput[]
    NOT?: ResearchDailyLogWhereInput | ResearchDailyLogWhereInput[]
    id?: StringFilter<"ResearchDailyLog"> | string
    experimentId?: StringFilter<"ResearchDailyLog"> | string
    plotId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    treatmentId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    logDate?: DateTimeFilter<"ResearchDailyLog"> | Date | string
    logTime?: StringNullableFilter<"ResearchDailyLog"> | string | null
    category?: EnumLogCategoryFilter<"ResearchDailyLog"> | $Enums.LogCategory
    title?: StringFilter<"ResearchDailyLog"> | string
    titleAr?: StringNullableFilter<"ResearchDailyLog"> | string | null
    notes?: StringNullableFilter<"ResearchDailyLog"> | string | null
    notesAr?: StringNullableFilter<"ResearchDailyLog"> | string | null
    measurements?: JsonFilter<"ResearchDailyLog">
    weatherConditions?: JsonFilter<"ResearchDailyLog">
    photos?: StringNullableListFilter<"ResearchDailyLog">
    attachments?: StringNullableListFilter<"ResearchDailyLog">
    recordedBy?: StringFilter<"ResearchDailyLog"> | string
    deviceId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    offlineId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    hash?: StringNullableFilter<"ResearchDailyLog"> | string | null
    syncedAt?: DateTimeNullableFilter<"ResearchDailyLog"> | Date | string | null
    createdAt?: DateTimeFilter<"ResearchDailyLog"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchDailyLog"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    plot?: XOR<ResearchPlotNullableRelationFilter, ResearchPlotWhereInput> | null
    treatment?: XOR<TreatmentNullableRelationFilter, TreatmentWhereInput> | null
    samples?: LabSampleListRelationFilter
  }

  export type ResearchDailyLogOrderByWithRelationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrderInput | SortOrder
    treatmentId?: SortOrderInput | SortOrder
    logDate?: SortOrder
    logTime?: SortOrderInput | SortOrder
    category?: SortOrder
    title?: SortOrder
    titleAr?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    notesAr?: SortOrderInput | SortOrder
    measurements?: SortOrder
    weatherConditions?: SortOrder
    photos?: SortOrder
    attachments?: SortOrder
    recordedBy?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    offlineId?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    syncedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    experiment?: ExperimentOrderByWithRelationInput
    plot?: ResearchPlotOrderByWithRelationInput
    treatment?: TreatmentOrderByWithRelationInput
    samples?: LabSampleOrderByRelationAggregateInput
  }

  export type ResearchDailyLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    offlineId?: string
    AND?: ResearchDailyLogWhereInput | ResearchDailyLogWhereInput[]
    OR?: ResearchDailyLogWhereInput[]
    NOT?: ResearchDailyLogWhereInput | ResearchDailyLogWhereInput[]
    experimentId?: StringFilter<"ResearchDailyLog"> | string
    plotId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    treatmentId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    logDate?: DateTimeFilter<"ResearchDailyLog"> | Date | string
    logTime?: StringNullableFilter<"ResearchDailyLog"> | string | null
    category?: EnumLogCategoryFilter<"ResearchDailyLog"> | $Enums.LogCategory
    title?: StringFilter<"ResearchDailyLog"> | string
    titleAr?: StringNullableFilter<"ResearchDailyLog"> | string | null
    notes?: StringNullableFilter<"ResearchDailyLog"> | string | null
    notesAr?: StringNullableFilter<"ResearchDailyLog"> | string | null
    measurements?: JsonFilter<"ResearchDailyLog">
    weatherConditions?: JsonFilter<"ResearchDailyLog">
    photos?: StringNullableListFilter<"ResearchDailyLog">
    attachments?: StringNullableListFilter<"ResearchDailyLog">
    recordedBy?: StringFilter<"ResearchDailyLog"> | string
    deviceId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    hash?: StringNullableFilter<"ResearchDailyLog"> | string | null
    syncedAt?: DateTimeNullableFilter<"ResearchDailyLog"> | Date | string | null
    createdAt?: DateTimeFilter<"ResearchDailyLog"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchDailyLog"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    plot?: XOR<ResearchPlotNullableRelationFilter, ResearchPlotWhereInput> | null
    treatment?: XOR<TreatmentNullableRelationFilter, TreatmentWhereInput> | null
    samples?: LabSampleListRelationFilter
  }, "id" | "offlineId">

  export type ResearchDailyLogOrderByWithAggregationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrderInput | SortOrder
    treatmentId?: SortOrderInput | SortOrder
    logDate?: SortOrder
    logTime?: SortOrderInput | SortOrder
    category?: SortOrder
    title?: SortOrder
    titleAr?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    notesAr?: SortOrderInput | SortOrder
    measurements?: SortOrder
    weatherConditions?: SortOrder
    photos?: SortOrder
    attachments?: SortOrder
    recordedBy?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    offlineId?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    syncedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResearchDailyLogCountOrderByAggregateInput
    _max?: ResearchDailyLogMaxOrderByAggregateInput
    _min?: ResearchDailyLogMinOrderByAggregateInput
  }

  export type ResearchDailyLogScalarWhereWithAggregatesInput = {
    AND?: ResearchDailyLogScalarWhereWithAggregatesInput | ResearchDailyLogScalarWhereWithAggregatesInput[]
    OR?: ResearchDailyLogScalarWhereWithAggregatesInput[]
    NOT?: ResearchDailyLogScalarWhereWithAggregatesInput | ResearchDailyLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResearchDailyLog"> | string
    experimentId?: StringWithAggregatesFilter<"ResearchDailyLog"> | string
    plotId?: StringNullableWithAggregatesFilter<"ResearchDailyLog"> | string | null
    treatmentId?: StringNullableWithAggregatesFilter<"ResearchDailyLog"> | string | null
    logDate?: DateTimeWithAggregatesFilter<"ResearchDailyLog"> | Date | string
    logTime?: StringNullableWithAggregatesFilter<"ResearchDailyLog"> | string | null
    category?: EnumLogCategoryWithAggregatesFilter<"ResearchDailyLog"> | $Enums.LogCategory
    title?: StringWithAggregatesFilter<"ResearchDailyLog"> | string
    titleAr?: StringNullableWithAggregatesFilter<"ResearchDailyLog"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ResearchDailyLog"> | string | null
    notesAr?: StringNullableWithAggregatesFilter<"ResearchDailyLog"> | string | null
    measurements?: JsonWithAggregatesFilter<"ResearchDailyLog">
    weatherConditions?: JsonWithAggregatesFilter<"ResearchDailyLog">
    photos?: StringNullableListFilter<"ResearchDailyLog">
    attachments?: StringNullableListFilter<"ResearchDailyLog">
    recordedBy?: StringWithAggregatesFilter<"ResearchDailyLog"> | string
    deviceId?: StringNullableWithAggregatesFilter<"ResearchDailyLog"> | string | null
    offlineId?: StringNullableWithAggregatesFilter<"ResearchDailyLog"> | string | null
    hash?: StringNullableWithAggregatesFilter<"ResearchDailyLog"> | string | null
    syncedAt?: DateTimeNullableWithAggregatesFilter<"ResearchDailyLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ResearchDailyLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResearchDailyLog"> | Date | string
  }

  export type LabSampleWhereInput = {
    AND?: LabSampleWhereInput | LabSampleWhereInput[]
    OR?: LabSampleWhereInput[]
    NOT?: LabSampleWhereInput | LabSampleWhereInput[]
    id?: StringFilter<"LabSample"> | string
    experimentId?: StringFilter<"LabSample"> | string
    plotId?: StringNullableFilter<"LabSample"> | string | null
    logId?: StringNullableFilter<"LabSample"> | string | null
    sampleCode?: StringFilter<"LabSample"> | string
    type?: EnumSampleTypeFilter<"LabSample"> | $Enums.SampleType
    description?: StringNullableFilter<"LabSample"> | string | null
    descriptionAr?: StringNullableFilter<"LabSample"> | string | null
    collectionDate?: DateTimeFilter<"LabSample"> | Date | string
    collectionTime?: StringNullableFilter<"LabSample"> | string | null
    collectedBy?: StringFilter<"LabSample"> | string
    storageLocation?: StringNullableFilter<"LabSample"> | string | null
    storageConditions?: StringNullableFilter<"LabSample"> | string | null
    quantity?: DecimalNullableFilter<"LabSample"> | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: StringNullableFilter<"LabSample"> | string | null
    analysisStatus?: StringFilter<"LabSample"> | string
    analysisResults?: JsonFilter<"LabSample">
    analyzedBy?: StringNullableFilter<"LabSample"> | string | null
    analyzedAt?: DateTimeNullableFilter<"LabSample"> | Date | string | null
    photos?: StringNullableListFilter<"LabSample">
    metadata?: JsonFilter<"LabSample">
    createdAt?: DateTimeFilter<"LabSample"> | Date | string
    updatedAt?: DateTimeFilter<"LabSample"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    plot?: XOR<ResearchPlotNullableRelationFilter, ResearchPlotWhereInput> | null
    log?: XOR<ResearchDailyLogNullableRelationFilter, ResearchDailyLogWhereInput> | null
  }

  export type LabSampleOrderByWithRelationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrderInput | SortOrder
    logId?: SortOrderInput | SortOrder
    sampleCode?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    collectionDate?: SortOrder
    collectionTime?: SortOrderInput | SortOrder
    collectedBy?: SortOrder
    storageLocation?: SortOrderInput | SortOrder
    storageConditions?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    quantityUnit?: SortOrderInput | SortOrder
    analysisStatus?: SortOrder
    analysisResults?: SortOrder
    analyzedBy?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    photos?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    experiment?: ExperimentOrderByWithRelationInput
    plot?: ResearchPlotOrderByWithRelationInput
    log?: ResearchDailyLogOrderByWithRelationInput
  }

  export type LabSampleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sampleCode?: string
    AND?: LabSampleWhereInput | LabSampleWhereInput[]
    OR?: LabSampleWhereInput[]
    NOT?: LabSampleWhereInput | LabSampleWhereInput[]
    experimentId?: StringFilter<"LabSample"> | string
    plotId?: StringNullableFilter<"LabSample"> | string | null
    logId?: StringNullableFilter<"LabSample"> | string | null
    type?: EnumSampleTypeFilter<"LabSample"> | $Enums.SampleType
    description?: StringNullableFilter<"LabSample"> | string | null
    descriptionAr?: StringNullableFilter<"LabSample"> | string | null
    collectionDate?: DateTimeFilter<"LabSample"> | Date | string
    collectionTime?: StringNullableFilter<"LabSample"> | string | null
    collectedBy?: StringFilter<"LabSample"> | string
    storageLocation?: StringNullableFilter<"LabSample"> | string | null
    storageConditions?: StringNullableFilter<"LabSample"> | string | null
    quantity?: DecimalNullableFilter<"LabSample"> | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: StringNullableFilter<"LabSample"> | string | null
    analysisStatus?: StringFilter<"LabSample"> | string
    analysisResults?: JsonFilter<"LabSample">
    analyzedBy?: StringNullableFilter<"LabSample"> | string | null
    analyzedAt?: DateTimeNullableFilter<"LabSample"> | Date | string | null
    photos?: StringNullableListFilter<"LabSample">
    metadata?: JsonFilter<"LabSample">
    createdAt?: DateTimeFilter<"LabSample"> | Date | string
    updatedAt?: DateTimeFilter<"LabSample"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
    plot?: XOR<ResearchPlotNullableRelationFilter, ResearchPlotWhereInput> | null
    log?: XOR<ResearchDailyLogNullableRelationFilter, ResearchDailyLogWhereInput> | null
  }, "id" | "sampleCode">

  export type LabSampleOrderByWithAggregationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrderInput | SortOrder
    logId?: SortOrderInput | SortOrder
    sampleCode?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionAr?: SortOrderInput | SortOrder
    collectionDate?: SortOrder
    collectionTime?: SortOrderInput | SortOrder
    collectedBy?: SortOrder
    storageLocation?: SortOrderInput | SortOrder
    storageConditions?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    quantityUnit?: SortOrderInput | SortOrder
    analysisStatus?: SortOrder
    analysisResults?: SortOrder
    analyzedBy?: SortOrderInput | SortOrder
    analyzedAt?: SortOrderInput | SortOrder
    photos?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LabSampleCountOrderByAggregateInput
    _avg?: LabSampleAvgOrderByAggregateInput
    _max?: LabSampleMaxOrderByAggregateInput
    _min?: LabSampleMinOrderByAggregateInput
    _sum?: LabSampleSumOrderByAggregateInput
  }

  export type LabSampleScalarWhereWithAggregatesInput = {
    AND?: LabSampleScalarWhereWithAggregatesInput | LabSampleScalarWhereWithAggregatesInput[]
    OR?: LabSampleScalarWhereWithAggregatesInput[]
    NOT?: LabSampleScalarWhereWithAggregatesInput | LabSampleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabSample"> | string
    experimentId?: StringWithAggregatesFilter<"LabSample"> | string
    plotId?: StringNullableWithAggregatesFilter<"LabSample"> | string | null
    logId?: StringNullableWithAggregatesFilter<"LabSample"> | string | null
    sampleCode?: StringWithAggregatesFilter<"LabSample"> | string
    type?: EnumSampleTypeWithAggregatesFilter<"LabSample"> | $Enums.SampleType
    description?: StringNullableWithAggregatesFilter<"LabSample"> | string | null
    descriptionAr?: StringNullableWithAggregatesFilter<"LabSample"> | string | null
    collectionDate?: DateTimeWithAggregatesFilter<"LabSample"> | Date | string
    collectionTime?: StringNullableWithAggregatesFilter<"LabSample"> | string | null
    collectedBy?: StringWithAggregatesFilter<"LabSample"> | string
    storageLocation?: StringNullableWithAggregatesFilter<"LabSample"> | string | null
    storageConditions?: StringNullableWithAggregatesFilter<"LabSample"> | string | null
    quantity?: DecimalNullableWithAggregatesFilter<"LabSample"> | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: StringNullableWithAggregatesFilter<"LabSample"> | string | null
    analysisStatus?: StringWithAggregatesFilter<"LabSample"> | string
    analysisResults?: JsonWithAggregatesFilter<"LabSample">
    analyzedBy?: StringNullableWithAggregatesFilter<"LabSample"> | string | null
    analyzedAt?: DateTimeNullableWithAggregatesFilter<"LabSample"> | Date | string | null
    photos?: StringNullableListFilter<"LabSample">
    metadata?: JsonWithAggregatesFilter<"LabSample">
    createdAt?: DateTimeWithAggregatesFilter<"LabSample"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabSample"> | Date | string
  }

  export type DigitalSignatureWhereInput = {
    AND?: DigitalSignatureWhereInput | DigitalSignatureWhereInput[]
    OR?: DigitalSignatureWhereInput[]
    NOT?: DigitalSignatureWhereInput | DigitalSignatureWhereInput[]
    id?: StringFilter<"DigitalSignature"> | string
    entityType?: StringFilter<"DigitalSignature"> | string
    entityId?: StringFilter<"DigitalSignature"> | string
    signerId?: StringFilter<"DigitalSignature"> | string
    signatureHash?: StringFilter<"DigitalSignature"> | string
    algorithm?: StringFilter<"DigitalSignature"> | string
    payloadHash?: StringFilter<"DigitalSignature"> | string
    timestamp?: DateTimeFilter<"DigitalSignature"> | Date | string
    ipAddress?: StringNullableFilter<"DigitalSignature"> | string | null
    deviceInfo?: JsonFilter<"DigitalSignature">
    purpose?: StringNullableFilter<"DigitalSignature"> | string | null
    isValid?: BoolFilter<"DigitalSignature"> | boolean
    invalidatedAt?: DateTimeNullableFilter<"DigitalSignature"> | Date | string | null
    invalidatedReason?: StringNullableFilter<"DigitalSignature"> | string | null
    createdAt?: DateTimeFilter<"DigitalSignature"> | Date | string
  }

  export type DigitalSignatureOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    signerId?: SortOrder
    signatureHash?: SortOrder
    algorithm?: SortOrder
    payloadHash?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    deviceInfo?: SortOrder
    purpose?: SortOrderInput | SortOrder
    isValid?: SortOrder
    invalidatedAt?: SortOrderInput | SortOrder
    invalidatedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type DigitalSignatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityType_entityId_signerId_purpose?: DigitalSignatureEntityTypeEntityIdSignerIdPurposeCompoundUniqueInput
    AND?: DigitalSignatureWhereInput | DigitalSignatureWhereInput[]
    OR?: DigitalSignatureWhereInput[]
    NOT?: DigitalSignatureWhereInput | DigitalSignatureWhereInput[]
    entityType?: StringFilter<"DigitalSignature"> | string
    entityId?: StringFilter<"DigitalSignature"> | string
    signerId?: StringFilter<"DigitalSignature"> | string
    signatureHash?: StringFilter<"DigitalSignature"> | string
    algorithm?: StringFilter<"DigitalSignature"> | string
    payloadHash?: StringFilter<"DigitalSignature"> | string
    timestamp?: DateTimeFilter<"DigitalSignature"> | Date | string
    ipAddress?: StringNullableFilter<"DigitalSignature"> | string | null
    deviceInfo?: JsonFilter<"DigitalSignature">
    purpose?: StringNullableFilter<"DigitalSignature"> | string | null
    isValid?: BoolFilter<"DigitalSignature"> | boolean
    invalidatedAt?: DateTimeNullableFilter<"DigitalSignature"> | Date | string | null
    invalidatedReason?: StringNullableFilter<"DigitalSignature"> | string | null
    createdAt?: DateTimeFilter<"DigitalSignature"> | Date | string
  }, "id" | "entityType_entityId_signerId_purpose">

  export type DigitalSignatureOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    signerId?: SortOrder
    signatureHash?: SortOrder
    algorithm?: SortOrder
    payloadHash?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    deviceInfo?: SortOrder
    purpose?: SortOrderInput | SortOrder
    isValid?: SortOrder
    invalidatedAt?: SortOrderInput | SortOrder
    invalidatedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DigitalSignatureCountOrderByAggregateInput
    _max?: DigitalSignatureMaxOrderByAggregateInput
    _min?: DigitalSignatureMinOrderByAggregateInput
  }

  export type DigitalSignatureScalarWhereWithAggregatesInput = {
    AND?: DigitalSignatureScalarWhereWithAggregatesInput | DigitalSignatureScalarWhereWithAggregatesInput[]
    OR?: DigitalSignatureScalarWhereWithAggregatesInput[]
    NOT?: DigitalSignatureScalarWhereWithAggregatesInput | DigitalSignatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DigitalSignature"> | string
    entityType?: StringWithAggregatesFilter<"DigitalSignature"> | string
    entityId?: StringWithAggregatesFilter<"DigitalSignature"> | string
    signerId?: StringWithAggregatesFilter<"DigitalSignature"> | string
    signatureHash?: StringWithAggregatesFilter<"DigitalSignature"> | string
    algorithm?: StringWithAggregatesFilter<"DigitalSignature"> | string
    payloadHash?: StringWithAggregatesFilter<"DigitalSignature"> | string
    timestamp?: DateTimeWithAggregatesFilter<"DigitalSignature"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"DigitalSignature"> | string | null
    deviceInfo?: JsonWithAggregatesFilter<"DigitalSignature">
    purpose?: StringNullableWithAggregatesFilter<"DigitalSignature"> | string | null
    isValid?: BoolWithAggregatesFilter<"DigitalSignature"> | boolean
    invalidatedAt?: DateTimeNullableWithAggregatesFilter<"DigitalSignature"> | Date | string | null
    invalidatedReason?: StringNullableWithAggregatesFilter<"DigitalSignature"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DigitalSignature"> | Date | string
  }

  export type ExperimentCollaboratorWhereInput = {
    AND?: ExperimentCollaboratorWhereInput | ExperimentCollaboratorWhereInput[]
    OR?: ExperimentCollaboratorWhereInput[]
    NOT?: ExperimentCollaboratorWhereInput | ExperimentCollaboratorWhereInput[]
    id?: StringFilter<"ExperimentCollaborator"> | string
    experimentId?: StringFilter<"ExperimentCollaborator"> | string
    userId?: StringFilter<"ExperimentCollaborator"> | string
    role?: StringFilter<"ExperimentCollaborator"> | string
    permissions?: JsonFilter<"ExperimentCollaborator">
    invitedBy?: StringNullableFilter<"ExperimentCollaborator"> | string | null
    acceptedAt?: DateTimeNullableFilter<"ExperimentCollaborator"> | Date | string | null
    createdAt?: DateTimeFilter<"ExperimentCollaborator"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
  }

  export type ExperimentCollaboratorOrderByWithRelationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    experiment?: ExperimentOrderByWithRelationInput
  }

  export type ExperimentCollaboratorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    experimentId_userId?: ExperimentCollaboratorExperimentIdUserIdCompoundUniqueInput
    AND?: ExperimentCollaboratorWhereInput | ExperimentCollaboratorWhereInput[]
    OR?: ExperimentCollaboratorWhereInput[]
    NOT?: ExperimentCollaboratorWhereInput | ExperimentCollaboratorWhereInput[]
    experimentId?: StringFilter<"ExperimentCollaborator"> | string
    userId?: StringFilter<"ExperimentCollaborator"> | string
    role?: StringFilter<"ExperimentCollaborator"> | string
    permissions?: JsonFilter<"ExperimentCollaborator">
    invitedBy?: StringNullableFilter<"ExperimentCollaborator"> | string | null
    acceptedAt?: DateTimeNullableFilter<"ExperimentCollaborator"> | Date | string | null
    createdAt?: DateTimeFilter<"ExperimentCollaborator"> | Date | string
    experiment?: XOR<ExperimentRelationFilter, ExperimentWhereInput>
  }, "id" | "experimentId_userId">

  export type ExperimentCollaboratorOrderByWithAggregationInput = {
    id?: SortOrder
    experimentId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ExperimentCollaboratorCountOrderByAggregateInput
    _max?: ExperimentCollaboratorMaxOrderByAggregateInput
    _min?: ExperimentCollaboratorMinOrderByAggregateInput
  }

  export type ExperimentCollaboratorScalarWhereWithAggregatesInput = {
    AND?: ExperimentCollaboratorScalarWhereWithAggregatesInput | ExperimentCollaboratorScalarWhereWithAggregatesInput[]
    OR?: ExperimentCollaboratorScalarWhereWithAggregatesInput[]
    NOT?: ExperimentCollaboratorScalarWhereWithAggregatesInput | ExperimentCollaboratorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExperimentCollaborator"> | string
    experimentId?: StringWithAggregatesFilter<"ExperimentCollaborator"> | string
    userId?: StringWithAggregatesFilter<"ExperimentCollaborator"> | string
    role?: StringWithAggregatesFilter<"ExperimentCollaborator"> | string
    permissions?: JsonWithAggregatesFilter<"ExperimentCollaborator">
    invitedBy?: StringNullableWithAggregatesFilter<"ExperimentCollaborator"> | string | null
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"ExperimentCollaborator"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExperimentCollaborator"> | Date | string
  }

  export type ExperimentAuditLogWhereInput = {
    AND?: ExperimentAuditLogWhereInput | ExperimentAuditLogWhereInput[]
    OR?: ExperimentAuditLogWhereInput[]
    NOT?: ExperimentAuditLogWhereInput | ExperimentAuditLogWhereInput[]
    id?: StringFilter<"ExperimentAuditLog"> | string
    experimentId?: StringNullableFilter<"ExperimentAuditLog"> | string | null
    entityType?: StringFilter<"ExperimentAuditLog"> | string
    entityId?: StringFilter<"ExperimentAuditLog"> | string
    action?: StringFilter<"ExperimentAuditLog"> | string
    oldValues?: JsonNullableFilter<"ExperimentAuditLog">
    newValues?: JsonNullableFilter<"ExperimentAuditLog">
    changedBy?: StringFilter<"ExperimentAuditLog"> | string
    changedAt?: DateTimeFilter<"ExperimentAuditLog"> | Date | string
    ipAddress?: StringNullableFilter<"ExperimentAuditLog"> | string | null
    userAgent?: StringNullableFilter<"ExperimentAuditLog"> | string | null
    experiment?: XOR<ExperimentNullableRelationFilter, ExperimentWhereInput> | null
  }

  export type ExperimentAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    experimentId?: SortOrderInput | SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    experiment?: ExperimentOrderByWithRelationInput
  }

  export type ExperimentAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExperimentAuditLogWhereInput | ExperimentAuditLogWhereInput[]
    OR?: ExperimentAuditLogWhereInput[]
    NOT?: ExperimentAuditLogWhereInput | ExperimentAuditLogWhereInput[]
    experimentId?: StringNullableFilter<"ExperimentAuditLog"> | string | null
    entityType?: StringFilter<"ExperimentAuditLog"> | string
    entityId?: StringFilter<"ExperimentAuditLog"> | string
    action?: StringFilter<"ExperimentAuditLog"> | string
    oldValues?: JsonNullableFilter<"ExperimentAuditLog">
    newValues?: JsonNullableFilter<"ExperimentAuditLog">
    changedBy?: StringFilter<"ExperimentAuditLog"> | string
    changedAt?: DateTimeFilter<"ExperimentAuditLog"> | Date | string
    ipAddress?: StringNullableFilter<"ExperimentAuditLog"> | string | null
    userAgent?: StringNullableFilter<"ExperimentAuditLog"> | string | null
    experiment?: XOR<ExperimentNullableRelationFilter, ExperimentWhereInput> | null
  }, "id">

  export type ExperimentAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    experimentId?: SortOrderInput | SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: ExperimentAuditLogCountOrderByAggregateInput
    _max?: ExperimentAuditLogMaxOrderByAggregateInput
    _min?: ExperimentAuditLogMinOrderByAggregateInput
  }

  export type ExperimentAuditLogScalarWhereWithAggregatesInput = {
    AND?: ExperimentAuditLogScalarWhereWithAggregatesInput | ExperimentAuditLogScalarWhereWithAggregatesInput[]
    OR?: ExperimentAuditLogScalarWhereWithAggregatesInput[]
    NOT?: ExperimentAuditLogScalarWhereWithAggregatesInput | ExperimentAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExperimentAuditLog"> | string
    experimentId?: StringNullableWithAggregatesFilter<"ExperimentAuditLog"> | string | null
    entityType?: StringWithAggregatesFilter<"ExperimentAuditLog"> | string
    entityId?: StringWithAggregatesFilter<"ExperimentAuditLog"> | string
    action?: StringWithAggregatesFilter<"ExperimentAuditLog"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"ExperimentAuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"ExperimentAuditLog">
    changedBy?: StringWithAggregatesFilter<"ExperimentAuditLog"> | string
    changedAt?: DateTimeWithAggregatesFilter<"ExperimentAuditLog"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"ExperimentAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ExperimentAuditLog"> | string | null
  }

  export type GermplasmCreateInput = {
    id?: string
    accessionNumber: string
    commonName: string
    commonNameAr?: string | null
    scientificName?: string | null
    genus?: string | null
    species?: string | null
    subspecies?: string | null
    cultivar?: string | null
    variety?: string | null
    pedigree?: string | null
    type?: $Enums.GermplasmType
    countryOfOrigin?: string | null
    regionOfOrigin?: string | null
    collectionSite?: string | null
    collectionDate?: Date | string | null
    collectedBy?: string | null
    donorInstitution?: string | null
    donorAccessionNumber?: string | null
    growthHabit?: string | null
    maturityDays?: number | null
    yieldPotential?: string | null
    droughtTolerance?: string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: string | null
    storageConditions?: string | null
    storageTemperature?: Decimal | DecimalJsLike | number | string | null
    storageHumidity?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    quantityAvailable?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    description?: string | null
    descriptionAr?: string | null
    photos?: GermplasmCreatephotosInput | string[]
    documents?: GermplasmCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    seedLots?: SeedLotCreateNestedManyWithoutGermplasmInput
    plantings?: PlantingCreateNestedManyWithoutGermplasmInput
  }

  export type GermplasmUncheckedCreateInput = {
    id?: string
    accessionNumber: string
    commonName: string
    commonNameAr?: string | null
    scientificName?: string | null
    genus?: string | null
    species?: string | null
    subspecies?: string | null
    cultivar?: string | null
    variety?: string | null
    pedigree?: string | null
    type?: $Enums.GermplasmType
    countryOfOrigin?: string | null
    regionOfOrigin?: string | null
    collectionSite?: string | null
    collectionDate?: Date | string | null
    collectedBy?: string | null
    donorInstitution?: string | null
    donorAccessionNumber?: string | null
    growthHabit?: string | null
    maturityDays?: number | null
    yieldPotential?: string | null
    droughtTolerance?: string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: string | null
    storageConditions?: string | null
    storageTemperature?: Decimal | DecimalJsLike | number | string | null
    storageHumidity?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    quantityAvailable?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    description?: string | null
    descriptionAr?: string | null
    photos?: GermplasmCreatephotosInput | string[]
    documents?: GermplasmCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    seedLots?: SeedLotUncheckedCreateNestedManyWithoutGermplasmInput
    plantings?: PlantingUncheckedCreateNestedManyWithoutGermplasmInput
  }

  export type GermplasmUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNumber?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    commonNameAr?: NullableStringFieldUpdateOperationsInput | string | null
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    subspecies?: NullableStringFieldUpdateOperationsInput | string | null
    cultivar?: NullableStringFieldUpdateOperationsInput | string | null
    variety?: NullableStringFieldUpdateOperationsInput | string | null
    pedigree?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGermplasmTypeFieldUpdateOperationsInput | $Enums.GermplasmType
    countryOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    regionOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    collectionSite?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    donorInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    donorAccessionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    maturityDays?: NullableIntFieldUpdateOperationsInput | number | null
    yieldPotential?: NullableStringFieldUpdateOperationsInput | string | null
    droughtTolerance?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    storageTemperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    quantityAvailable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: GermplasmUpdatephotosInput | string[]
    documents?: GermplasmUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seedLots?: SeedLotUpdateManyWithoutGermplasmNestedInput
    plantings?: PlantingUpdateManyWithoutGermplasmNestedInput
  }

  export type GermplasmUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNumber?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    commonNameAr?: NullableStringFieldUpdateOperationsInput | string | null
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    subspecies?: NullableStringFieldUpdateOperationsInput | string | null
    cultivar?: NullableStringFieldUpdateOperationsInput | string | null
    variety?: NullableStringFieldUpdateOperationsInput | string | null
    pedigree?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGermplasmTypeFieldUpdateOperationsInput | $Enums.GermplasmType
    countryOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    regionOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    collectionSite?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    donorInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    donorAccessionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    maturityDays?: NullableIntFieldUpdateOperationsInput | number | null
    yieldPotential?: NullableStringFieldUpdateOperationsInput | string | null
    droughtTolerance?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    storageTemperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    quantityAvailable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: GermplasmUpdatephotosInput | string[]
    documents?: GermplasmUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seedLots?: SeedLotUncheckedUpdateManyWithoutGermplasmNestedInput
    plantings?: PlantingUncheckedUpdateManyWithoutGermplasmNestedInput
  }

  export type GermplasmCreateManyInput = {
    id?: string
    accessionNumber: string
    commonName: string
    commonNameAr?: string | null
    scientificName?: string | null
    genus?: string | null
    species?: string | null
    subspecies?: string | null
    cultivar?: string | null
    variety?: string | null
    pedigree?: string | null
    type?: $Enums.GermplasmType
    countryOfOrigin?: string | null
    regionOfOrigin?: string | null
    collectionSite?: string | null
    collectionDate?: Date | string | null
    collectedBy?: string | null
    donorInstitution?: string | null
    donorAccessionNumber?: string | null
    growthHabit?: string | null
    maturityDays?: number | null
    yieldPotential?: string | null
    droughtTolerance?: string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: string | null
    storageConditions?: string | null
    storageTemperature?: Decimal | DecimalJsLike | number | string | null
    storageHumidity?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    quantityAvailable?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    description?: string | null
    descriptionAr?: string | null
    photos?: GermplasmCreatephotosInput | string[]
    documents?: GermplasmCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GermplasmUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNumber?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    commonNameAr?: NullableStringFieldUpdateOperationsInput | string | null
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    subspecies?: NullableStringFieldUpdateOperationsInput | string | null
    cultivar?: NullableStringFieldUpdateOperationsInput | string | null
    variety?: NullableStringFieldUpdateOperationsInput | string | null
    pedigree?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGermplasmTypeFieldUpdateOperationsInput | $Enums.GermplasmType
    countryOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    regionOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    collectionSite?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    donorInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    donorAccessionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    maturityDays?: NullableIntFieldUpdateOperationsInput | number | null
    yieldPotential?: NullableStringFieldUpdateOperationsInput | string | null
    droughtTolerance?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    storageTemperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    quantityAvailable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: GermplasmUpdatephotosInput | string[]
    documents?: GermplasmUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GermplasmUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNumber?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    commonNameAr?: NullableStringFieldUpdateOperationsInput | string | null
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    subspecies?: NullableStringFieldUpdateOperationsInput | string | null
    cultivar?: NullableStringFieldUpdateOperationsInput | string | null
    variety?: NullableStringFieldUpdateOperationsInput | string | null
    pedigree?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGermplasmTypeFieldUpdateOperationsInput | $Enums.GermplasmType
    countryOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    regionOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    collectionSite?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    donorInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    donorAccessionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    maturityDays?: NullableIntFieldUpdateOperationsInput | number | null
    yieldPotential?: NullableStringFieldUpdateOperationsInput | string | null
    droughtTolerance?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    storageTemperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    quantityAvailable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: GermplasmUpdatephotosInput | string[]
    documents?: GermplasmUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeedLotCreateInput = {
    id?: string
    lotNumber: string
    initialQuantity: Decimal | DecimalJsLike | number | string
    currentQuantity: Decimal | DecimalJsLike | number | string
    quantityUnit: string
    seedCount?: number | null
    thousandSeedWeight?: Decimal | DecimalJsLike | number | string | null
    qualityGrade?: $Enums.SeedQualityGrade
    germinationRate?: Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: Date | string | null
    purityPercentage?: Decimal | DecimalJsLike | number | string | null
    moistureContent?: Decimal | DecimalJsLike | number | string | null
    vigorIndex?: Decimal | DecimalJsLike | number | string | null
    productionDate?: Date | string | null
    harvestDate?: Date | string | null
    productionLocation?: string | null
    productionSeason?: string | null
    producedBy?: string | null
    certificationNumber?: string | null
    certifiedBy?: string | null
    certificationDate?: Date | string | null
    expiryDate?: Date | string | null
    isTreated?: boolean
    treatmentType?: string | null
    treatmentProduct?: string | null
    treatmentDate?: Date | string | null
    storageLocation?: string | null
    storageConditions?: string | null
    notes?: string | null
    notesAr?: string | null
    photos?: SeedLotCreatephotosInput | string[]
    documents?: SeedLotCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    germplasm: GermplasmCreateNestedOneWithoutSeedLotsInput
    plantings?: PlantingCreateNestedManyWithoutSeedLotInput
  }

  export type SeedLotUncheckedCreateInput = {
    id?: string
    germplasmId: string
    lotNumber: string
    initialQuantity: Decimal | DecimalJsLike | number | string
    currentQuantity: Decimal | DecimalJsLike | number | string
    quantityUnit: string
    seedCount?: number | null
    thousandSeedWeight?: Decimal | DecimalJsLike | number | string | null
    qualityGrade?: $Enums.SeedQualityGrade
    germinationRate?: Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: Date | string | null
    purityPercentage?: Decimal | DecimalJsLike | number | string | null
    moistureContent?: Decimal | DecimalJsLike | number | string | null
    vigorIndex?: Decimal | DecimalJsLike | number | string | null
    productionDate?: Date | string | null
    harvestDate?: Date | string | null
    productionLocation?: string | null
    productionSeason?: string | null
    producedBy?: string | null
    certificationNumber?: string | null
    certifiedBy?: string | null
    certificationDate?: Date | string | null
    expiryDate?: Date | string | null
    isTreated?: boolean
    treatmentType?: string | null
    treatmentProduct?: string | null
    treatmentDate?: Date | string | null
    storageLocation?: string | null
    storageConditions?: string | null
    notes?: string | null
    notesAr?: string | null
    photos?: SeedLotCreatephotosInput | string[]
    documents?: SeedLotCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plantings?: PlantingUncheckedCreateNestedManyWithoutSeedLotInput
  }

  export type SeedLotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    initialQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFieldUpdateOperationsInput | string
    seedCount?: NullableIntFieldUpdateOperationsInput | number | null
    thousandSeedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFieldUpdateOperationsInput | $Enums.SeedQualityGrade
    germinationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purityPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moistureContent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    productionSeason?: NullableStringFieldUpdateOperationsInput | string | null
    producedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    treatmentType?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentProduct?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SeedLotUpdatephotosInput | string[]
    documents?: SeedLotUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    germplasm?: GermplasmUpdateOneRequiredWithoutSeedLotsNestedInput
    plantings?: PlantingUpdateManyWithoutSeedLotNestedInput
  }

  export type SeedLotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    germplasmId?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    initialQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFieldUpdateOperationsInput | string
    seedCount?: NullableIntFieldUpdateOperationsInput | number | null
    thousandSeedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFieldUpdateOperationsInput | $Enums.SeedQualityGrade
    germinationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purityPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moistureContent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    productionSeason?: NullableStringFieldUpdateOperationsInput | string | null
    producedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    treatmentType?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentProduct?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SeedLotUpdatephotosInput | string[]
    documents?: SeedLotUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantings?: PlantingUncheckedUpdateManyWithoutSeedLotNestedInput
  }

  export type SeedLotCreateManyInput = {
    id?: string
    germplasmId: string
    lotNumber: string
    initialQuantity: Decimal | DecimalJsLike | number | string
    currentQuantity: Decimal | DecimalJsLike | number | string
    quantityUnit: string
    seedCount?: number | null
    thousandSeedWeight?: Decimal | DecimalJsLike | number | string | null
    qualityGrade?: $Enums.SeedQualityGrade
    germinationRate?: Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: Date | string | null
    purityPercentage?: Decimal | DecimalJsLike | number | string | null
    moistureContent?: Decimal | DecimalJsLike | number | string | null
    vigorIndex?: Decimal | DecimalJsLike | number | string | null
    productionDate?: Date | string | null
    harvestDate?: Date | string | null
    productionLocation?: string | null
    productionSeason?: string | null
    producedBy?: string | null
    certificationNumber?: string | null
    certifiedBy?: string | null
    certificationDate?: Date | string | null
    expiryDate?: Date | string | null
    isTreated?: boolean
    treatmentType?: string | null
    treatmentProduct?: string | null
    treatmentDate?: Date | string | null
    storageLocation?: string | null
    storageConditions?: string | null
    notes?: string | null
    notesAr?: string | null
    photos?: SeedLotCreatephotosInput | string[]
    documents?: SeedLotCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeedLotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    initialQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFieldUpdateOperationsInput | string
    seedCount?: NullableIntFieldUpdateOperationsInput | number | null
    thousandSeedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFieldUpdateOperationsInput | $Enums.SeedQualityGrade
    germinationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purityPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moistureContent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    productionSeason?: NullableStringFieldUpdateOperationsInput | string | null
    producedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    treatmentType?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentProduct?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SeedLotUpdatephotosInput | string[]
    documents?: SeedLotUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeedLotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    germplasmId?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    initialQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFieldUpdateOperationsInput | string
    seedCount?: NullableIntFieldUpdateOperationsInput | number | null
    thousandSeedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFieldUpdateOperationsInput | $Enums.SeedQualityGrade
    germinationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purityPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moistureContent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    productionSeason?: NullableStringFieldUpdateOperationsInput | string | null
    producedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    treatmentType?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentProduct?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SeedLotUpdatephotosInput | string[]
    documents?: SeedLotUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantingCreateInput = {
    id?: string
    plotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutPlantingsInput
    germplasm: GermplasmCreateNestedOneWithoutPlantingsInput
    seedLot?: SeedLotCreateNestedOneWithoutPlantingsInput
  }

  export type PlantingUncheckedCreateInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    germplasmId: string
    seedLotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutPlantingsNestedInput
    germplasm?: GermplasmUpdateOneRequiredWithoutPlantingsNestedInput
    seedLot?: SeedLotUpdateOneWithoutPlantingsNestedInput
  }

  export type PlantingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    germplasmId?: StringFieldUpdateOperationsInput | string
    seedLotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantingCreateManyInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    germplasmId: string
    seedLotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    germplasmId?: StringFieldUpdateOperationsInput | string
    seedLotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentCreateInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogCreateNestedManyWithoutExperimentInput
    samples?: LabSampleCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogCreateNestedManyWithoutExperimentInput
    plantings?: PlantingCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUncheckedCreateInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolUncheckedCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotUncheckedCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentUncheckedCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutExperimentInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorUncheckedCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogUncheckedCreateNestedManyWithoutExperimentInput
    plantings?: PlantingUncheckedCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUncheckedUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUncheckedUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUncheckedUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUncheckedUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUncheckedUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentCreateManyInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
  }

  export type ExperimentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ExperimentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type ResearchProtocolCreateInput = {
    id?: string
    name: string
    nameAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    methodology: string
    methodologyAr?: string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolCreateequipmentRequiredInput | string[]
    safetyGuidelines?: string | null
    version?: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutProtocolsInput
  }

  export type ResearchProtocolUncheckedCreateInput = {
    id?: string
    experimentId: string
    name: string
    nameAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    methodology: string
    methodologyAr?: string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolCreateequipmentRequiredInput | string[]
    safetyGuidelines?: string | null
    version?: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchProtocolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: StringFieldUpdateOperationsInput | string
    methodologyAr?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolUpdateequipmentRequiredInput | string[]
    safetyGuidelines?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutProtocolsNestedInput
  }

  export type ResearchProtocolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: StringFieldUpdateOperationsInput | string
    methodologyAr?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolUpdateequipmentRequiredInput | string[]
    safetyGuidelines?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProtocolCreateManyInput = {
    id?: string
    experimentId: string
    name: string
    nameAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    methodology: string
    methodologyAr?: string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolCreateequipmentRequiredInput | string[]
    safetyGuidelines?: string | null
    version?: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchProtocolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: StringFieldUpdateOperationsInput | string
    methodologyAr?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolUpdateequipmentRequiredInput | string[]
    safetyGuidelines?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProtocolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: StringFieldUpdateOperationsInput | string
    methodologyAr?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolUpdateequipmentRequiredInput | string[]
    safetyGuidelines?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchPlotCreateInput = {
    id?: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutPlotsInput
    treatments?: TreatmentCreateNestedManyWithoutPlotInput
    logs?: ResearchDailyLogCreateNestedManyWithoutPlotInput
    samples?: LabSampleCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotUncheckedCreateInput = {
    id?: string
    experimentId: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    treatments?: TreatmentUncheckedCreateNestedManyWithoutPlotInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutPlotInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutPlotsNestedInput
    treatments?: TreatmentUpdateManyWithoutPlotNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutPlotNestedInput
    samples?: LabSampleUpdateManyWithoutPlotNestedInput
  }

  export type ResearchPlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treatments?: TreatmentUncheckedUpdateManyWithoutPlotNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutPlotNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutPlotNestedInput
  }

  export type ResearchPlotCreateManyInput = {
    id?: string
    experimentId: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchPlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchPlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentCreateInput = {
    id?: string
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutTreatmentsInput
    plot?: ResearchPlotCreateNestedOneWithoutTreatmentsInput
    logs?: ResearchDailyLogCreateNestedManyWithoutTreatmentInput
  }

  export type TreatmentUncheckedCreateInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutTreatmentInput
  }

  export type TreatmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutTreatmentsNestedInput
    plot?: ResearchPlotUpdateOneWithoutTreatmentsNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutTreatmentNestedInput
  }

  export type TreatmentCreateManyInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TreatmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchDailyLogCreateInput = {
    id?: string
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutLogsInput
    plot?: ResearchPlotCreateNestedOneWithoutLogsInput
    treatment?: TreatmentCreateNestedOneWithoutLogsInput
    samples?: LabSampleCreateNestedManyWithoutLogInput
  }

  export type ResearchDailyLogUncheckedCreateInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    treatmentId?: string | null
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: LabSampleUncheckedCreateNestedManyWithoutLogInput
  }

  export type ResearchDailyLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutLogsNestedInput
    plot?: ResearchPlotUpdateOneWithoutLogsNestedInput
    treatment?: TreatmentUpdateOneWithoutLogsNestedInput
    samples?: LabSampleUpdateManyWithoutLogNestedInput
  }

  export type ResearchDailyLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentId?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: LabSampleUncheckedUpdateManyWithoutLogNestedInput
  }

  export type ResearchDailyLogCreateManyInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    treatmentId?: string | null
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchDailyLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchDailyLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentId?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleCreateInput = {
    id?: string
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutSamplesInput
    plot?: ResearchPlotCreateNestedOneWithoutSamplesInput
    log?: ResearchDailyLogCreateNestedOneWithoutSamplesInput
  }

  export type LabSampleUncheckedCreateInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    logId?: string | null
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabSampleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutSamplesNestedInput
    plot?: ResearchPlotUpdateOneWithoutSamplesNestedInput
    log?: ResearchDailyLogUpdateOneWithoutSamplesNestedInput
  }

  export type LabSampleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    logId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleCreateManyInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    logId?: string | null
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabSampleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    logId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DigitalSignatureCreateInput = {
    id?: string
    entityType: string
    entityId: string
    signerId: string
    signatureHash: string
    algorithm?: string
    payloadHash: string
    timestamp?: Date | string
    ipAddress?: string | null
    deviceInfo?: JsonNullValueInput | InputJsonValue
    purpose?: string | null
    isValid?: boolean
    invalidatedAt?: Date | string | null
    invalidatedReason?: string | null
    createdAt?: Date | string
  }

  export type DigitalSignatureUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    signerId: string
    signatureHash: string
    algorithm?: string
    payloadHash: string
    timestamp?: Date | string
    ipAddress?: string | null
    deviceInfo?: JsonNullValueInput | InputJsonValue
    purpose?: string | null
    isValid?: boolean
    invalidatedAt?: Date | string | null
    invalidatedReason?: string | null
    createdAt?: Date | string
  }

  export type DigitalSignatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    signerId?: StringFieldUpdateOperationsInput | string
    signatureHash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    payloadHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: JsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidatedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DigitalSignatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    signerId?: StringFieldUpdateOperationsInput | string
    signatureHash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    payloadHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: JsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidatedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DigitalSignatureCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    signerId: string
    signatureHash: string
    algorithm?: string
    payloadHash: string
    timestamp?: Date | string
    ipAddress?: string | null
    deviceInfo?: JsonNullValueInput | InputJsonValue
    purpose?: string | null
    isValid?: boolean
    invalidatedAt?: Date | string | null
    invalidatedReason?: string | null
    createdAt?: Date | string
  }

  export type DigitalSignatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    signerId?: StringFieldUpdateOperationsInput | string
    signatureHash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    payloadHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: JsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidatedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DigitalSignatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    signerId?: StringFieldUpdateOperationsInput | string
    signatureHash?: StringFieldUpdateOperationsInput | string
    algorithm?: StringFieldUpdateOperationsInput | string
    payloadHash?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: JsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    invalidatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidatedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentCollaboratorCreateInput = {
    id?: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutCollaboratorsInput
  }

  export type ExperimentCollaboratorUncheckedCreateInput = {
    id?: string
    experimentId: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ExperimentCollaboratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutCollaboratorsNestedInput
  }

  export type ExperimentCollaboratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentCollaboratorCreateManyInput = {
    id?: string
    experimentId: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ExperimentCollaboratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentCollaboratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentAuditLogCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy: string
    changedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    experiment?: ExperimentCreateNestedOneWithoutAuditLogsInput
  }

  export type ExperimentAuditLogUncheckedCreateInput = {
    id?: string
    experimentId?: string | null
    entityType: string
    entityId: string
    action: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy: string
    changedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ExperimentAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    experiment?: ExperimentUpdateOneWithoutAuditLogsNestedInput
  }

  export type ExperimentAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExperimentAuditLogCreateManyInput = {
    id?: string
    experimentId?: string | null
    entityType: string
    entityId: string
    action: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy: string
    changedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ExperimentAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExperimentAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGermplasmTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GermplasmType | EnumGermplasmTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GermplasmType[] | ListEnumGermplasmTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GermplasmType[] | ListEnumGermplasmTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGermplasmTypeFilter<$PrismaModel> | $Enums.GermplasmType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SeedLotListRelationFilter = {
    every?: SeedLotWhereInput
    some?: SeedLotWhereInput
    none?: SeedLotWhereInput
  }

  export type PlantingListRelationFilter = {
    every?: PlantingWhereInput
    some?: PlantingWhereInput
    none?: PlantingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SeedLotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlantingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GermplasmCountOrderByAggregateInput = {
    id?: SortOrder
    accessionNumber?: SortOrder
    commonName?: SortOrder
    commonNameAr?: SortOrder
    scientificName?: SortOrder
    genus?: SortOrder
    species?: SortOrder
    subspecies?: SortOrder
    cultivar?: SortOrder
    variety?: SortOrder
    pedigree?: SortOrder
    type?: SortOrder
    countryOfOrigin?: SortOrder
    regionOfOrigin?: SortOrder
    collectionSite?: SortOrder
    collectionDate?: SortOrder
    collectedBy?: SortOrder
    donorInstitution?: SortOrder
    donorAccessionNumber?: SortOrder
    growthHabit?: SortOrder
    maturityDays?: SortOrder
    yieldPotential?: SortOrder
    droughtTolerance?: SortOrder
    diseaseResistance?: SortOrder
    pestResistance?: SortOrder
    qualityTraits?: SortOrder
    storageLocation?: SortOrder
    storageConditions?: SortOrder
    storageTemperature?: SortOrder
    storageHumidity?: SortOrder
    isAvailable?: SortOrder
    quantityAvailable?: SortOrder
    quantityUnit?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    photos?: SortOrder
    documents?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GermplasmAvgOrderByAggregateInput = {
    maturityDays?: SortOrder
    storageTemperature?: SortOrder
    storageHumidity?: SortOrder
    quantityAvailable?: SortOrder
  }

  export type GermplasmMaxOrderByAggregateInput = {
    id?: SortOrder
    accessionNumber?: SortOrder
    commonName?: SortOrder
    commonNameAr?: SortOrder
    scientificName?: SortOrder
    genus?: SortOrder
    species?: SortOrder
    subspecies?: SortOrder
    cultivar?: SortOrder
    variety?: SortOrder
    pedigree?: SortOrder
    type?: SortOrder
    countryOfOrigin?: SortOrder
    regionOfOrigin?: SortOrder
    collectionSite?: SortOrder
    collectionDate?: SortOrder
    collectedBy?: SortOrder
    donorInstitution?: SortOrder
    donorAccessionNumber?: SortOrder
    growthHabit?: SortOrder
    maturityDays?: SortOrder
    yieldPotential?: SortOrder
    droughtTolerance?: SortOrder
    storageLocation?: SortOrder
    storageConditions?: SortOrder
    storageTemperature?: SortOrder
    storageHumidity?: SortOrder
    isAvailable?: SortOrder
    quantityAvailable?: SortOrder
    quantityUnit?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GermplasmMinOrderByAggregateInput = {
    id?: SortOrder
    accessionNumber?: SortOrder
    commonName?: SortOrder
    commonNameAr?: SortOrder
    scientificName?: SortOrder
    genus?: SortOrder
    species?: SortOrder
    subspecies?: SortOrder
    cultivar?: SortOrder
    variety?: SortOrder
    pedigree?: SortOrder
    type?: SortOrder
    countryOfOrigin?: SortOrder
    regionOfOrigin?: SortOrder
    collectionSite?: SortOrder
    collectionDate?: SortOrder
    collectedBy?: SortOrder
    donorInstitution?: SortOrder
    donorAccessionNumber?: SortOrder
    growthHabit?: SortOrder
    maturityDays?: SortOrder
    yieldPotential?: SortOrder
    droughtTolerance?: SortOrder
    storageLocation?: SortOrder
    storageConditions?: SortOrder
    storageTemperature?: SortOrder
    storageHumidity?: SortOrder
    isAvailable?: SortOrder
    quantityAvailable?: SortOrder
    quantityUnit?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GermplasmSumOrderByAggregateInput = {
    maturityDays?: SortOrder
    storageTemperature?: SortOrder
    storageHumidity?: SortOrder
    quantityAvailable?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGermplasmTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GermplasmType | EnumGermplasmTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GermplasmType[] | ListEnumGermplasmTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GermplasmType[] | ListEnumGermplasmTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGermplasmTypeWithAggregatesFilter<$PrismaModel> | $Enums.GermplasmType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGermplasmTypeFilter<$PrismaModel>
    _max?: NestedEnumGermplasmTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumSeedQualityGradeFilter<$PrismaModel = never> = {
    equals?: $Enums.SeedQualityGrade | EnumSeedQualityGradeFieldRefInput<$PrismaModel>
    in?: $Enums.SeedQualityGrade[] | ListEnumSeedQualityGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeedQualityGrade[] | ListEnumSeedQualityGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumSeedQualityGradeFilter<$PrismaModel> | $Enums.SeedQualityGrade
  }

  export type GermplasmRelationFilter = {
    is?: GermplasmWhereInput
    isNot?: GermplasmWhereInput
  }

  export type SeedLotCountOrderByAggregateInput = {
    id?: SortOrder
    germplasmId?: SortOrder
    lotNumber?: SortOrder
    initialQuantity?: SortOrder
    currentQuantity?: SortOrder
    quantityUnit?: SortOrder
    seedCount?: SortOrder
    thousandSeedWeight?: SortOrder
    qualityGrade?: SortOrder
    germinationRate?: SortOrder
    germinationTestDate?: SortOrder
    purityPercentage?: SortOrder
    moistureContent?: SortOrder
    vigorIndex?: SortOrder
    productionDate?: SortOrder
    harvestDate?: SortOrder
    productionLocation?: SortOrder
    productionSeason?: SortOrder
    producedBy?: SortOrder
    certificationNumber?: SortOrder
    certifiedBy?: SortOrder
    certificationDate?: SortOrder
    expiryDate?: SortOrder
    isTreated?: SortOrder
    treatmentType?: SortOrder
    treatmentProduct?: SortOrder
    treatmentDate?: SortOrder
    storageLocation?: SortOrder
    storageConditions?: SortOrder
    notes?: SortOrder
    notesAr?: SortOrder
    photos?: SortOrder
    documents?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeedLotAvgOrderByAggregateInput = {
    initialQuantity?: SortOrder
    currentQuantity?: SortOrder
    seedCount?: SortOrder
    thousandSeedWeight?: SortOrder
    germinationRate?: SortOrder
    purityPercentage?: SortOrder
    moistureContent?: SortOrder
    vigorIndex?: SortOrder
  }

  export type SeedLotMaxOrderByAggregateInput = {
    id?: SortOrder
    germplasmId?: SortOrder
    lotNumber?: SortOrder
    initialQuantity?: SortOrder
    currentQuantity?: SortOrder
    quantityUnit?: SortOrder
    seedCount?: SortOrder
    thousandSeedWeight?: SortOrder
    qualityGrade?: SortOrder
    germinationRate?: SortOrder
    germinationTestDate?: SortOrder
    purityPercentage?: SortOrder
    moistureContent?: SortOrder
    vigorIndex?: SortOrder
    productionDate?: SortOrder
    harvestDate?: SortOrder
    productionLocation?: SortOrder
    productionSeason?: SortOrder
    producedBy?: SortOrder
    certificationNumber?: SortOrder
    certifiedBy?: SortOrder
    certificationDate?: SortOrder
    expiryDate?: SortOrder
    isTreated?: SortOrder
    treatmentType?: SortOrder
    treatmentProduct?: SortOrder
    treatmentDate?: SortOrder
    storageLocation?: SortOrder
    storageConditions?: SortOrder
    notes?: SortOrder
    notesAr?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeedLotMinOrderByAggregateInput = {
    id?: SortOrder
    germplasmId?: SortOrder
    lotNumber?: SortOrder
    initialQuantity?: SortOrder
    currentQuantity?: SortOrder
    quantityUnit?: SortOrder
    seedCount?: SortOrder
    thousandSeedWeight?: SortOrder
    qualityGrade?: SortOrder
    germinationRate?: SortOrder
    germinationTestDate?: SortOrder
    purityPercentage?: SortOrder
    moistureContent?: SortOrder
    vigorIndex?: SortOrder
    productionDate?: SortOrder
    harvestDate?: SortOrder
    productionLocation?: SortOrder
    productionSeason?: SortOrder
    producedBy?: SortOrder
    certificationNumber?: SortOrder
    certifiedBy?: SortOrder
    certificationDate?: SortOrder
    expiryDate?: SortOrder
    isTreated?: SortOrder
    treatmentType?: SortOrder
    treatmentProduct?: SortOrder
    treatmentDate?: SortOrder
    storageLocation?: SortOrder
    storageConditions?: SortOrder
    notes?: SortOrder
    notesAr?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeedLotSumOrderByAggregateInput = {
    initialQuantity?: SortOrder
    currentQuantity?: SortOrder
    seedCount?: SortOrder
    thousandSeedWeight?: SortOrder
    germinationRate?: SortOrder
    purityPercentage?: SortOrder
    moistureContent?: SortOrder
    vigorIndex?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumSeedQualityGradeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeedQualityGrade | EnumSeedQualityGradeFieldRefInput<$PrismaModel>
    in?: $Enums.SeedQualityGrade[] | ListEnumSeedQualityGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeedQualityGrade[] | ListEnumSeedQualityGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumSeedQualityGradeWithAggregatesFilter<$PrismaModel> | $Enums.SeedQualityGrade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeedQualityGradeFilter<$PrismaModel>
    _max?: NestedEnumSeedQualityGradeFilter<$PrismaModel>
  }

  export type ExperimentRelationFilter = {
    is?: ExperimentWhereInput
    isNot?: ExperimentWhereInput
  }

  export type SeedLotNullableRelationFilter = {
    is?: SeedLotWhereInput | null
    isNot?: SeedLotWhereInput | null
  }

  export type PlantingCountOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    germplasmId?: SortOrder
    seedLotId?: SortOrder
    plantingDate?: SortOrder
    plantingMethod?: SortOrder
    seedingRate?: SortOrder
    seedingRateUnit?: SortOrder
    seedsPerHill?: SortOrder
    seedDepth?: SortOrder
    seedDepthUnit?: SortOrder
    rowSpacing?: SortOrder
    plantSpacing?: SortOrder
    spacingUnit?: SortOrder
    plantedArea?: SortOrder
    plantedAreaUnit?: SortOrder
    numberOfRows?: SortOrder
    plantsPerRow?: SortOrder
    totalPlantsExpected?: SortOrder
    germinationDate?: SortOrder
    emergenceDate?: SortOrder
    germinationCount?: SortOrder
    germinationPercentage?: SortOrder
    thinningDate?: SortOrder
    finalPlantCount?: SortOrder
    plantedBy?: SortOrder
    notes?: SortOrder
    notesAr?: SortOrder
    photos?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlantingAvgOrderByAggregateInput = {
    seedingRate?: SortOrder
    seedsPerHill?: SortOrder
    seedDepth?: SortOrder
    rowSpacing?: SortOrder
    plantSpacing?: SortOrder
    plantedArea?: SortOrder
    numberOfRows?: SortOrder
    plantsPerRow?: SortOrder
    totalPlantsExpected?: SortOrder
    germinationCount?: SortOrder
    germinationPercentage?: SortOrder
    finalPlantCount?: SortOrder
  }

  export type PlantingMaxOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    germplasmId?: SortOrder
    seedLotId?: SortOrder
    plantingDate?: SortOrder
    plantingMethod?: SortOrder
    seedingRate?: SortOrder
    seedingRateUnit?: SortOrder
    seedsPerHill?: SortOrder
    seedDepth?: SortOrder
    seedDepthUnit?: SortOrder
    rowSpacing?: SortOrder
    plantSpacing?: SortOrder
    spacingUnit?: SortOrder
    plantedArea?: SortOrder
    plantedAreaUnit?: SortOrder
    numberOfRows?: SortOrder
    plantsPerRow?: SortOrder
    totalPlantsExpected?: SortOrder
    germinationDate?: SortOrder
    emergenceDate?: SortOrder
    germinationCount?: SortOrder
    germinationPercentage?: SortOrder
    thinningDate?: SortOrder
    finalPlantCount?: SortOrder
    plantedBy?: SortOrder
    notes?: SortOrder
    notesAr?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlantingMinOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    germplasmId?: SortOrder
    seedLotId?: SortOrder
    plantingDate?: SortOrder
    plantingMethod?: SortOrder
    seedingRate?: SortOrder
    seedingRateUnit?: SortOrder
    seedsPerHill?: SortOrder
    seedDepth?: SortOrder
    seedDepthUnit?: SortOrder
    rowSpacing?: SortOrder
    plantSpacing?: SortOrder
    spacingUnit?: SortOrder
    plantedArea?: SortOrder
    plantedAreaUnit?: SortOrder
    numberOfRows?: SortOrder
    plantsPerRow?: SortOrder
    totalPlantsExpected?: SortOrder
    germinationDate?: SortOrder
    emergenceDate?: SortOrder
    germinationCount?: SortOrder
    germinationPercentage?: SortOrder
    thinningDate?: SortOrder
    finalPlantCount?: SortOrder
    plantedBy?: SortOrder
    notes?: SortOrder
    notesAr?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlantingSumOrderByAggregateInput = {
    seedingRate?: SortOrder
    seedsPerHill?: SortOrder
    seedDepth?: SortOrder
    rowSpacing?: SortOrder
    plantSpacing?: SortOrder
    plantedArea?: SortOrder
    numberOfRows?: SortOrder
    plantsPerRow?: SortOrder
    totalPlantsExpected?: SortOrder
    germinationCount?: SortOrder
    germinationPercentage?: SortOrder
    finalPlantCount?: SortOrder
  }

  export type EnumExperimentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExperimentStatus | EnumExperimentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExperimentStatus[] | ListEnumExperimentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExperimentStatus[] | ListEnumExperimentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExperimentStatusFilter<$PrismaModel> | $Enums.ExperimentStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ResearchProtocolListRelationFilter = {
    every?: ResearchProtocolWhereInput
    some?: ResearchProtocolWhereInput
    none?: ResearchProtocolWhereInput
  }

  export type ResearchPlotListRelationFilter = {
    every?: ResearchPlotWhereInput
    some?: ResearchPlotWhereInput
    none?: ResearchPlotWhereInput
  }

  export type TreatmentListRelationFilter = {
    every?: TreatmentWhereInput
    some?: TreatmentWhereInput
    none?: TreatmentWhereInput
  }

  export type ResearchDailyLogListRelationFilter = {
    every?: ResearchDailyLogWhereInput
    some?: ResearchDailyLogWhereInput
    none?: ResearchDailyLogWhereInput
  }

  export type LabSampleListRelationFilter = {
    every?: LabSampleWhereInput
    some?: LabSampleWhereInput
    none?: LabSampleWhereInput
  }

  export type ExperimentCollaboratorListRelationFilter = {
    every?: ExperimentCollaboratorWhereInput
    some?: ExperimentCollaboratorWhereInput
    none?: ExperimentCollaboratorWhereInput
  }

  export type ExperimentAuditLogListRelationFilter = {
    every?: ExperimentAuditLogWhereInput
    some?: ExperimentAuditLogWhereInput
    none?: ExperimentAuditLogWhereInput
  }

  export type ResearchProtocolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchPlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TreatmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchDailyLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabSampleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExperimentCollaboratorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExperimentAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExperimentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleAr?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    hypothesis?: SortOrder
    hypothesisAr?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
    principalResearcherId?: SortOrder
    organizationId?: SortOrder
    farmId?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
  }

  export type ExperimentAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ExperimentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleAr?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    hypothesis?: SortOrder
    hypothesisAr?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
    principalResearcherId?: SortOrder
    organizationId?: SortOrder
    farmId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
  }

  export type ExperimentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    titleAr?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    hypothesis?: SortOrder
    hypothesisAr?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    lockedAt?: SortOrder
    lockedBy?: SortOrder
    principalResearcherId?: SortOrder
    organizationId?: SortOrder
    farmId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    version?: SortOrder
  }

  export type ExperimentSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumExperimentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExperimentStatus | EnumExperimentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExperimentStatus[] | ListEnumExperimentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExperimentStatus[] | ListEnumExperimentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExperimentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExperimentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExperimentStatusFilter<$PrismaModel>
    _max?: NestedEnumExperimentStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ResearchProtocolCountOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    name?: SortOrder
    nameAr?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    methodology?: SortOrder
    methodologyAr?: SortOrder
    variables?: SortOrder
    measurementSchedule?: SortOrder
    equipmentRequired?: SortOrder
    safetyGuidelines?: SortOrder
    version?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchProtocolAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ResearchProtocolMaxOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    name?: SortOrder
    nameAr?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    methodology?: SortOrder
    methodologyAr?: SortOrder
    safetyGuidelines?: SortOrder
    version?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchProtocolMinOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    name?: SortOrder
    nameAr?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    methodology?: SortOrder
    methodologyAr?: SortOrder
    safetyGuidelines?: SortOrder
    version?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchProtocolSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ResearchPlotExperimentIdPlotCodeCompoundUniqueInput = {
    experimentId: string
    plotCode: string
  }

  export type ResearchPlotCountOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotCode?: SortOrder
    name?: SortOrder
    nameAr?: SortOrder
    areaSqm?: SortOrder
    soilType?: SortOrder
    soilPh?: SortOrder
    previousCrop?: SortOrder
    replicateNumber?: SortOrder
    blockNumber?: SortOrder
    rowNumber?: SortOrder
    columnNumber?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchPlotAvgOrderByAggregateInput = {
    areaSqm?: SortOrder
    soilPh?: SortOrder
    replicateNumber?: SortOrder
    blockNumber?: SortOrder
    rowNumber?: SortOrder
    columnNumber?: SortOrder
  }

  export type ResearchPlotMaxOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotCode?: SortOrder
    name?: SortOrder
    nameAr?: SortOrder
    areaSqm?: SortOrder
    soilType?: SortOrder
    soilPh?: SortOrder
    previousCrop?: SortOrder
    replicateNumber?: SortOrder
    blockNumber?: SortOrder
    rowNumber?: SortOrder
    columnNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchPlotMinOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotCode?: SortOrder
    name?: SortOrder
    nameAr?: SortOrder
    areaSqm?: SortOrder
    soilType?: SortOrder
    soilPh?: SortOrder
    previousCrop?: SortOrder
    replicateNumber?: SortOrder
    blockNumber?: SortOrder
    rowNumber?: SortOrder
    columnNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchPlotSumOrderByAggregateInput = {
    areaSqm?: SortOrder
    soilPh?: SortOrder
    replicateNumber?: SortOrder
    blockNumber?: SortOrder
    rowNumber?: SortOrder
    columnNumber?: SortOrder
  }

  export type EnumTreatmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TreatmentType | EnumTreatmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TreatmentType[] | ListEnumTreatmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreatmentType[] | ListEnumTreatmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTreatmentTypeFilter<$PrismaModel> | $Enums.TreatmentType
  }

  export type ResearchPlotNullableRelationFilter = {
    is?: ResearchPlotWhereInput | null
    isNot?: ResearchPlotWhereInput | null
  }

  export type TreatmentCountOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    treatmentCode?: SortOrder
    name?: SortOrder
    nameAr?: SortOrder
    type?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    dosage?: SortOrder
    dosageUnit?: SortOrder
    applicationMethod?: SortOrder
    applicationFrequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isControl?: SortOrder
    parameters?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TreatmentMaxOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    treatmentCode?: SortOrder
    name?: SortOrder
    nameAr?: SortOrder
    type?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    dosage?: SortOrder
    dosageUnit?: SortOrder
    applicationMethod?: SortOrder
    applicationFrequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isControl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TreatmentMinOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    treatmentCode?: SortOrder
    name?: SortOrder
    nameAr?: SortOrder
    type?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    dosage?: SortOrder
    dosageUnit?: SortOrder
    applicationMethod?: SortOrder
    applicationFrequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isControl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTreatmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TreatmentType | EnumTreatmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TreatmentType[] | ListEnumTreatmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreatmentType[] | ListEnumTreatmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTreatmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.TreatmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTreatmentTypeFilter<$PrismaModel>
    _max?: NestedEnumTreatmentTypeFilter<$PrismaModel>
  }

  export type EnumLogCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryFilter<$PrismaModel> | $Enums.LogCategory
  }

  export type TreatmentNullableRelationFilter = {
    is?: TreatmentWhereInput | null
    isNot?: TreatmentWhereInput | null
  }

  export type ResearchDailyLogCountOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    treatmentId?: SortOrder
    logDate?: SortOrder
    logTime?: SortOrder
    category?: SortOrder
    title?: SortOrder
    titleAr?: SortOrder
    notes?: SortOrder
    notesAr?: SortOrder
    measurements?: SortOrder
    weatherConditions?: SortOrder
    photos?: SortOrder
    attachments?: SortOrder
    recordedBy?: SortOrder
    deviceId?: SortOrder
    offlineId?: SortOrder
    hash?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchDailyLogMaxOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    treatmentId?: SortOrder
    logDate?: SortOrder
    logTime?: SortOrder
    category?: SortOrder
    title?: SortOrder
    titleAr?: SortOrder
    notes?: SortOrder
    notesAr?: SortOrder
    recordedBy?: SortOrder
    deviceId?: SortOrder
    offlineId?: SortOrder
    hash?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResearchDailyLogMinOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    treatmentId?: SortOrder
    logDate?: SortOrder
    logTime?: SortOrder
    category?: SortOrder
    title?: SortOrder
    titleAr?: SortOrder
    notes?: SortOrder
    notesAr?: SortOrder
    recordedBy?: SortOrder
    deviceId?: SortOrder
    offlineId?: SortOrder
    hash?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLogCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryWithAggregatesFilter<$PrismaModel> | $Enums.LogCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogCategoryFilter<$PrismaModel>
    _max?: NestedEnumLogCategoryFilter<$PrismaModel>
  }

  export type EnumSampleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleType | EnumSampleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleTypeFilter<$PrismaModel> | $Enums.SampleType
  }

  export type ResearchDailyLogNullableRelationFilter = {
    is?: ResearchDailyLogWhereInput | null
    isNot?: ResearchDailyLogWhereInput | null
  }

  export type LabSampleCountOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    logId?: SortOrder
    sampleCode?: SortOrder
    type?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    collectionDate?: SortOrder
    collectionTime?: SortOrder
    collectedBy?: SortOrder
    storageLocation?: SortOrder
    storageConditions?: SortOrder
    quantity?: SortOrder
    quantityUnit?: SortOrder
    analysisStatus?: SortOrder
    analysisResults?: SortOrder
    analyzedBy?: SortOrder
    analyzedAt?: SortOrder
    photos?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabSampleAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type LabSampleMaxOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    logId?: SortOrder
    sampleCode?: SortOrder
    type?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    collectionDate?: SortOrder
    collectionTime?: SortOrder
    collectedBy?: SortOrder
    storageLocation?: SortOrder
    storageConditions?: SortOrder
    quantity?: SortOrder
    quantityUnit?: SortOrder
    analysisStatus?: SortOrder
    analyzedBy?: SortOrder
    analyzedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabSampleMinOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    plotId?: SortOrder
    logId?: SortOrder
    sampleCode?: SortOrder
    type?: SortOrder
    description?: SortOrder
    descriptionAr?: SortOrder
    collectionDate?: SortOrder
    collectionTime?: SortOrder
    collectedBy?: SortOrder
    storageLocation?: SortOrder
    storageConditions?: SortOrder
    quantity?: SortOrder
    quantityUnit?: SortOrder
    analysisStatus?: SortOrder
    analyzedBy?: SortOrder
    analyzedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabSampleSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumSampleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleType | EnumSampleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleTypeWithAggregatesFilter<$PrismaModel> | $Enums.SampleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleTypeFilter<$PrismaModel>
    _max?: NestedEnumSampleTypeFilter<$PrismaModel>
  }

  export type DigitalSignatureEntityTypeEntityIdSignerIdPurposeCompoundUniqueInput = {
    entityType: string
    entityId: string
    signerId: string
    purpose: string
  }

  export type DigitalSignatureCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    signerId?: SortOrder
    signatureHash?: SortOrder
    algorithm?: SortOrder
    payloadHash?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    deviceInfo?: SortOrder
    purpose?: SortOrder
    isValid?: SortOrder
    invalidatedAt?: SortOrder
    invalidatedReason?: SortOrder
    createdAt?: SortOrder
  }

  export type DigitalSignatureMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    signerId?: SortOrder
    signatureHash?: SortOrder
    algorithm?: SortOrder
    payloadHash?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    purpose?: SortOrder
    isValid?: SortOrder
    invalidatedAt?: SortOrder
    invalidatedReason?: SortOrder
    createdAt?: SortOrder
  }

  export type DigitalSignatureMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    signerId?: SortOrder
    signatureHash?: SortOrder
    algorithm?: SortOrder
    payloadHash?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    purpose?: SortOrder
    isValid?: SortOrder
    invalidatedAt?: SortOrder
    invalidatedReason?: SortOrder
    createdAt?: SortOrder
  }

  export type ExperimentCollaboratorExperimentIdUserIdCompoundUniqueInput = {
    experimentId: string
    userId: string
  }

  export type ExperimentCollaboratorCountOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ExperimentCollaboratorMaxOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ExperimentCollaboratorMinOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ExperimentNullableRelationFilter = {
    is?: ExperimentWhereInput | null
    isNot?: ExperimentWhereInput | null
  }

  export type ExperimentAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type ExperimentAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type ExperimentAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    experimentId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type GermplasmCreatephotosInput = {
    set: string[]
  }

  export type GermplasmCreatedocumentsInput = {
    set: string[]
  }

  export type SeedLotCreateNestedManyWithoutGermplasmInput = {
    create?: XOR<SeedLotCreateWithoutGermplasmInput, SeedLotUncheckedCreateWithoutGermplasmInput> | SeedLotCreateWithoutGermplasmInput[] | SeedLotUncheckedCreateWithoutGermplasmInput[]
    connectOrCreate?: SeedLotCreateOrConnectWithoutGermplasmInput | SeedLotCreateOrConnectWithoutGermplasmInput[]
    createMany?: SeedLotCreateManyGermplasmInputEnvelope
    connect?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
  }

  export type PlantingCreateNestedManyWithoutGermplasmInput = {
    create?: XOR<PlantingCreateWithoutGermplasmInput, PlantingUncheckedCreateWithoutGermplasmInput> | PlantingCreateWithoutGermplasmInput[] | PlantingUncheckedCreateWithoutGermplasmInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutGermplasmInput | PlantingCreateOrConnectWithoutGermplasmInput[]
    createMany?: PlantingCreateManyGermplasmInputEnvelope
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
  }

  export type SeedLotUncheckedCreateNestedManyWithoutGermplasmInput = {
    create?: XOR<SeedLotCreateWithoutGermplasmInput, SeedLotUncheckedCreateWithoutGermplasmInput> | SeedLotCreateWithoutGermplasmInput[] | SeedLotUncheckedCreateWithoutGermplasmInput[]
    connectOrCreate?: SeedLotCreateOrConnectWithoutGermplasmInput | SeedLotCreateOrConnectWithoutGermplasmInput[]
    createMany?: SeedLotCreateManyGermplasmInputEnvelope
    connect?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
  }

  export type PlantingUncheckedCreateNestedManyWithoutGermplasmInput = {
    create?: XOR<PlantingCreateWithoutGermplasmInput, PlantingUncheckedCreateWithoutGermplasmInput> | PlantingCreateWithoutGermplasmInput[] | PlantingUncheckedCreateWithoutGermplasmInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutGermplasmInput | PlantingCreateOrConnectWithoutGermplasmInput[]
    createMany?: PlantingCreateManyGermplasmInputEnvelope
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumGermplasmTypeFieldUpdateOperationsInput = {
    set?: $Enums.GermplasmType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type GermplasmUpdatephotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GermplasmUpdatedocumentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SeedLotUpdateManyWithoutGermplasmNestedInput = {
    create?: XOR<SeedLotCreateWithoutGermplasmInput, SeedLotUncheckedCreateWithoutGermplasmInput> | SeedLotCreateWithoutGermplasmInput[] | SeedLotUncheckedCreateWithoutGermplasmInput[]
    connectOrCreate?: SeedLotCreateOrConnectWithoutGermplasmInput | SeedLotCreateOrConnectWithoutGermplasmInput[]
    upsert?: SeedLotUpsertWithWhereUniqueWithoutGermplasmInput | SeedLotUpsertWithWhereUniqueWithoutGermplasmInput[]
    createMany?: SeedLotCreateManyGermplasmInputEnvelope
    set?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
    disconnect?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
    delete?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
    connect?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
    update?: SeedLotUpdateWithWhereUniqueWithoutGermplasmInput | SeedLotUpdateWithWhereUniqueWithoutGermplasmInput[]
    updateMany?: SeedLotUpdateManyWithWhereWithoutGermplasmInput | SeedLotUpdateManyWithWhereWithoutGermplasmInput[]
    deleteMany?: SeedLotScalarWhereInput | SeedLotScalarWhereInput[]
  }

  export type PlantingUpdateManyWithoutGermplasmNestedInput = {
    create?: XOR<PlantingCreateWithoutGermplasmInput, PlantingUncheckedCreateWithoutGermplasmInput> | PlantingCreateWithoutGermplasmInput[] | PlantingUncheckedCreateWithoutGermplasmInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutGermplasmInput | PlantingCreateOrConnectWithoutGermplasmInput[]
    upsert?: PlantingUpsertWithWhereUniqueWithoutGermplasmInput | PlantingUpsertWithWhereUniqueWithoutGermplasmInput[]
    createMany?: PlantingCreateManyGermplasmInputEnvelope
    set?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    disconnect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    delete?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    update?: PlantingUpdateWithWhereUniqueWithoutGermplasmInput | PlantingUpdateWithWhereUniqueWithoutGermplasmInput[]
    updateMany?: PlantingUpdateManyWithWhereWithoutGermplasmInput | PlantingUpdateManyWithWhereWithoutGermplasmInput[]
    deleteMany?: PlantingScalarWhereInput | PlantingScalarWhereInput[]
  }

  export type SeedLotUncheckedUpdateManyWithoutGermplasmNestedInput = {
    create?: XOR<SeedLotCreateWithoutGermplasmInput, SeedLotUncheckedCreateWithoutGermplasmInput> | SeedLotCreateWithoutGermplasmInput[] | SeedLotUncheckedCreateWithoutGermplasmInput[]
    connectOrCreate?: SeedLotCreateOrConnectWithoutGermplasmInput | SeedLotCreateOrConnectWithoutGermplasmInput[]
    upsert?: SeedLotUpsertWithWhereUniqueWithoutGermplasmInput | SeedLotUpsertWithWhereUniqueWithoutGermplasmInput[]
    createMany?: SeedLotCreateManyGermplasmInputEnvelope
    set?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
    disconnect?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
    delete?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
    connect?: SeedLotWhereUniqueInput | SeedLotWhereUniqueInput[]
    update?: SeedLotUpdateWithWhereUniqueWithoutGermplasmInput | SeedLotUpdateWithWhereUniqueWithoutGermplasmInput[]
    updateMany?: SeedLotUpdateManyWithWhereWithoutGermplasmInput | SeedLotUpdateManyWithWhereWithoutGermplasmInput[]
    deleteMany?: SeedLotScalarWhereInput | SeedLotScalarWhereInput[]
  }

  export type PlantingUncheckedUpdateManyWithoutGermplasmNestedInput = {
    create?: XOR<PlantingCreateWithoutGermplasmInput, PlantingUncheckedCreateWithoutGermplasmInput> | PlantingCreateWithoutGermplasmInput[] | PlantingUncheckedCreateWithoutGermplasmInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutGermplasmInput | PlantingCreateOrConnectWithoutGermplasmInput[]
    upsert?: PlantingUpsertWithWhereUniqueWithoutGermplasmInput | PlantingUpsertWithWhereUniqueWithoutGermplasmInput[]
    createMany?: PlantingCreateManyGermplasmInputEnvelope
    set?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    disconnect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    delete?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    update?: PlantingUpdateWithWhereUniqueWithoutGermplasmInput | PlantingUpdateWithWhereUniqueWithoutGermplasmInput[]
    updateMany?: PlantingUpdateManyWithWhereWithoutGermplasmInput | PlantingUpdateManyWithWhereWithoutGermplasmInput[]
    deleteMany?: PlantingScalarWhereInput | PlantingScalarWhereInput[]
  }

  export type SeedLotCreatephotosInput = {
    set: string[]
  }

  export type SeedLotCreatedocumentsInput = {
    set: string[]
  }

  export type GermplasmCreateNestedOneWithoutSeedLotsInput = {
    create?: XOR<GermplasmCreateWithoutSeedLotsInput, GermplasmUncheckedCreateWithoutSeedLotsInput>
    connectOrCreate?: GermplasmCreateOrConnectWithoutSeedLotsInput
    connect?: GermplasmWhereUniqueInput
  }

  export type PlantingCreateNestedManyWithoutSeedLotInput = {
    create?: XOR<PlantingCreateWithoutSeedLotInput, PlantingUncheckedCreateWithoutSeedLotInput> | PlantingCreateWithoutSeedLotInput[] | PlantingUncheckedCreateWithoutSeedLotInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutSeedLotInput | PlantingCreateOrConnectWithoutSeedLotInput[]
    createMany?: PlantingCreateManySeedLotInputEnvelope
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
  }

  export type PlantingUncheckedCreateNestedManyWithoutSeedLotInput = {
    create?: XOR<PlantingCreateWithoutSeedLotInput, PlantingUncheckedCreateWithoutSeedLotInput> | PlantingCreateWithoutSeedLotInput[] | PlantingUncheckedCreateWithoutSeedLotInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutSeedLotInput | PlantingCreateOrConnectWithoutSeedLotInput[]
    createMany?: PlantingCreateManySeedLotInputEnvelope
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumSeedQualityGradeFieldUpdateOperationsInput = {
    set?: $Enums.SeedQualityGrade
  }

  export type SeedLotUpdatephotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SeedLotUpdatedocumentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GermplasmUpdateOneRequiredWithoutSeedLotsNestedInput = {
    create?: XOR<GermplasmCreateWithoutSeedLotsInput, GermplasmUncheckedCreateWithoutSeedLotsInput>
    connectOrCreate?: GermplasmCreateOrConnectWithoutSeedLotsInput
    upsert?: GermplasmUpsertWithoutSeedLotsInput
    connect?: GermplasmWhereUniqueInput
    update?: XOR<XOR<GermplasmUpdateToOneWithWhereWithoutSeedLotsInput, GermplasmUpdateWithoutSeedLotsInput>, GermplasmUncheckedUpdateWithoutSeedLotsInput>
  }

  export type PlantingUpdateManyWithoutSeedLotNestedInput = {
    create?: XOR<PlantingCreateWithoutSeedLotInput, PlantingUncheckedCreateWithoutSeedLotInput> | PlantingCreateWithoutSeedLotInput[] | PlantingUncheckedCreateWithoutSeedLotInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutSeedLotInput | PlantingCreateOrConnectWithoutSeedLotInput[]
    upsert?: PlantingUpsertWithWhereUniqueWithoutSeedLotInput | PlantingUpsertWithWhereUniqueWithoutSeedLotInput[]
    createMany?: PlantingCreateManySeedLotInputEnvelope
    set?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    disconnect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    delete?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    update?: PlantingUpdateWithWhereUniqueWithoutSeedLotInput | PlantingUpdateWithWhereUniqueWithoutSeedLotInput[]
    updateMany?: PlantingUpdateManyWithWhereWithoutSeedLotInput | PlantingUpdateManyWithWhereWithoutSeedLotInput[]
    deleteMany?: PlantingScalarWhereInput | PlantingScalarWhereInput[]
  }

  export type PlantingUncheckedUpdateManyWithoutSeedLotNestedInput = {
    create?: XOR<PlantingCreateWithoutSeedLotInput, PlantingUncheckedCreateWithoutSeedLotInput> | PlantingCreateWithoutSeedLotInput[] | PlantingUncheckedCreateWithoutSeedLotInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutSeedLotInput | PlantingCreateOrConnectWithoutSeedLotInput[]
    upsert?: PlantingUpsertWithWhereUniqueWithoutSeedLotInput | PlantingUpsertWithWhereUniqueWithoutSeedLotInput[]
    createMany?: PlantingCreateManySeedLotInputEnvelope
    set?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    disconnect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    delete?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    update?: PlantingUpdateWithWhereUniqueWithoutSeedLotInput | PlantingUpdateWithWhereUniqueWithoutSeedLotInput[]
    updateMany?: PlantingUpdateManyWithWhereWithoutSeedLotInput | PlantingUpdateManyWithWhereWithoutSeedLotInput[]
    deleteMany?: PlantingScalarWhereInput | PlantingScalarWhereInput[]
  }

  export type PlantingCreatephotosInput = {
    set: string[]
  }

  export type ExperimentCreateNestedOneWithoutPlantingsInput = {
    create?: XOR<ExperimentCreateWithoutPlantingsInput, ExperimentUncheckedCreateWithoutPlantingsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutPlantingsInput
    connect?: ExperimentWhereUniqueInput
  }

  export type GermplasmCreateNestedOneWithoutPlantingsInput = {
    create?: XOR<GermplasmCreateWithoutPlantingsInput, GermplasmUncheckedCreateWithoutPlantingsInput>
    connectOrCreate?: GermplasmCreateOrConnectWithoutPlantingsInput
    connect?: GermplasmWhereUniqueInput
  }

  export type SeedLotCreateNestedOneWithoutPlantingsInput = {
    create?: XOR<SeedLotCreateWithoutPlantingsInput, SeedLotUncheckedCreateWithoutPlantingsInput>
    connectOrCreate?: SeedLotCreateOrConnectWithoutPlantingsInput
    connect?: SeedLotWhereUniqueInput
  }

  export type PlantingUpdatephotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExperimentUpdateOneRequiredWithoutPlantingsNestedInput = {
    create?: XOR<ExperimentCreateWithoutPlantingsInput, ExperimentUncheckedCreateWithoutPlantingsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutPlantingsInput
    upsert?: ExperimentUpsertWithoutPlantingsInput
    connect?: ExperimentWhereUniqueInput
    update?: XOR<XOR<ExperimentUpdateToOneWithWhereWithoutPlantingsInput, ExperimentUpdateWithoutPlantingsInput>, ExperimentUncheckedUpdateWithoutPlantingsInput>
  }

  export type GermplasmUpdateOneRequiredWithoutPlantingsNestedInput = {
    create?: XOR<GermplasmCreateWithoutPlantingsInput, GermplasmUncheckedCreateWithoutPlantingsInput>
    connectOrCreate?: GermplasmCreateOrConnectWithoutPlantingsInput
    upsert?: GermplasmUpsertWithoutPlantingsInput
    connect?: GermplasmWhereUniqueInput
    update?: XOR<XOR<GermplasmUpdateToOneWithWhereWithoutPlantingsInput, GermplasmUpdateWithoutPlantingsInput>, GermplasmUncheckedUpdateWithoutPlantingsInput>
  }

  export type SeedLotUpdateOneWithoutPlantingsNestedInput = {
    create?: XOR<SeedLotCreateWithoutPlantingsInput, SeedLotUncheckedCreateWithoutPlantingsInput>
    connectOrCreate?: SeedLotCreateOrConnectWithoutPlantingsInput
    upsert?: SeedLotUpsertWithoutPlantingsInput
    disconnect?: SeedLotWhereInput | boolean
    delete?: SeedLotWhereInput | boolean
    connect?: SeedLotWhereUniqueInput
    update?: XOR<XOR<SeedLotUpdateToOneWithWhereWithoutPlantingsInput, SeedLotUpdateWithoutPlantingsInput>, SeedLotUncheckedUpdateWithoutPlantingsInput>
  }

  export type ExperimentCreatetagsInput = {
    set: string[]
  }

  export type ResearchProtocolCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ResearchProtocolCreateWithoutExperimentInput, ResearchProtocolUncheckedCreateWithoutExperimentInput> | ResearchProtocolCreateWithoutExperimentInput[] | ResearchProtocolUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchProtocolCreateOrConnectWithoutExperimentInput | ResearchProtocolCreateOrConnectWithoutExperimentInput[]
    createMany?: ResearchProtocolCreateManyExperimentInputEnvelope
    connect?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
  }

  export type ResearchPlotCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ResearchPlotCreateWithoutExperimentInput, ResearchPlotUncheckedCreateWithoutExperimentInput> | ResearchPlotCreateWithoutExperimentInput[] | ResearchPlotUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutExperimentInput | ResearchPlotCreateOrConnectWithoutExperimentInput[]
    createMany?: ResearchPlotCreateManyExperimentInputEnvelope
    connect?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
  }

  export type TreatmentCreateNestedManyWithoutExperimentInput = {
    create?: XOR<TreatmentCreateWithoutExperimentInput, TreatmentUncheckedCreateWithoutExperimentInput> | TreatmentCreateWithoutExperimentInput[] | TreatmentUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutExperimentInput | TreatmentCreateOrConnectWithoutExperimentInput[]
    createMany?: TreatmentCreateManyExperimentInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type ResearchDailyLogCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ResearchDailyLogCreateWithoutExperimentInput, ResearchDailyLogUncheckedCreateWithoutExperimentInput> | ResearchDailyLogCreateWithoutExperimentInput[] | ResearchDailyLogUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutExperimentInput | ResearchDailyLogCreateOrConnectWithoutExperimentInput[]
    createMany?: ResearchDailyLogCreateManyExperimentInputEnvelope
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
  }

  export type LabSampleCreateNestedManyWithoutExperimentInput = {
    create?: XOR<LabSampleCreateWithoutExperimentInput, LabSampleUncheckedCreateWithoutExperimentInput> | LabSampleCreateWithoutExperimentInput[] | LabSampleUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutExperimentInput | LabSampleCreateOrConnectWithoutExperimentInput[]
    createMany?: LabSampleCreateManyExperimentInputEnvelope
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
  }

  export type ExperimentCollaboratorCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ExperimentCollaboratorCreateWithoutExperimentInput, ExperimentCollaboratorUncheckedCreateWithoutExperimentInput> | ExperimentCollaboratorCreateWithoutExperimentInput[] | ExperimentCollaboratorUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ExperimentCollaboratorCreateOrConnectWithoutExperimentInput | ExperimentCollaboratorCreateOrConnectWithoutExperimentInput[]
    createMany?: ExperimentCollaboratorCreateManyExperimentInputEnvelope
    connect?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
  }

  export type ExperimentAuditLogCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ExperimentAuditLogCreateWithoutExperimentInput, ExperimentAuditLogUncheckedCreateWithoutExperimentInput> | ExperimentAuditLogCreateWithoutExperimentInput[] | ExperimentAuditLogUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ExperimentAuditLogCreateOrConnectWithoutExperimentInput | ExperimentAuditLogCreateOrConnectWithoutExperimentInput[]
    createMany?: ExperimentAuditLogCreateManyExperimentInputEnvelope
    connect?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
  }

  export type PlantingCreateNestedManyWithoutExperimentInput = {
    create?: XOR<PlantingCreateWithoutExperimentInput, PlantingUncheckedCreateWithoutExperimentInput> | PlantingCreateWithoutExperimentInput[] | PlantingUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutExperimentInput | PlantingCreateOrConnectWithoutExperimentInput[]
    createMany?: PlantingCreateManyExperimentInputEnvelope
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
  }

  export type ResearchProtocolUncheckedCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ResearchProtocolCreateWithoutExperimentInput, ResearchProtocolUncheckedCreateWithoutExperimentInput> | ResearchProtocolCreateWithoutExperimentInput[] | ResearchProtocolUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchProtocolCreateOrConnectWithoutExperimentInput | ResearchProtocolCreateOrConnectWithoutExperimentInput[]
    createMany?: ResearchProtocolCreateManyExperimentInputEnvelope
    connect?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
  }

  export type ResearchPlotUncheckedCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ResearchPlotCreateWithoutExperimentInput, ResearchPlotUncheckedCreateWithoutExperimentInput> | ResearchPlotCreateWithoutExperimentInput[] | ResearchPlotUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutExperimentInput | ResearchPlotCreateOrConnectWithoutExperimentInput[]
    createMany?: ResearchPlotCreateManyExperimentInputEnvelope
    connect?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
  }

  export type TreatmentUncheckedCreateNestedManyWithoutExperimentInput = {
    create?: XOR<TreatmentCreateWithoutExperimentInput, TreatmentUncheckedCreateWithoutExperimentInput> | TreatmentCreateWithoutExperimentInput[] | TreatmentUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutExperimentInput | TreatmentCreateOrConnectWithoutExperimentInput[]
    createMany?: TreatmentCreateManyExperimentInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type ResearchDailyLogUncheckedCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ResearchDailyLogCreateWithoutExperimentInput, ResearchDailyLogUncheckedCreateWithoutExperimentInput> | ResearchDailyLogCreateWithoutExperimentInput[] | ResearchDailyLogUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutExperimentInput | ResearchDailyLogCreateOrConnectWithoutExperimentInput[]
    createMany?: ResearchDailyLogCreateManyExperimentInputEnvelope
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
  }

  export type LabSampleUncheckedCreateNestedManyWithoutExperimentInput = {
    create?: XOR<LabSampleCreateWithoutExperimentInput, LabSampleUncheckedCreateWithoutExperimentInput> | LabSampleCreateWithoutExperimentInput[] | LabSampleUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutExperimentInput | LabSampleCreateOrConnectWithoutExperimentInput[]
    createMany?: LabSampleCreateManyExperimentInputEnvelope
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
  }

  export type ExperimentCollaboratorUncheckedCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ExperimentCollaboratorCreateWithoutExperimentInput, ExperimentCollaboratorUncheckedCreateWithoutExperimentInput> | ExperimentCollaboratorCreateWithoutExperimentInput[] | ExperimentCollaboratorUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ExperimentCollaboratorCreateOrConnectWithoutExperimentInput | ExperimentCollaboratorCreateOrConnectWithoutExperimentInput[]
    createMany?: ExperimentCollaboratorCreateManyExperimentInputEnvelope
    connect?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
  }

  export type ExperimentAuditLogUncheckedCreateNestedManyWithoutExperimentInput = {
    create?: XOR<ExperimentAuditLogCreateWithoutExperimentInput, ExperimentAuditLogUncheckedCreateWithoutExperimentInput> | ExperimentAuditLogCreateWithoutExperimentInput[] | ExperimentAuditLogUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ExperimentAuditLogCreateOrConnectWithoutExperimentInput | ExperimentAuditLogCreateOrConnectWithoutExperimentInput[]
    createMany?: ExperimentAuditLogCreateManyExperimentInputEnvelope
    connect?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
  }

  export type PlantingUncheckedCreateNestedManyWithoutExperimentInput = {
    create?: XOR<PlantingCreateWithoutExperimentInput, PlantingUncheckedCreateWithoutExperimentInput> | PlantingCreateWithoutExperimentInput[] | PlantingUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutExperimentInput | PlantingCreateOrConnectWithoutExperimentInput[]
    createMany?: PlantingCreateManyExperimentInputEnvelope
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
  }

  export type EnumExperimentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExperimentStatus
  }

  export type ExperimentUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ResearchProtocolUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ResearchProtocolCreateWithoutExperimentInput, ResearchProtocolUncheckedCreateWithoutExperimentInput> | ResearchProtocolCreateWithoutExperimentInput[] | ResearchProtocolUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchProtocolCreateOrConnectWithoutExperimentInput | ResearchProtocolCreateOrConnectWithoutExperimentInput[]
    upsert?: ResearchProtocolUpsertWithWhereUniqueWithoutExperimentInput | ResearchProtocolUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ResearchProtocolCreateManyExperimentInputEnvelope
    set?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
    disconnect?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
    delete?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
    connect?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
    update?: ResearchProtocolUpdateWithWhereUniqueWithoutExperimentInput | ResearchProtocolUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ResearchProtocolUpdateManyWithWhereWithoutExperimentInput | ResearchProtocolUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ResearchProtocolScalarWhereInput | ResearchProtocolScalarWhereInput[]
  }

  export type ResearchPlotUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ResearchPlotCreateWithoutExperimentInput, ResearchPlotUncheckedCreateWithoutExperimentInput> | ResearchPlotCreateWithoutExperimentInput[] | ResearchPlotUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutExperimentInput | ResearchPlotCreateOrConnectWithoutExperimentInput[]
    upsert?: ResearchPlotUpsertWithWhereUniqueWithoutExperimentInput | ResearchPlotUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ResearchPlotCreateManyExperimentInputEnvelope
    set?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
    disconnect?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
    delete?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
    connect?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
    update?: ResearchPlotUpdateWithWhereUniqueWithoutExperimentInput | ResearchPlotUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ResearchPlotUpdateManyWithWhereWithoutExperimentInput | ResearchPlotUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ResearchPlotScalarWhereInput | ResearchPlotScalarWhereInput[]
  }

  export type TreatmentUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<TreatmentCreateWithoutExperimentInput, TreatmentUncheckedCreateWithoutExperimentInput> | TreatmentCreateWithoutExperimentInput[] | TreatmentUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutExperimentInput | TreatmentCreateOrConnectWithoutExperimentInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutExperimentInput | TreatmentUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: TreatmentCreateManyExperimentInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutExperimentInput | TreatmentUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutExperimentInput | TreatmentUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type ResearchDailyLogUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ResearchDailyLogCreateWithoutExperimentInput, ResearchDailyLogUncheckedCreateWithoutExperimentInput> | ResearchDailyLogCreateWithoutExperimentInput[] | ResearchDailyLogUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutExperimentInput | ResearchDailyLogCreateOrConnectWithoutExperimentInput[]
    upsert?: ResearchDailyLogUpsertWithWhereUniqueWithoutExperimentInput | ResearchDailyLogUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ResearchDailyLogCreateManyExperimentInputEnvelope
    set?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    disconnect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    delete?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    update?: ResearchDailyLogUpdateWithWhereUniqueWithoutExperimentInput | ResearchDailyLogUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ResearchDailyLogUpdateManyWithWhereWithoutExperimentInput | ResearchDailyLogUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ResearchDailyLogScalarWhereInput | ResearchDailyLogScalarWhereInput[]
  }

  export type LabSampleUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<LabSampleCreateWithoutExperimentInput, LabSampleUncheckedCreateWithoutExperimentInput> | LabSampleCreateWithoutExperimentInput[] | LabSampleUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutExperimentInput | LabSampleCreateOrConnectWithoutExperimentInput[]
    upsert?: LabSampleUpsertWithWhereUniqueWithoutExperimentInput | LabSampleUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: LabSampleCreateManyExperimentInputEnvelope
    set?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    disconnect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    delete?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    update?: LabSampleUpdateWithWhereUniqueWithoutExperimentInput | LabSampleUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: LabSampleUpdateManyWithWhereWithoutExperimentInput | LabSampleUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: LabSampleScalarWhereInput | LabSampleScalarWhereInput[]
  }

  export type ExperimentCollaboratorUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ExperimentCollaboratorCreateWithoutExperimentInput, ExperimentCollaboratorUncheckedCreateWithoutExperimentInput> | ExperimentCollaboratorCreateWithoutExperimentInput[] | ExperimentCollaboratorUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ExperimentCollaboratorCreateOrConnectWithoutExperimentInput | ExperimentCollaboratorCreateOrConnectWithoutExperimentInput[]
    upsert?: ExperimentCollaboratorUpsertWithWhereUniqueWithoutExperimentInput | ExperimentCollaboratorUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ExperimentCollaboratorCreateManyExperimentInputEnvelope
    set?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
    disconnect?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
    delete?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
    connect?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
    update?: ExperimentCollaboratorUpdateWithWhereUniqueWithoutExperimentInput | ExperimentCollaboratorUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ExperimentCollaboratorUpdateManyWithWhereWithoutExperimentInput | ExperimentCollaboratorUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ExperimentCollaboratorScalarWhereInput | ExperimentCollaboratorScalarWhereInput[]
  }

  export type ExperimentAuditLogUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ExperimentAuditLogCreateWithoutExperimentInput, ExperimentAuditLogUncheckedCreateWithoutExperimentInput> | ExperimentAuditLogCreateWithoutExperimentInput[] | ExperimentAuditLogUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ExperimentAuditLogCreateOrConnectWithoutExperimentInput | ExperimentAuditLogCreateOrConnectWithoutExperimentInput[]
    upsert?: ExperimentAuditLogUpsertWithWhereUniqueWithoutExperimentInput | ExperimentAuditLogUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ExperimentAuditLogCreateManyExperimentInputEnvelope
    set?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
    disconnect?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
    delete?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
    connect?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
    update?: ExperimentAuditLogUpdateWithWhereUniqueWithoutExperimentInput | ExperimentAuditLogUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ExperimentAuditLogUpdateManyWithWhereWithoutExperimentInput | ExperimentAuditLogUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ExperimentAuditLogScalarWhereInput | ExperimentAuditLogScalarWhereInput[]
  }

  export type PlantingUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<PlantingCreateWithoutExperimentInput, PlantingUncheckedCreateWithoutExperimentInput> | PlantingCreateWithoutExperimentInput[] | PlantingUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutExperimentInput | PlantingCreateOrConnectWithoutExperimentInput[]
    upsert?: PlantingUpsertWithWhereUniqueWithoutExperimentInput | PlantingUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: PlantingCreateManyExperimentInputEnvelope
    set?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    disconnect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    delete?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    update?: PlantingUpdateWithWhereUniqueWithoutExperimentInput | PlantingUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: PlantingUpdateManyWithWhereWithoutExperimentInput | PlantingUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: PlantingScalarWhereInput | PlantingScalarWhereInput[]
  }

  export type ResearchProtocolUncheckedUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ResearchProtocolCreateWithoutExperimentInput, ResearchProtocolUncheckedCreateWithoutExperimentInput> | ResearchProtocolCreateWithoutExperimentInput[] | ResearchProtocolUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchProtocolCreateOrConnectWithoutExperimentInput | ResearchProtocolCreateOrConnectWithoutExperimentInput[]
    upsert?: ResearchProtocolUpsertWithWhereUniqueWithoutExperimentInput | ResearchProtocolUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ResearchProtocolCreateManyExperimentInputEnvelope
    set?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
    disconnect?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
    delete?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
    connect?: ResearchProtocolWhereUniqueInput | ResearchProtocolWhereUniqueInput[]
    update?: ResearchProtocolUpdateWithWhereUniqueWithoutExperimentInput | ResearchProtocolUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ResearchProtocolUpdateManyWithWhereWithoutExperimentInput | ResearchProtocolUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ResearchProtocolScalarWhereInput | ResearchProtocolScalarWhereInput[]
  }

  export type ResearchPlotUncheckedUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ResearchPlotCreateWithoutExperimentInput, ResearchPlotUncheckedCreateWithoutExperimentInput> | ResearchPlotCreateWithoutExperimentInput[] | ResearchPlotUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutExperimentInput | ResearchPlotCreateOrConnectWithoutExperimentInput[]
    upsert?: ResearchPlotUpsertWithWhereUniqueWithoutExperimentInput | ResearchPlotUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ResearchPlotCreateManyExperimentInputEnvelope
    set?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
    disconnect?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
    delete?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
    connect?: ResearchPlotWhereUniqueInput | ResearchPlotWhereUniqueInput[]
    update?: ResearchPlotUpdateWithWhereUniqueWithoutExperimentInput | ResearchPlotUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ResearchPlotUpdateManyWithWhereWithoutExperimentInput | ResearchPlotUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ResearchPlotScalarWhereInput | ResearchPlotScalarWhereInput[]
  }

  export type TreatmentUncheckedUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<TreatmentCreateWithoutExperimentInput, TreatmentUncheckedCreateWithoutExperimentInput> | TreatmentCreateWithoutExperimentInput[] | TreatmentUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutExperimentInput | TreatmentCreateOrConnectWithoutExperimentInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutExperimentInput | TreatmentUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: TreatmentCreateManyExperimentInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutExperimentInput | TreatmentUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutExperimentInput | TreatmentUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type ResearchDailyLogUncheckedUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ResearchDailyLogCreateWithoutExperimentInput, ResearchDailyLogUncheckedCreateWithoutExperimentInput> | ResearchDailyLogCreateWithoutExperimentInput[] | ResearchDailyLogUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutExperimentInput | ResearchDailyLogCreateOrConnectWithoutExperimentInput[]
    upsert?: ResearchDailyLogUpsertWithWhereUniqueWithoutExperimentInput | ResearchDailyLogUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ResearchDailyLogCreateManyExperimentInputEnvelope
    set?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    disconnect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    delete?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    update?: ResearchDailyLogUpdateWithWhereUniqueWithoutExperimentInput | ResearchDailyLogUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ResearchDailyLogUpdateManyWithWhereWithoutExperimentInput | ResearchDailyLogUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ResearchDailyLogScalarWhereInput | ResearchDailyLogScalarWhereInput[]
  }

  export type LabSampleUncheckedUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<LabSampleCreateWithoutExperimentInput, LabSampleUncheckedCreateWithoutExperimentInput> | LabSampleCreateWithoutExperimentInput[] | LabSampleUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutExperimentInput | LabSampleCreateOrConnectWithoutExperimentInput[]
    upsert?: LabSampleUpsertWithWhereUniqueWithoutExperimentInput | LabSampleUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: LabSampleCreateManyExperimentInputEnvelope
    set?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    disconnect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    delete?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    update?: LabSampleUpdateWithWhereUniqueWithoutExperimentInput | LabSampleUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: LabSampleUpdateManyWithWhereWithoutExperimentInput | LabSampleUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: LabSampleScalarWhereInput | LabSampleScalarWhereInput[]
  }

  export type ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ExperimentCollaboratorCreateWithoutExperimentInput, ExperimentCollaboratorUncheckedCreateWithoutExperimentInput> | ExperimentCollaboratorCreateWithoutExperimentInput[] | ExperimentCollaboratorUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ExperimentCollaboratorCreateOrConnectWithoutExperimentInput | ExperimentCollaboratorCreateOrConnectWithoutExperimentInput[]
    upsert?: ExperimentCollaboratorUpsertWithWhereUniqueWithoutExperimentInput | ExperimentCollaboratorUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ExperimentCollaboratorCreateManyExperimentInputEnvelope
    set?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
    disconnect?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
    delete?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
    connect?: ExperimentCollaboratorWhereUniqueInput | ExperimentCollaboratorWhereUniqueInput[]
    update?: ExperimentCollaboratorUpdateWithWhereUniqueWithoutExperimentInput | ExperimentCollaboratorUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ExperimentCollaboratorUpdateManyWithWhereWithoutExperimentInput | ExperimentCollaboratorUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ExperimentCollaboratorScalarWhereInput | ExperimentCollaboratorScalarWhereInput[]
  }

  export type ExperimentAuditLogUncheckedUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<ExperimentAuditLogCreateWithoutExperimentInput, ExperimentAuditLogUncheckedCreateWithoutExperimentInput> | ExperimentAuditLogCreateWithoutExperimentInput[] | ExperimentAuditLogUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: ExperimentAuditLogCreateOrConnectWithoutExperimentInput | ExperimentAuditLogCreateOrConnectWithoutExperimentInput[]
    upsert?: ExperimentAuditLogUpsertWithWhereUniqueWithoutExperimentInput | ExperimentAuditLogUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: ExperimentAuditLogCreateManyExperimentInputEnvelope
    set?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
    disconnect?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
    delete?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
    connect?: ExperimentAuditLogWhereUniqueInput | ExperimentAuditLogWhereUniqueInput[]
    update?: ExperimentAuditLogUpdateWithWhereUniqueWithoutExperimentInput | ExperimentAuditLogUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: ExperimentAuditLogUpdateManyWithWhereWithoutExperimentInput | ExperimentAuditLogUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: ExperimentAuditLogScalarWhereInput | ExperimentAuditLogScalarWhereInput[]
  }

  export type PlantingUncheckedUpdateManyWithoutExperimentNestedInput = {
    create?: XOR<PlantingCreateWithoutExperimentInput, PlantingUncheckedCreateWithoutExperimentInput> | PlantingCreateWithoutExperimentInput[] | PlantingUncheckedCreateWithoutExperimentInput[]
    connectOrCreate?: PlantingCreateOrConnectWithoutExperimentInput | PlantingCreateOrConnectWithoutExperimentInput[]
    upsert?: PlantingUpsertWithWhereUniqueWithoutExperimentInput | PlantingUpsertWithWhereUniqueWithoutExperimentInput[]
    createMany?: PlantingCreateManyExperimentInputEnvelope
    set?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    disconnect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    delete?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    connect?: PlantingWhereUniqueInput | PlantingWhereUniqueInput[]
    update?: PlantingUpdateWithWhereUniqueWithoutExperimentInput | PlantingUpdateWithWhereUniqueWithoutExperimentInput[]
    updateMany?: PlantingUpdateManyWithWhereWithoutExperimentInput | PlantingUpdateManyWithWhereWithoutExperimentInput[]
    deleteMany?: PlantingScalarWhereInput | PlantingScalarWhereInput[]
  }

  export type ResearchProtocolCreateequipmentRequiredInput = {
    set: string[]
  }

  export type ExperimentCreateNestedOneWithoutProtocolsInput = {
    create?: XOR<ExperimentCreateWithoutProtocolsInput, ExperimentUncheckedCreateWithoutProtocolsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutProtocolsInput
    connect?: ExperimentWhereUniqueInput
  }

  export type ResearchProtocolUpdateequipmentRequiredInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExperimentUpdateOneRequiredWithoutProtocolsNestedInput = {
    create?: XOR<ExperimentCreateWithoutProtocolsInput, ExperimentUncheckedCreateWithoutProtocolsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutProtocolsInput
    upsert?: ExperimentUpsertWithoutProtocolsInput
    connect?: ExperimentWhereUniqueInput
    update?: XOR<XOR<ExperimentUpdateToOneWithWhereWithoutProtocolsInput, ExperimentUpdateWithoutProtocolsInput>, ExperimentUncheckedUpdateWithoutProtocolsInput>
  }

  export type ExperimentCreateNestedOneWithoutPlotsInput = {
    create?: XOR<ExperimentCreateWithoutPlotsInput, ExperimentUncheckedCreateWithoutPlotsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutPlotsInput
    connect?: ExperimentWhereUniqueInput
  }

  export type TreatmentCreateNestedManyWithoutPlotInput = {
    create?: XOR<TreatmentCreateWithoutPlotInput, TreatmentUncheckedCreateWithoutPlotInput> | TreatmentCreateWithoutPlotInput[] | TreatmentUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutPlotInput | TreatmentCreateOrConnectWithoutPlotInput[]
    createMany?: TreatmentCreateManyPlotInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type ResearchDailyLogCreateNestedManyWithoutPlotInput = {
    create?: XOR<ResearchDailyLogCreateWithoutPlotInput, ResearchDailyLogUncheckedCreateWithoutPlotInput> | ResearchDailyLogCreateWithoutPlotInput[] | ResearchDailyLogUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutPlotInput | ResearchDailyLogCreateOrConnectWithoutPlotInput[]
    createMany?: ResearchDailyLogCreateManyPlotInputEnvelope
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
  }

  export type LabSampleCreateNestedManyWithoutPlotInput = {
    create?: XOR<LabSampleCreateWithoutPlotInput, LabSampleUncheckedCreateWithoutPlotInput> | LabSampleCreateWithoutPlotInput[] | LabSampleUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutPlotInput | LabSampleCreateOrConnectWithoutPlotInput[]
    createMany?: LabSampleCreateManyPlotInputEnvelope
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
  }

  export type TreatmentUncheckedCreateNestedManyWithoutPlotInput = {
    create?: XOR<TreatmentCreateWithoutPlotInput, TreatmentUncheckedCreateWithoutPlotInput> | TreatmentCreateWithoutPlotInput[] | TreatmentUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutPlotInput | TreatmentCreateOrConnectWithoutPlotInput[]
    createMany?: TreatmentCreateManyPlotInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type ResearchDailyLogUncheckedCreateNestedManyWithoutPlotInput = {
    create?: XOR<ResearchDailyLogCreateWithoutPlotInput, ResearchDailyLogUncheckedCreateWithoutPlotInput> | ResearchDailyLogCreateWithoutPlotInput[] | ResearchDailyLogUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutPlotInput | ResearchDailyLogCreateOrConnectWithoutPlotInput[]
    createMany?: ResearchDailyLogCreateManyPlotInputEnvelope
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
  }

  export type LabSampleUncheckedCreateNestedManyWithoutPlotInput = {
    create?: XOR<LabSampleCreateWithoutPlotInput, LabSampleUncheckedCreateWithoutPlotInput> | LabSampleCreateWithoutPlotInput[] | LabSampleUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutPlotInput | LabSampleCreateOrConnectWithoutPlotInput[]
    createMany?: LabSampleCreateManyPlotInputEnvelope
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
  }

  export type ExperimentUpdateOneRequiredWithoutPlotsNestedInput = {
    create?: XOR<ExperimentCreateWithoutPlotsInput, ExperimentUncheckedCreateWithoutPlotsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutPlotsInput
    upsert?: ExperimentUpsertWithoutPlotsInput
    connect?: ExperimentWhereUniqueInput
    update?: XOR<XOR<ExperimentUpdateToOneWithWhereWithoutPlotsInput, ExperimentUpdateWithoutPlotsInput>, ExperimentUncheckedUpdateWithoutPlotsInput>
  }

  export type TreatmentUpdateManyWithoutPlotNestedInput = {
    create?: XOR<TreatmentCreateWithoutPlotInput, TreatmentUncheckedCreateWithoutPlotInput> | TreatmentCreateWithoutPlotInput[] | TreatmentUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutPlotInput | TreatmentCreateOrConnectWithoutPlotInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutPlotInput | TreatmentUpsertWithWhereUniqueWithoutPlotInput[]
    createMany?: TreatmentCreateManyPlotInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutPlotInput | TreatmentUpdateWithWhereUniqueWithoutPlotInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutPlotInput | TreatmentUpdateManyWithWhereWithoutPlotInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type ResearchDailyLogUpdateManyWithoutPlotNestedInput = {
    create?: XOR<ResearchDailyLogCreateWithoutPlotInput, ResearchDailyLogUncheckedCreateWithoutPlotInput> | ResearchDailyLogCreateWithoutPlotInput[] | ResearchDailyLogUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutPlotInput | ResearchDailyLogCreateOrConnectWithoutPlotInput[]
    upsert?: ResearchDailyLogUpsertWithWhereUniqueWithoutPlotInput | ResearchDailyLogUpsertWithWhereUniqueWithoutPlotInput[]
    createMany?: ResearchDailyLogCreateManyPlotInputEnvelope
    set?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    disconnect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    delete?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    update?: ResearchDailyLogUpdateWithWhereUniqueWithoutPlotInput | ResearchDailyLogUpdateWithWhereUniqueWithoutPlotInput[]
    updateMany?: ResearchDailyLogUpdateManyWithWhereWithoutPlotInput | ResearchDailyLogUpdateManyWithWhereWithoutPlotInput[]
    deleteMany?: ResearchDailyLogScalarWhereInput | ResearchDailyLogScalarWhereInput[]
  }

  export type LabSampleUpdateManyWithoutPlotNestedInput = {
    create?: XOR<LabSampleCreateWithoutPlotInput, LabSampleUncheckedCreateWithoutPlotInput> | LabSampleCreateWithoutPlotInput[] | LabSampleUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutPlotInput | LabSampleCreateOrConnectWithoutPlotInput[]
    upsert?: LabSampleUpsertWithWhereUniqueWithoutPlotInput | LabSampleUpsertWithWhereUniqueWithoutPlotInput[]
    createMany?: LabSampleCreateManyPlotInputEnvelope
    set?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    disconnect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    delete?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    update?: LabSampleUpdateWithWhereUniqueWithoutPlotInput | LabSampleUpdateWithWhereUniqueWithoutPlotInput[]
    updateMany?: LabSampleUpdateManyWithWhereWithoutPlotInput | LabSampleUpdateManyWithWhereWithoutPlotInput[]
    deleteMany?: LabSampleScalarWhereInput | LabSampleScalarWhereInput[]
  }

  export type TreatmentUncheckedUpdateManyWithoutPlotNestedInput = {
    create?: XOR<TreatmentCreateWithoutPlotInput, TreatmentUncheckedCreateWithoutPlotInput> | TreatmentCreateWithoutPlotInput[] | TreatmentUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutPlotInput | TreatmentCreateOrConnectWithoutPlotInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutPlotInput | TreatmentUpsertWithWhereUniqueWithoutPlotInput[]
    createMany?: TreatmentCreateManyPlotInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutPlotInput | TreatmentUpdateWithWhereUniqueWithoutPlotInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutPlotInput | TreatmentUpdateManyWithWhereWithoutPlotInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type ResearchDailyLogUncheckedUpdateManyWithoutPlotNestedInput = {
    create?: XOR<ResearchDailyLogCreateWithoutPlotInput, ResearchDailyLogUncheckedCreateWithoutPlotInput> | ResearchDailyLogCreateWithoutPlotInput[] | ResearchDailyLogUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutPlotInput | ResearchDailyLogCreateOrConnectWithoutPlotInput[]
    upsert?: ResearchDailyLogUpsertWithWhereUniqueWithoutPlotInput | ResearchDailyLogUpsertWithWhereUniqueWithoutPlotInput[]
    createMany?: ResearchDailyLogCreateManyPlotInputEnvelope
    set?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    disconnect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    delete?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    update?: ResearchDailyLogUpdateWithWhereUniqueWithoutPlotInput | ResearchDailyLogUpdateWithWhereUniqueWithoutPlotInput[]
    updateMany?: ResearchDailyLogUpdateManyWithWhereWithoutPlotInput | ResearchDailyLogUpdateManyWithWhereWithoutPlotInput[]
    deleteMany?: ResearchDailyLogScalarWhereInput | ResearchDailyLogScalarWhereInput[]
  }

  export type LabSampleUncheckedUpdateManyWithoutPlotNestedInput = {
    create?: XOR<LabSampleCreateWithoutPlotInput, LabSampleUncheckedCreateWithoutPlotInput> | LabSampleCreateWithoutPlotInput[] | LabSampleUncheckedCreateWithoutPlotInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutPlotInput | LabSampleCreateOrConnectWithoutPlotInput[]
    upsert?: LabSampleUpsertWithWhereUniqueWithoutPlotInput | LabSampleUpsertWithWhereUniqueWithoutPlotInput[]
    createMany?: LabSampleCreateManyPlotInputEnvelope
    set?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    disconnect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    delete?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    update?: LabSampleUpdateWithWhereUniqueWithoutPlotInput | LabSampleUpdateWithWhereUniqueWithoutPlotInput[]
    updateMany?: LabSampleUpdateManyWithWhereWithoutPlotInput | LabSampleUpdateManyWithWhereWithoutPlotInput[]
    deleteMany?: LabSampleScalarWhereInput | LabSampleScalarWhereInput[]
  }

  export type ExperimentCreateNestedOneWithoutTreatmentsInput = {
    create?: XOR<ExperimentCreateWithoutTreatmentsInput, ExperimentUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutTreatmentsInput
    connect?: ExperimentWhereUniqueInput
  }

  export type ResearchPlotCreateNestedOneWithoutTreatmentsInput = {
    create?: XOR<ResearchPlotCreateWithoutTreatmentsInput, ResearchPlotUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutTreatmentsInput
    connect?: ResearchPlotWhereUniqueInput
  }

  export type ResearchDailyLogCreateNestedManyWithoutTreatmentInput = {
    create?: XOR<ResearchDailyLogCreateWithoutTreatmentInput, ResearchDailyLogUncheckedCreateWithoutTreatmentInput> | ResearchDailyLogCreateWithoutTreatmentInput[] | ResearchDailyLogUncheckedCreateWithoutTreatmentInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutTreatmentInput | ResearchDailyLogCreateOrConnectWithoutTreatmentInput[]
    createMany?: ResearchDailyLogCreateManyTreatmentInputEnvelope
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
  }

  export type ResearchDailyLogUncheckedCreateNestedManyWithoutTreatmentInput = {
    create?: XOR<ResearchDailyLogCreateWithoutTreatmentInput, ResearchDailyLogUncheckedCreateWithoutTreatmentInput> | ResearchDailyLogCreateWithoutTreatmentInput[] | ResearchDailyLogUncheckedCreateWithoutTreatmentInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutTreatmentInput | ResearchDailyLogCreateOrConnectWithoutTreatmentInput[]
    createMany?: ResearchDailyLogCreateManyTreatmentInputEnvelope
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
  }

  export type EnumTreatmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.TreatmentType
  }

  export type ExperimentUpdateOneRequiredWithoutTreatmentsNestedInput = {
    create?: XOR<ExperimentCreateWithoutTreatmentsInput, ExperimentUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutTreatmentsInput
    upsert?: ExperimentUpsertWithoutTreatmentsInput
    connect?: ExperimentWhereUniqueInput
    update?: XOR<XOR<ExperimentUpdateToOneWithWhereWithoutTreatmentsInput, ExperimentUpdateWithoutTreatmentsInput>, ExperimentUncheckedUpdateWithoutTreatmentsInput>
  }

  export type ResearchPlotUpdateOneWithoutTreatmentsNestedInput = {
    create?: XOR<ResearchPlotCreateWithoutTreatmentsInput, ResearchPlotUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutTreatmentsInput
    upsert?: ResearchPlotUpsertWithoutTreatmentsInput
    disconnect?: ResearchPlotWhereInput | boolean
    delete?: ResearchPlotWhereInput | boolean
    connect?: ResearchPlotWhereUniqueInput
    update?: XOR<XOR<ResearchPlotUpdateToOneWithWhereWithoutTreatmentsInput, ResearchPlotUpdateWithoutTreatmentsInput>, ResearchPlotUncheckedUpdateWithoutTreatmentsInput>
  }

  export type ResearchDailyLogUpdateManyWithoutTreatmentNestedInput = {
    create?: XOR<ResearchDailyLogCreateWithoutTreatmentInput, ResearchDailyLogUncheckedCreateWithoutTreatmentInput> | ResearchDailyLogCreateWithoutTreatmentInput[] | ResearchDailyLogUncheckedCreateWithoutTreatmentInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutTreatmentInput | ResearchDailyLogCreateOrConnectWithoutTreatmentInput[]
    upsert?: ResearchDailyLogUpsertWithWhereUniqueWithoutTreatmentInput | ResearchDailyLogUpsertWithWhereUniqueWithoutTreatmentInput[]
    createMany?: ResearchDailyLogCreateManyTreatmentInputEnvelope
    set?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    disconnect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    delete?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    update?: ResearchDailyLogUpdateWithWhereUniqueWithoutTreatmentInput | ResearchDailyLogUpdateWithWhereUniqueWithoutTreatmentInput[]
    updateMany?: ResearchDailyLogUpdateManyWithWhereWithoutTreatmentInput | ResearchDailyLogUpdateManyWithWhereWithoutTreatmentInput[]
    deleteMany?: ResearchDailyLogScalarWhereInput | ResearchDailyLogScalarWhereInput[]
  }

  export type ResearchDailyLogUncheckedUpdateManyWithoutTreatmentNestedInput = {
    create?: XOR<ResearchDailyLogCreateWithoutTreatmentInput, ResearchDailyLogUncheckedCreateWithoutTreatmentInput> | ResearchDailyLogCreateWithoutTreatmentInput[] | ResearchDailyLogUncheckedCreateWithoutTreatmentInput[]
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutTreatmentInput | ResearchDailyLogCreateOrConnectWithoutTreatmentInput[]
    upsert?: ResearchDailyLogUpsertWithWhereUniqueWithoutTreatmentInput | ResearchDailyLogUpsertWithWhereUniqueWithoutTreatmentInput[]
    createMany?: ResearchDailyLogCreateManyTreatmentInputEnvelope
    set?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    disconnect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    delete?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    connect?: ResearchDailyLogWhereUniqueInput | ResearchDailyLogWhereUniqueInput[]
    update?: ResearchDailyLogUpdateWithWhereUniqueWithoutTreatmentInput | ResearchDailyLogUpdateWithWhereUniqueWithoutTreatmentInput[]
    updateMany?: ResearchDailyLogUpdateManyWithWhereWithoutTreatmentInput | ResearchDailyLogUpdateManyWithWhereWithoutTreatmentInput[]
    deleteMany?: ResearchDailyLogScalarWhereInput | ResearchDailyLogScalarWhereInput[]
  }

  export type ResearchDailyLogCreatephotosInput = {
    set: string[]
  }

  export type ResearchDailyLogCreateattachmentsInput = {
    set: string[]
  }

  export type ExperimentCreateNestedOneWithoutLogsInput = {
    create?: XOR<ExperimentCreateWithoutLogsInput, ExperimentUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutLogsInput
    connect?: ExperimentWhereUniqueInput
  }

  export type ResearchPlotCreateNestedOneWithoutLogsInput = {
    create?: XOR<ResearchPlotCreateWithoutLogsInput, ResearchPlotUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutLogsInput
    connect?: ResearchPlotWhereUniqueInput
  }

  export type TreatmentCreateNestedOneWithoutLogsInput = {
    create?: XOR<TreatmentCreateWithoutLogsInput, TreatmentUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TreatmentCreateOrConnectWithoutLogsInput
    connect?: TreatmentWhereUniqueInput
  }

  export type LabSampleCreateNestedManyWithoutLogInput = {
    create?: XOR<LabSampleCreateWithoutLogInput, LabSampleUncheckedCreateWithoutLogInput> | LabSampleCreateWithoutLogInput[] | LabSampleUncheckedCreateWithoutLogInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutLogInput | LabSampleCreateOrConnectWithoutLogInput[]
    createMany?: LabSampleCreateManyLogInputEnvelope
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
  }

  export type LabSampleUncheckedCreateNestedManyWithoutLogInput = {
    create?: XOR<LabSampleCreateWithoutLogInput, LabSampleUncheckedCreateWithoutLogInput> | LabSampleCreateWithoutLogInput[] | LabSampleUncheckedCreateWithoutLogInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutLogInput | LabSampleCreateOrConnectWithoutLogInput[]
    createMany?: LabSampleCreateManyLogInputEnvelope
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
  }

  export type EnumLogCategoryFieldUpdateOperationsInput = {
    set?: $Enums.LogCategory
  }

  export type ResearchDailyLogUpdatephotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResearchDailyLogUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExperimentUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ExperimentCreateWithoutLogsInput, ExperimentUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutLogsInput
    upsert?: ExperimentUpsertWithoutLogsInput
    connect?: ExperimentWhereUniqueInput
    update?: XOR<XOR<ExperimentUpdateToOneWithWhereWithoutLogsInput, ExperimentUpdateWithoutLogsInput>, ExperimentUncheckedUpdateWithoutLogsInput>
  }

  export type ResearchPlotUpdateOneWithoutLogsNestedInput = {
    create?: XOR<ResearchPlotCreateWithoutLogsInput, ResearchPlotUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutLogsInput
    upsert?: ResearchPlotUpsertWithoutLogsInput
    disconnect?: ResearchPlotWhereInput | boolean
    delete?: ResearchPlotWhereInput | boolean
    connect?: ResearchPlotWhereUniqueInput
    update?: XOR<XOR<ResearchPlotUpdateToOneWithWhereWithoutLogsInput, ResearchPlotUpdateWithoutLogsInput>, ResearchPlotUncheckedUpdateWithoutLogsInput>
  }

  export type TreatmentUpdateOneWithoutLogsNestedInput = {
    create?: XOR<TreatmentCreateWithoutLogsInput, TreatmentUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TreatmentCreateOrConnectWithoutLogsInput
    upsert?: TreatmentUpsertWithoutLogsInput
    disconnect?: TreatmentWhereInput | boolean
    delete?: TreatmentWhereInput | boolean
    connect?: TreatmentWhereUniqueInput
    update?: XOR<XOR<TreatmentUpdateToOneWithWhereWithoutLogsInput, TreatmentUpdateWithoutLogsInput>, TreatmentUncheckedUpdateWithoutLogsInput>
  }

  export type LabSampleUpdateManyWithoutLogNestedInput = {
    create?: XOR<LabSampleCreateWithoutLogInput, LabSampleUncheckedCreateWithoutLogInput> | LabSampleCreateWithoutLogInput[] | LabSampleUncheckedCreateWithoutLogInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutLogInput | LabSampleCreateOrConnectWithoutLogInput[]
    upsert?: LabSampleUpsertWithWhereUniqueWithoutLogInput | LabSampleUpsertWithWhereUniqueWithoutLogInput[]
    createMany?: LabSampleCreateManyLogInputEnvelope
    set?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    disconnect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    delete?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    update?: LabSampleUpdateWithWhereUniqueWithoutLogInput | LabSampleUpdateWithWhereUniqueWithoutLogInput[]
    updateMany?: LabSampleUpdateManyWithWhereWithoutLogInput | LabSampleUpdateManyWithWhereWithoutLogInput[]
    deleteMany?: LabSampleScalarWhereInput | LabSampleScalarWhereInput[]
  }

  export type LabSampleUncheckedUpdateManyWithoutLogNestedInput = {
    create?: XOR<LabSampleCreateWithoutLogInput, LabSampleUncheckedCreateWithoutLogInput> | LabSampleCreateWithoutLogInput[] | LabSampleUncheckedCreateWithoutLogInput[]
    connectOrCreate?: LabSampleCreateOrConnectWithoutLogInput | LabSampleCreateOrConnectWithoutLogInput[]
    upsert?: LabSampleUpsertWithWhereUniqueWithoutLogInput | LabSampleUpsertWithWhereUniqueWithoutLogInput[]
    createMany?: LabSampleCreateManyLogInputEnvelope
    set?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    disconnect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    delete?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    connect?: LabSampleWhereUniqueInput | LabSampleWhereUniqueInput[]
    update?: LabSampleUpdateWithWhereUniqueWithoutLogInput | LabSampleUpdateWithWhereUniqueWithoutLogInput[]
    updateMany?: LabSampleUpdateManyWithWhereWithoutLogInput | LabSampleUpdateManyWithWhereWithoutLogInput[]
    deleteMany?: LabSampleScalarWhereInput | LabSampleScalarWhereInput[]
  }

  export type LabSampleCreatephotosInput = {
    set: string[]
  }

  export type ExperimentCreateNestedOneWithoutSamplesInput = {
    create?: XOR<ExperimentCreateWithoutSamplesInput, ExperimentUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutSamplesInput
    connect?: ExperimentWhereUniqueInput
  }

  export type ResearchPlotCreateNestedOneWithoutSamplesInput = {
    create?: XOR<ResearchPlotCreateWithoutSamplesInput, ResearchPlotUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutSamplesInput
    connect?: ResearchPlotWhereUniqueInput
  }

  export type ResearchDailyLogCreateNestedOneWithoutSamplesInput = {
    create?: XOR<ResearchDailyLogCreateWithoutSamplesInput, ResearchDailyLogUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutSamplesInput
    connect?: ResearchDailyLogWhereUniqueInput
  }

  export type EnumSampleTypeFieldUpdateOperationsInput = {
    set?: $Enums.SampleType
  }

  export type LabSampleUpdatephotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExperimentUpdateOneRequiredWithoutSamplesNestedInput = {
    create?: XOR<ExperimentCreateWithoutSamplesInput, ExperimentUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutSamplesInput
    upsert?: ExperimentUpsertWithoutSamplesInput
    connect?: ExperimentWhereUniqueInput
    update?: XOR<XOR<ExperimentUpdateToOneWithWhereWithoutSamplesInput, ExperimentUpdateWithoutSamplesInput>, ExperimentUncheckedUpdateWithoutSamplesInput>
  }

  export type ResearchPlotUpdateOneWithoutSamplesNestedInput = {
    create?: XOR<ResearchPlotCreateWithoutSamplesInput, ResearchPlotUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: ResearchPlotCreateOrConnectWithoutSamplesInput
    upsert?: ResearchPlotUpsertWithoutSamplesInput
    disconnect?: ResearchPlotWhereInput | boolean
    delete?: ResearchPlotWhereInput | boolean
    connect?: ResearchPlotWhereUniqueInput
    update?: XOR<XOR<ResearchPlotUpdateToOneWithWhereWithoutSamplesInput, ResearchPlotUpdateWithoutSamplesInput>, ResearchPlotUncheckedUpdateWithoutSamplesInput>
  }

  export type ResearchDailyLogUpdateOneWithoutSamplesNestedInput = {
    create?: XOR<ResearchDailyLogCreateWithoutSamplesInput, ResearchDailyLogUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: ResearchDailyLogCreateOrConnectWithoutSamplesInput
    upsert?: ResearchDailyLogUpsertWithoutSamplesInput
    disconnect?: ResearchDailyLogWhereInput | boolean
    delete?: ResearchDailyLogWhereInput | boolean
    connect?: ResearchDailyLogWhereUniqueInput
    update?: XOR<XOR<ResearchDailyLogUpdateToOneWithWhereWithoutSamplesInput, ResearchDailyLogUpdateWithoutSamplesInput>, ResearchDailyLogUncheckedUpdateWithoutSamplesInput>
  }

  export type ExperimentCreateNestedOneWithoutCollaboratorsInput = {
    create?: XOR<ExperimentCreateWithoutCollaboratorsInput, ExperimentUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutCollaboratorsInput
    connect?: ExperimentWhereUniqueInput
  }

  export type ExperimentUpdateOneRequiredWithoutCollaboratorsNestedInput = {
    create?: XOR<ExperimentCreateWithoutCollaboratorsInput, ExperimentUncheckedCreateWithoutCollaboratorsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutCollaboratorsInput
    upsert?: ExperimentUpsertWithoutCollaboratorsInput
    connect?: ExperimentWhereUniqueInput
    update?: XOR<XOR<ExperimentUpdateToOneWithWhereWithoutCollaboratorsInput, ExperimentUpdateWithoutCollaboratorsInput>, ExperimentUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type ExperimentCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ExperimentCreateWithoutAuditLogsInput, ExperimentUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutAuditLogsInput
    connect?: ExperimentWhereUniqueInput
  }

  export type ExperimentUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ExperimentCreateWithoutAuditLogsInput, ExperimentUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ExperimentCreateOrConnectWithoutAuditLogsInput
    upsert?: ExperimentUpsertWithoutAuditLogsInput
    disconnect?: ExperimentWhereInput | boolean
    delete?: ExperimentWhereInput | boolean
    connect?: ExperimentWhereUniqueInput
    update?: XOR<XOR<ExperimentUpdateToOneWithWhereWithoutAuditLogsInput, ExperimentUpdateWithoutAuditLogsInput>, ExperimentUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGermplasmTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GermplasmType | EnumGermplasmTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GermplasmType[] | ListEnumGermplasmTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GermplasmType[] | ListEnumGermplasmTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGermplasmTypeFilter<$PrismaModel> | $Enums.GermplasmType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumGermplasmTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GermplasmType | EnumGermplasmTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GermplasmType[] | ListEnumGermplasmTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GermplasmType[] | ListEnumGermplasmTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGermplasmTypeWithAggregatesFilter<$PrismaModel> | $Enums.GermplasmType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGermplasmTypeFilter<$PrismaModel>
    _max?: NestedEnumGermplasmTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumSeedQualityGradeFilter<$PrismaModel = never> = {
    equals?: $Enums.SeedQualityGrade | EnumSeedQualityGradeFieldRefInput<$PrismaModel>
    in?: $Enums.SeedQualityGrade[] | ListEnumSeedQualityGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeedQualityGrade[] | ListEnumSeedQualityGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumSeedQualityGradeFilter<$PrismaModel> | $Enums.SeedQualityGrade
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumSeedQualityGradeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeedQualityGrade | EnumSeedQualityGradeFieldRefInput<$PrismaModel>
    in?: $Enums.SeedQualityGrade[] | ListEnumSeedQualityGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeedQualityGrade[] | ListEnumSeedQualityGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumSeedQualityGradeWithAggregatesFilter<$PrismaModel> | $Enums.SeedQualityGrade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeedQualityGradeFilter<$PrismaModel>
    _max?: NestedEnumSeedQualityGradeFilter<$PrismaModel>
  }

  export type NestedEnumExperimentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExperimentStatus | EnumExperimentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExperimentStatus[] | ListEnumExperimentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExperimentStatus[] | ListEnumExperimentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExperimentStatusFilter<$PrismaModel> | $Enums.ExperimentStatus
  }

  export type NestedEnumExperimentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExperimentStatus | EnumExperimentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExperimentStatus[] | ListEnumExperimentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExperimentStatus[] | ListEnumExperimentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExperimentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExperimentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExperimentStatusFilter<$PrismaModel>
    _max?: NestedEnumExperimentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTreatmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TreatmentType | EnumTreatmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TreatmentType[] | ListEnumTreatmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreatmentType[] | ListEnumTreatmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTreatmentTypeFilter<$PrismaModel> | $Enums.TreatmentType
  }

  export type NestedEnumTreatmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TreatmentType | EnumTreatmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TreatmentType[] | ListEnumTreatmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TreatmentType[] | ListEnumTreatmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTreatmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.TreatmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTreatmentTypeFilter<$PrismaModel>
    _max?: NestedEnumTreatmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumLogCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryFilter<$PrismaModel> | $Enums.LogCategory
  }

  export type NestedEnumLogCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryWithAggregatesFilter<$PrismaModel> | $Enums.LogCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogCategoryFilter<$PrismaModel>
    _max?: NestedEnumLogCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSampleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleType | EnumSampleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleTypeFilter<$PrismaModel> | $Enums.SampleType
  }

  export type NestedEnumSampleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleType | EnumSampleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleTypeWithAggregatesFilter<$PrismaModel> | $Enums.SampleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleTypeFilter<$PrismaModel>
    _max?: NestedEnumSampleTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SeedLotCreateWithoutGermplasmInput = {
    id?: string
    lotNumber: string
    initialQuantity: Decimal | DecimalJsLike | number | string
    currentQuantity: Decimal | DecimalJsLike | number | string
    quantityUnit: string
    seedCount?: number | null
    thousandSeedWeight?: Decimal | DecimalJsLike | number | string | null
    qualityGrade?: $Enums.SeedQualityGrade
    germinationRate?: Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: Date | string | null
    purityPercentage?: Decimal | DecimalJsLike | number | string | null
    moistureContent?: Decimal | DecimalJsLike | number | string | null
    vigorIndex?: Decimal | DecimalJsLike | number | string | null
    productionDate?: Date | string | null
    harvestDate?: Date | string | null
    productionLocation?: string | null
    productionSeason?: string | null
    producedBy?: string | null
    certificationNumber?: string | null
    certifiedBy?: string | null
    certificationDate?: Date | string | null
    expiryDate?: Date | string | null
    isTreated?: boolean
    treatmentType?: string | null
    treatmentProduct?: string | null
    treatmentDate?: Date | string | null
    storageLocation?: string | null
    storageConditions?: string | null
    notes?: string | null
    notesAr?: string | null
    photos?: SeedLotCreatephotosInput | string[]
    documents?: SeedLotCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plantings?: PlantingCreateNestedManyWithoutSeedLotInput
  }

  export type SeedLotUncheckedCreateWithoutGermplasmInput = {
    id?: string
    lotNumber: string
    initialQuantity: Decimal | DecimalJsLike | number | string
    currentQuantity: Decimal | DecimalJsLike | number | string
    quantityUnit: string
    seedCount?: number | null
    thousandSeedWeight?: Decimal | DecimalJsLike | number | string | null
    qualityGrade?: $Enums.SeedQualityGrade
    germinationRate?: Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: Date | string | null
    purityPercentage?: Decimal | DecimalJsLike | number | string | null
    moistureContent?: Decimal | DecimalJsLike | number | string | null
    vigorIndex?: Decimal | DecimalJsLike | number | string | null
    productionDate?: Date | string | null
    harvestDate?: Date | string | null
    productionLocation?: string | null
    productionSeason?: string | null
    producedBy?: string | null
    certificationNumber?: string | null
    certifiedBy?: string | null
    certificationDate?: Date | string | null
    expiryDate?: Date | string | null
    isTreated?: boolean
    treatmentType?: string | null
    treatmentProduct?: string | null
    treatmentDate?: Date | string | null
    storageLocation?: string | null
    storageConditions?: string | null
    notes?: string | null
    notesAr?: string | null
    photos?: SeedLotCreatephotosInput | string[]
    documents?: SeedLotCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plantings?: PlantingUncheckedCreateNestedManyWithoutSeedLotInput
  }

  export type SeedLotCreateOrConnectWithoutGermplasmInput = {
    where: SeedLotWhereUniqueInput
    create: XOR<SeedLotCreateWithoutGermplasmInput, SeedLotUncheckedCreateWithoutGermplasmInput>
  }

  export type SeedLotCreateManyGermplasmInputEnvelope = {
    data: SeedLotCreateManyGermplasmInput | SeedLotCreateManyGermplasmInput[]
    skipDuplicates?: boolean
  }

  export type PlantingCreateWithoutGermplasmInput = {
    id?: string
    plotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutPlantingsInput
    seedLot?: SeedLotCreateNestedOneWithoutPlantingsInput
  }

  export type PlantingUncheckedCreateWithoutGermplasmInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    seedLotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantingCreateOrConnectWithoutGermplasmInput = {
    where: PlantingWhereUniqueInput
    create: XOR<PlantingCreateWithoutGermplasmInput, PlantingUncheckedCreateWithoutGermplasmInput>
  }

  export type PlantingCreateManyGermplasmInputEnvelope = {
    data: PlantingCreateManyGermplasmInput | PlantingCreateManyGermplasmInput[]
    skipDuplicates?: boolean
  }

  export type SeedLotUpsertWithWhereUniqueWithoutGermplasmInput = {
    where: SeedLotWhereUniqueInput
    update: XOR<SeedLotUpdateWithoutGermplasmInput, SeedLotUncheckedUpdateWithoutGermplasmInput>
    create: XOR<SeedLotCreateWithoutGermplasmInput, SeedLotUncheckedCreateWithoutGermplasmInput>
  }

  export type SeedLotUpdateWithWhereUniqueWithoutGermplasmInput = {
    where: SeedLotWhereUniqueInput
    data: XOR<SeedLotUpdateWithoutGermplasmInput, SeedLotUncheckedUpdateWithoutGermplasmInput>
  }

  export type SeedLotUpdateManyWithWhereWithoutGermplasmInput = {
    where: SeedLotScalarWhereInput
    data: XOR<SeedLotUpdateManyMutationInput, SeedLotUncheckedUpdateManyWithoutGermplasmInput>
  }

  export type SeedLotScalarWhereInput = {
    AND?: SeedLotScalarWhereInput | SeedLotScalarWhereInput[]
    OR?: SeedLotScalarWhereInput[]
    NOT?: SeedLotScalarWhereInput | SeedLotScalarWhereInput[]
    id?: StringFilter<"SeedLot"> | string
    germplasmId?: StringFilter<"SeedLot"> | string
    lotNumber?: StringFilter<"SeedLot"> | string
    initialQuantity?: DecimalFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFilter<"SeedLot"> | string
    seedCount?: IntNullableFilter<"SeedLot"> | number | null
    thousandSeedWeight?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFilter<"SeedLot"> | $Enums.SeedQualityGrade
    germinationRate?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    purityPercentage?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    moistureContent?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: DecimalNullableFilter<"SeedLot"> | Decimal | DecimalJsLike | number | string | null
    productionDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    harvestDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    productionLocation?: StringNullableFilter<"SeedLot"> | string | null
    productionSeason?: StringNullableFilter<"SeedLot"> | string | null
    producedBy?: StringNullableFilter<"SeedLot"> | string | null
    certificationNumber?: StringNullableFilter<"SeedLot"> | string | null
    certifiedBy?: StringNullableFilter<"SeedLot"> | string | null
    certificationDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    isTreated?: BoolFilter<"SeedLot"> | boolean
    treatmentType?: StringNullableFilter<"SeedLot"> | string | null
    treatmentProduct?: StringNullableFilter<"SeedLot"> | string | null
    treatmentDate?: DateTimeNullableFilter<"SeedLot"> | Date | string | null
    storageLocation?: StringNullableFilter<"SeedLot"> | string | null
    storageConditions?: StringNullableFilter<"SeedLot"> | string | null
    notes?: StringNullableFilter<"SeedLot"> | string | null
    notesAr?: StringNullableFilter<"SeedLot"> | string | null
    photos?: StringNullableListFilter<"SeedLot">
    documents?: StringNullableListFilter<"SeedLot">
    metadata?: JsonFilter<"SeedLot">
    createdAt?: DateTimeFilter<"SeedLot"> | Date | string
    updatedAt?: DateTimeFilter<"SeedLot"> | Date | string
  }

  export type PlantingUpsertWithWhereUniqueWithoutGermplasmInput = {
    where: PlantingWhereUniqueInput
    update: XOR<PlantingUpdateWithoutGermplasmInput, PlantingUncheckedUpdateWithoutGermplasmInput>
    create: XOR<PlantingCreateWithoutGermplasmInput, PlantingUncheckedCreateWithoutGermplasmInput>
  }

  export type PlantingUpdateWithWhereUniqueWithoutGermplasmInput = {
    where: PlantingWhereUniqueInput
    data: XOR<PlantingUpdateWithoutGermplasmInput, PlantingUncheckedUpdateWithoutGermplasmInput>
  }

  export type PlantingUpdateManyWithWhereWithoutGermplasmInput = {
    where: PlantingScalarWhereInput
    data: XOR<PlantingUpdateManyMutationInput, PlantingUncheckedUpdateManyWithoutGermplasmInput>
  }

  export type PlantingScalarWhereInput = {
    AND?: PlantingScalarWhereInput | PlantingScalarWhereInput[]
    OR?: PlantingScalarWhereInput[]
    NOT?: PlantingScalarWhereInput | PlantingScalarWhereInput[]
    id?: StringFilter<"Planting"> | string
    experimentId?: StringFilter<"Planting"> | string
    plotId?: StringNullableFilter<"Planting"> | string | null
    germplasmId?: StringFilter<"Planting"> | string
    seedLotId?: StringNullableFilter<"Planting"> | string | null
    plantingDate?: DateTimeFilter<"Planting"> | Date | string
    plantingMethod?: StringNullableFilter<"Planting"> | string | null
    seedingRate?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: StringNullableFilter<"Planting"> | string | null
    seedsPerHill?: IntNullableFilter<"Planting"> | number | null
    seedDepth?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: StringNullableFilter<"Planting"> | string | null
    rowSpacing?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: StringNullableFilter<"Planting"> | string | null
    plantedArea?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: StringNullableFilter<"Planting"> | string | null
    numberOfRows?: IntNullableFilter<"Planting"> | number | null
    plantsPerRow?: IntNullableFilter<"Planting"> | number | null
    totalPlantsExpected?: IntNullableFilter<"Planting"> | number | null
    germinationDate?: DateTimeNullableFilter<"Planting"> | Date | string | null
    emergenceDate?: DateTimeNullableFilter<"Planting"> | Date | string | null
    germinationCount?: IntNullableFilter<"Planting"> | number | null
    germinationPercentage?: DecimalNullableFilter<"Planting"> | Decimal | DecimalJsLike | number | string | null
    thinningDate?: DateTimeNullableFilter<"Planting"> | Date | string | null
    finalPlantCount?: IntNullableFilter<"Planting"> | number | null
    plantedBy?: StringFilter<"Planting"> | string
    notes?: StringNullableFilter<"Planting"> | string | null
    notesAr?: StringNullableFilter<"Planting"> | string | null
    photos?: StringNullableListFilter<"Planting">
    metadata?: JsonFilter<"Planting">
    createdAt?: DateTimeFilter<"Planting"> | Date | string
    updatedAt?: DateTimeFilter<"Planting"> | Date | string
  }

  export type GermplasmCreateWithoutSeedLotsInput = {
    id?: string
    accessionNumber: string
    commonName: string
    commonNameAr?: string | null
    scientificName?: string | null
    genus?: string | null
    species?: string | null
    subspecies?: string | null
    cultivar?: string | null
    variety?: string | null
    pedigree?: string | null
    type?: $Enums.GermplasmType
    countryOfOrigin?: string | null
    regionOfOrigin?: string | null
    collectionSite?: string | null
    collectionDate?: Date | string | null
    collectedBy?: string | null
    donorInstitution?: string | null
    donorAccessionNumber?: string | null
    growthHabit?: string | null
    maturityDays?: number | null
    yieldPotential?: string | null
    droughtTolerance?: string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: string | null
    storageConditions?: string | null
    storageTemperature?: Decimal | DecimalJsLike | number | string | null
    storageHumidity?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    quantityAvailable?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    description?: string | null
    descriptionAr?: string | null
    photos?: GermplasmCreatephotosInput | string[]
    documents?: GermplasmCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plantings?: PlantingCreateNestedManyWithoutGermplasmInput
  }

  export type GermplasmUncheckedCreateWithoutSeedLotsInput = {
    id?: string
    accessionNumber: string
    commonName: string
    commonNameAr?: string | null
    scientificName?: string | null
    genus?: string | null
    species?: string | null
    subspecies?: string | null
    cultivar?: string | null
    variety?: string | null
    pedigree?: string | null
    type?: $Enums.GermplasmType
    countryOfOrigin?: string | null
    regionOfOrigin?: string | null
    collectionSite?: string | null
    collectionDate?: Date | string | null
    collectedBy?: string | null
    donorInstitution?: string | null
    donorAccessionNumber?: string | null
    growthHabit?: string | null
    maturityDays?: number | null
    yieldPotential?: string | null
    droughtTolerance?: string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: string | null
    storageConditions?: string | null
    storageTemperature?: Decimal | DecimalJsLike | number | string | null
    storageHumidity?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    quantityAvailable?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    description?: string | null
    descriptionAr?: string | null
    photos?: GermplasmCreatephotosInput | string[]
    documents?: GermplasmCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plantings?: PlantingUncheckedCreateNestedManyWithoutGermplasmInput
  }

  export type GermplasmCreateOrConnectWithoutSeedLotsInput = {
    where: GermplasmWhereUniqueInput
    create: XOR<GermplasmCreateWithoutSeedLotsInput, GermplasmUncheckedCreateWithoutSeedLotsInput>
  }

  export type PlantingCreateWithoutSeedLotInput = {
    id?: string
    plotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutPlantingsInput
    germplasm: GermplasmCreateNestedOneWithoutPlantingsInput
  }

  export type PlantingUncheckedCreateWithoutSeedLotInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    germplasmId: string
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantingCreateOrConnectWithoutSeedLotInput = {
    where: PlantingWhereUniqueInput
    create: XOR<PlantingCreateWithoutSeedLotInput, PlantingUncheckedCreateWithoutSeedLotInput>
  }

  export type PlantingCreateManySeedLotInputEnvelope = {
    data: PlantingCreateManySeedLotInput | PlantingCreateManySeedLotInput[]
    skipDuplicates?: boolean
  }

  export type GermplasmUpsertWithoutSeedLotsInput = {
    update: XOR<GermplasmUpdateWithoutSeedLotsInput, GermplasmUncheckedUpdateWithoutSeedLotsInput>
    create: XOR<GermplasmCreateWithoutSeedLotsInput, GermplasmUncheckedCreateWithoutSeedLotsInput>
    where?: GermplasmWhereInput
  }

  export type GermplasmUpdateToOneWithWhereWithoutSeedLotsInput = {
    where?: GermplasmWhereInput
    data: XOR<GermplasmUpdateWithoutSeedLotsInput, GermplasmUncheckedUpdateWithoutSeedLotsInput>
  }

  export type GermplasmUpdateWithoutSeedLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNumber?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    commonNameAr?: NullableStringFieldUpdateOperationsInput | string | null
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    subspecies?: NullableStringFieldUpdateOperationsInput | string | null
    cultivar?: NullableStringFieldUpdateOperationsInput | string | null
    variety?: NullableStringFieldUpdateOperationsInput | string | null
    pedigree?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGermplasmTypeFieldUpdateOperationsInput | $Enums.GermplasmType
    countryOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    regionOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    collectionSite?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    donorInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    donorAccessionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    maturityDays?: NullableIntFieldUpdateOperationsInput | number | null
    yieldPotential?: NullableStringFieldUpdateOperationsInput | string | null
    droughtTolerance?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    storageTemperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    quantityAvailable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: GermplasmUpdatephotosInput | string[]
    documents?: GermplasmUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantings?: PlantingUpdateManyWithoutGermplasmNestedInput
  }

  export type GermplasmUncheckedUpdateWithoutSeedLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNumber?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    commonNameAr?: NullableStringFieldUpdateOperationsInput | string | null
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    subspecies?: NullableStringFieldUpdateOperationsInput | string | null
    cultivar?: NullableStringFieldUpdateOperationsInput | string | null
    variety?: NullableStringFieldUpdateOperationsInput | string | null
    pedigree?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGermplasmTypeFieldUpdateOperationsInput | $Enums.GermplasmType
    countryOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    regionOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    collectionSite?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    donorInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    donorAccessionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    maturityDays?: NullableIntFieldUpdateOperationsInput | number | null
    yieldPotential?: NullableStringFieldUpdateOperationsInput | string | null
    droughtTolerance?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    storageTemperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    quantityAvailable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: GermplasmUpdatephotosInput | string[]
    documents?: GermplasmUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantings?: PlantingUncheckedUpdateManyWithoutGermplasmNestedInput
  }

  export type PlantingUpsertWithWhereUniqueWithoutSeedLotInput = {
    where: PlantingWhereUniqueInput
    update: XOR<PlantingUpdateWithoutSeedLotInput, PlantingUncheckedUpdateWithoutSeedLotInput>
    create: XOR<PlantingCreateWithoutSeedLotInput, PlantingUncheckedCreateWithoutSeedLotInput>
  }

  export type PlantingUpdateWithWhereUniqueWithoutSeedLotInput = {
    where: PlantingWhereUniqueInput
    data: XOR<PlantingUpdateWithoutSeedLotInput, PlantingUncheckedUpdateWithoutSeedLotInput>
  }

  export type PlantingUpdateManyWithWhereWithoutSeedLotInput = {
    where: PlantingScalarWhereInput
    data: XOR<PlantingUpdateManyMutationInput, PlantingUncheckedUpdateManyWithoutSeedLotInput>
  }

  export type ExperimentCreateWithoutPlantingsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogCreateNestedManyWithoutExperimentInput
    samples?: LabSampleCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUncheckedCreateWithoutPlantingsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolUncheckedCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotUncheckedCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentUncheckedCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutExperimentInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorUncheckedCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogUncheckedCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentCreateOrConnectWithoutPlantingsInput = {
    where: ExperimentWhereUniqueInput
    create: XOR<ExperimentCreateWithoutPlantingsInput, ExperimentUncheckedCreateWithoutPlantingsInput>
  }

  export type GermplasmCreateWithoutPlantingsInput = {
    id?: string
    accessionNumber: string
    commonName: string
    commonNameAr?: string | null
    scientificName?: string | null
    genus?: string | null
    species?: string | null
    subspecies?: string | null
    cultivar?: string | null
    variety?: string | null
    pedigree?: string | null
    type?: $Enums.GermplasmType
    countryOfOrigin?: string | null
    regionOfOrigin?: string | null
    collectionSite?: string | null
    collectionDate?: Date | string | null
    collectedBy?: string | null
    donorInstitution?: string | null
    donorAccessionNumber?: string | null
    growthHabit?: string | null
    maturityDays?: number | null
    yieldPotential?: string | null
    droughtTolerance?: string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: string | null
    storageConditions?: string | null
    storageTemperature?: Decimal | DecimalJsLike | number | string | null
    storageHumidity?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    quantityAvailable?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    description?: string | null
    descriptionAr?: string | null
    photos?: GermplasmCreatephotosInput | string[]
    documents?: GermplasmCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    seedLots?: SeedLotCreateNestedManyWithoutGermplasmInput
  }

  export type GermplasmUncheckedCreateWithoutPlantingsInput = {
    id?: string
    accessionNumber: string
    commonName: string
    commonNameAr?: string | null
    scientificName?: string | null
    genus?: string | null
    species?: string | null
    subspecies?: string | null
    cultivar?: string | null
    variety?: string | null
    pedigree?: string | null
    type?: $Enums.GermplasmType
    countryOfOrigin?: string | null
    regionOfOrigin?: string | null
    collectionSite?: string | null
    collectionDate?: Date | string | null
    collectedBy?: string | null
    donorInstitution?: string | null
    donorAccessionNumber?: string | null
    growthHabit?: string | null
    maturityDays?: number | null
    yieldPotential?: string | null
    droughtTolerance?: string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: string | null
    storageConditions?: string | null
    storageTemperature?: Decimal | DecimalJsLike | number | string | null
    storageHumidity?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    quantityAvailable?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    description?: string | null
    descriptionAr?: string | null
    photos?: GermplasmCreatephotosInput | string[]
    documents?: GermplasmCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    seedLots?: SeedLotUncheckedCreateNestedManyWithoutGermplasmInput
  }

  export type GermplasmCreateOrConnectWithoutPlantingsInput = {
    where: GermplasmWhereUniqueInput
    create: XOR<GermplasmCreateWithoutPlantingsInput, GermplasmUncheckedCreateWithoutPlantingsInput>
  }

  export type SeedLotCreateWithoutPlantingsInput = {
    id?: string
    lotNumber: string
    initialQuantity: Decimal | DecimalJsLike | number | string
    currentQuantity: Decimal | DecimalJsLike | number | string
    quantityUnit: string
    seedCount?: number | null
    thousandSeedWeight?: Decimal | DecimalJsLike | number | string | null
    qualityGrade?: $Enums.SeedQualityGrade
    germinationRate?: Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: Date | string | null
    purityPercentage?: Decimal | DecimalJsLike | number | string | null
    moistureContent?: Decimal | DecimalJsLike | number | string | null
    vigorIndex?: Decimal | DecimalJsLike | number | string | null
    productionDate?: Date | string | null
    harvestDate?: Date | string | null
    productionLocation?: string | null
    productionSeason?: string | null
    producedBy?: string | null
    certificationNumber?: string | null
    certifiedBy?: string | null
    certificationDate?: Date | string | null
    expiryDate?: Date | string | null
    isTreated?: boolean
    treatmentType?: string | null
    treatmentProduct?: string | null
    treatmentDate?: Date | string | null
    storageLocation?: string | null
    storageConditions?: string | null
    notes?: string | null
    notesAr?: string | null
    photos?: SeedLotCreatephotosInput | string[]
    documents?: SeedLotCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    germplasm: GermplasmCreateNestedOneWithoutSeedLotsInput
  }

  export type SeedLotUncheckedCreateWithoutPlantingsInput = {
    id?: string
    germplasmId: string
    lotNumber: string
    initialQuantity: Decimal | DecimalJsLike | number | string
    currentQuantity: Decimal | DecimalJsLike | number | string
    quantityUnit: string
    seedCount?: number | null
    thousandSeedWeight?: Decimal | DecimalJsLike | number | string | null
    qualityGrade?: $Enums.SeedQualityGrade
    germinationRate?: Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: Date | string | null
    purityPercentage?: Decimal | DecimalJsLike | number | string | null
    moistureContent?: Decimal | DecimalJsLike | number | string | null
    vigorIndex?: Decimal | DecimalJsLike | number | string | null
    productionDate?: Date | string | null
    harvestDate?: Date | string | null
    productionLocation?: string | null
    productionSeason?: string | null
    producedBy?: string | null
    certificationNumber?: string | null
    certifiedBy?: string | null
    certificationDate?: Date | string | null
    expiryDate?: Date | string | null
    isTreated?: boolean
    treatmentType?: string | null
    treatmentProduct?: string | null
    treatmentDate?: Date | string | null
    storageLocation?: string | null
    storageConditions?: string | null
    notes?: string | null
    notesAr?: string | null
    photos?: SeedLotCreatephotosInput | string[]
    documents?: SeedLotCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeedLotCreateOrConnectWithoutPlantingsInput = {
    where: SeedLotWhereUniqueInput
    create: XOR<SeedLotCreateWithoutPlantingsInput, SeedLotUncheckedCreateWithoutPlantingsInput>
  }

  export type ExperimentUpsertWithoutPlantingsInput = {
    update: XOR<ExperimentUpdateWithoutPlantingsInput, ExperimentUncheckedUpdateWithoutPlantingsInput>
    create: XOR<ExperimentCreateWithoutPlantingsInput, ExperimentUncheckedCreateWithoutPlantingsInput>
    where?: ExperimentWhereInput
  }

  export type ExperimentUpdateToOneWithWhereWithoutPlantingsInput = {
    where?: ExperimentWhereInput
    data: XOR<ExperimentUpdateWithoutPlantingsInput, ExperimentUncheckedUpdateWithoutPlantingsInput>
  }

  export type ExperimentUpdateWithoutPlantingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentUncheckedUpdateWithoutPlantingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUncheckedUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUncheckedUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUncheckedUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUncheckedUpdateManyWithoutExperimentNestedInput
  }

  export type GermplasmUpsertWithoutPlantingsInput = {
    update: XOR<GermplasmUpdateWithoutPlantingsInput, GermplasmUncheckedUpdateWithoutPlantingsInput>
    create: XOR<GermplasmCreateWithoutPlantingsInput, GermplasmUncheckedCreateWithoutPlantingsInput>
    where?: GermplasmWhereInput
  }

  export type GermplasmUpdateToOneWithWhereWithoutPlantingsInput = {
    where?: GermplasmWhereInput
    data: XOR<GermplasmUpdateWithoutPlantingsInput, GermplasmUncheckedUpdateWithoutPlantingsInput>
  }

  export type GermplasmUpdateWithoutPlantingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNumber?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    commonNameAr?: NullableStringFieldUpdateOperationsInput | string | null
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    subspecies?: NullableStringFieldUpdateOperationsInput | string | null
    cultivar?: NullableStringFieldUpdateOperationsInput | string | null
    variety?: NullableStringFieldUpdateOperationsInput | string | null
    pedigree?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGermplasmTypeFieldUpdateOperationsInput | $Enums.GermplasmType
    countryOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    regionOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    collectionSite?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    donorInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    donorAccessionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    maturityDays?: NullableIntFieldUpdateOperationsInput | number | null
    yieldPotential?: NullableStringFieldUpdateOperationsInput | string | null
    droughtTolerance?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    storageTemperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    quantityAvailable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: GermplasmUpdatephotosInput | string[]
    documents?: GermplasmUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seedLots?: SeedLotUpdateManyWithoutGermplasmNestedInput
  }

  export type GermplasmUncheckedUpdateWithoutPlantingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessionNumber?: StringFieldUpdateOperationsInput | string
    commonName?: StringFieldUpdateOperationsInput | string
    commonNameAr?: NullableStringFieldUpdateOperationsInput | string | null
    scientificName?: NullableStringFieldUpdateOperationsInput | string | null
    genus?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    subspecies?: NullableStringFieldUpdateOperationsInput | string | null
    cultivar?: NullableStringFieldUpdateOperationsInput | string | null
    variety?: NullableStringFieldUpdateOperationsInput | string | null
    pedigree?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumGermplasmTypeFieldUpdateOperationsInput | $Enums.GermplasmType
    countryOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    regionOfOrigin?: NullableStringFieldUpdateOperationsInput | string | null
    collectionSite?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    donorInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    donorAccessionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    growthHabit?: NullableStringFieldUpdateOperationsInput | string | null
    maturityDays?: NullableIntFieldUpdateOperationsInput | number | null
    yieldPotential?: NullableStringFieldUpdateOperationsInput | string | null
    droughtTolerance?: NullableStringFieldUpdateOperationsInput | string | null
    diseaseResistance?: JsonNullValueInput | InputJsonValue
    pestResistance?: JsonNullValueInput | InputJsonValue
    qualityTraits?: JsonNullValueInput | InputJsonValue
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    storageTemperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    storageHumidity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    quantityAvailable?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: GermplasmUpdatephotosInput | string[]
    documents?: GermplasmUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seedLots?: SeedLotUncheckedUpdateManyWithoutGermplasmNestedInput
  }

  export type SeedLotUpsertWithoutPlantingsInput = {
    update: XOR<SeedLotUpdateWithoutPlantingsInput, SeedLotUncheckedUpdateWithoutPlantingsInput>
    create: XOR<SeedLotCreateWithoutPlantingsInput, SeedLotUncheckedCreateWithoutPlantingsInput>
    where?: SeedLotWhereInput
  }

  export type SeedLotUpdateToOneWithWhereWithoutPlantingsInput = {
    where?: SeedLotWhereInput
    data: XOR<SeedLotUpdateWithoutPlantingsInput, SeedLotUncheckedUpdateWithoutPlantingsInput>
  }

  export type SeedLotUpdateWithoutPlantingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    initialQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFieldUpdateOperationsInput | string
    seedCount?: NullableIntFieldUpdateOperationsInput | number | null
    thousandSeedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFieldUpdateOperationsInput | $Enums.SeedQualityGrade
    germinationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purityPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moistureContent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    productionSeason?: NullableStringFieldUpdateOperationsInput | string | null
    producedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    treatmentType?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentProduct?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SeedLotUpdatephotosInput | string[]
    documents?: SeedLotUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    germplasm?: GermplasmUpdateOneRequiredWithoutSeedLotsNestedInput
  }

  export type SeedLotUncheckedUpdateWithoutPlantingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    germplasmId?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    initialQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFieldUpdateOperationsInput | string
    seedCount?: NullableIntFieldUpdateOperationsInput | number | null
    thousandSeedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFieldUpdateOperationsInput | $Enums.SeedQualityGrade
    germinationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purityPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moistureContent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    productionSeason?: NullableStringFieldUpdateOperationsInput | string | null
    producedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    treatmentType?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentProduct?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SeedLotUpdatephotosInput | string[]
    documents?: SeedLotUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProtocolCreateWithoutExperimentInput = {
    id?: string
    name: string
    nameAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    methodology: string
    methodologyAr?: string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolCreateequipmentRequiredInput | string[]
    safetyGuidelines?: string | null
    version?: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchProtocolUncheckedCreateWithoutExperimentInput = {
    id?: string
    name: string
    nameAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    methodology: string
    methodologyAr?: string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolCreateequipmentRequiredInput | string[]
    safetyGuidelines?: string | null
    version?: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchProtocolCreateOrConnectWithoutExperimentInput = {
    where: ResearchProtocolWhereUniqueInput
    create: XOR<ResearchProtocolCreateWithoutExperimentInput, ResearchProtocolUncheckedCreateWithoutExperimentInput>
  }

  export type ResearchProtocolCreateManyExperimentInputEnvelope = {
    data: ResearchProtocolCreateManyExperimentInput | ResearchProtocolCreateManyExperimentInput[]
    skipDuplicates?: boolean
  }

  export type ResearchPlotCreateWithoutExperimentInput = {
    id?: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    treatments?: TreatmentCreateNestedManyWithoutPlotInput
    logs?: ResearchDailyLogCreateNestedManyWithoutPlotInput
    samples?: LabSampleCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotUncheckedCreateWithoutExperimentInput = {
    id?: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    treatments?: TreatmentUncheckedCreateNestedManyWithoutPlotInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutPlotInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotCreateOrConnectWithoutExperimentInput = {
    where: ResearchPlotWhereUniqueInput
    create: XOR<ResearchPlotCreateWithoutExperimentInput, ResearchPlotUncheckedCreateWithoutExperimentInput>
  }

  export type ResearchPlotCreateManyExperimentInputEnvelope = {
    data: ResearchPlotCreateManyExperimentInput | ResearchPlotCreateManyExperimentInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentCreateWithoutExperimentInput = {
    id?: string
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plot?: ResearchPlotCreateNestedOneWithoutTreatmentsInput
    logs?: ResearchDailyLogCreateNestedManyWithoutTreatmentInput
  }

  export type TreatmentUncheckedCreateWithoutExperimentInput = {
    id?: string
    plotId?: string | null
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutTreatmentInput
  }

  export type TreatmentCreateOrConnectWithoutExperimentInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutExperimentInput, TreatmentUncheckedCreateWithoutExperimentInput>
  }

  export type TreatmentCreateManyExperimentInputEnvelope = {
    data: TreatmentCreateManyExperimentInput | TreatmentCreateManyExperimentInput[]
    skipDuplicates?: boolean
  }

  export type ResearchDailyLogCreateWithoutExperimentInput = {
    id?: string
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plot?: ResearchPlotCreateNestedOneWithoutLogsInput
    treatment?: TreatmentCreateNestedOneWithoutLogsInput
    samples?: LabSampleCreateNestedManyWithoutLogInput
  }

  export type ResearchDailyLogUncheckedCreateWithoutExperimentInput = {
    id?: string
    plotId?: string | null
    treatmentId?: string | null
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: LabSampleUncheckedCreateNestedManyWithoutLogInput
  }

  export type ResearchDailyLogCreateOrConnectWithoutExperimentInput = {
    where: ResearchDailyLogWhereUniqueInput
    create: XOR<ResearchDailyLogCreateWithoutExperimentInput, ResearchDailyLogUncheckedCreateWithoutExperimentInput>
  }

  export type ResearchDailyLogCreateManyExperimentInputEnvelope = {
    data: ResearchDailyLogCreateManyExperimentInput | ResearchDailyLogCreateManyExperimentInput[]
    skipDuplicates?: boolean
  }

  export type LabSampleCreateWithoutExperimentInput = {
    id?: string
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    plot?: ResearchPlotCreateNestedOneWithoutSamplesInput
    log?: ResearchDailyLogCreateNestedOneWithoutSamplesInput
  }

  export type LabSampleUncheckedCreateWithoutExperimentInput = {
    id?: string
    plotId?: string | null
    logId?: string | null
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabSampleCreateOrConnectWithoutExperimentInput = {
    where: LabSampleWhereUniqueInput
    create: XOR<LabSampleCreateWithoutExperimentInput, LabSampleUncheckedCreateWithoutExperimentInput>
  }

  export type LabSampleCreateManyExperimentInputEnvelope = {
    data: LabSampleCreateManyExperimentInput | LabSampleCreateManyExperimentInput[]
    skipDuplicates?: boolean
  }

  export type ExperimentCollaboratorCreateWithoutExperimentInput = {
    id?: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ExperimentCollaboratorUncheckedCreateWithoutExperimentInput = {
    id?: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ExperimentCollaboratorCreateOrConnectWithoutExperimentInput = {
    where: ExperimentCollaboratorWhereUniqueInput
    create: XOR<ExperimentCollaboratorCreateWithoutExperimentInput, ExperimentCollaboratorUncheckedCreateWithoutExperimentInput>
  }

  export type ExperimentCollaboratorCreateManyExperimentInputEnvelope = {
    data: ExperimentCollaboratorCreateManyExperimentInput | ExperimentCollaboratorCreateManyExperimentInput[]
    skipDuplicates?: boolean
  }

  export type ExperimentAuditLogCreateWithoutExperimentInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy: string
    changedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ExperimentAuditLogUncheckedCreateWithoutExperimentInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy: string
    changedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type ExperimentAuditLogCreateOrConnectWithoutExperimentInput = {
    where: ExperimentAuditLogWhereUniqueInput
    create: XOR<ExperimentAuditLogCreateWithoutExperimentInput, ExperimentAuditLogUncheckedCreateWithoutExperimentInput>
  }

  export type ExperimentAuditLogCreateManyExperimentInputEnvelope = {
    data: ExperimentAuditLogCreateManyExperimentInput | ExperimentAuditLogCreateManyExperimentInput[]
    skipDuplicates?: boolean
  }

  export type PlantingCreateWithoutExperimentInput = {
    id?: string
    plotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    germplasm: GermplasmCreateNestedOneWithoutPlantingsInput
    seedLot?: SeedLotCreateNestedOneWithoutPlantingsInput
  }

  export type PlantingUncheckedCreateWithoutExperimentInput = {
    id?: string
    plotId?: string | null
    germplasmId: string
    seedLotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantingCreateOrConnectWithoutExperimentInput = {
    where: PlantingWhereUniqueInput
    create: XOR<PlantingCreateWithoutExperimentInput, PlantingUncheckedCreateWithoutExperimentInput>
  }

  export type PlantingCreateManyExperimentInputEnvelope = {
    data: PlantingCreateManyExperimentInput | PlantingCreateManyExperimentInput[]
    skipDuplicates?: boolean
  }

  export type ResearchProtocolUpsertWithWhereUniqueWithoutExperimentInput = {
    where: ResearchProtocolWhereUniqueInput
    update: XOR<ResearchProtocolUpdateWithoutExperimentInput, ResearchProtocolUncheckedUpdateWithoutExperimentInput>
    create: XOR<ResearchProtocolCreateWithoutExperimentInput, ResearchProtocolUncheckedCreateWithoutExperimentInput>
  }

  export type ResearchProtocolUpdateWithWhereUniqueWithoutExperimentInput = {
    where: ResearchProtocolWhereUniqueInput
    data: XOR<ResearchProtocolUpdateWithoutExperimentInput, ResearchProtocolUncheckedUpdateWithoutExperimentInput>
  }

  export type ResearchProtocolUpdateManyWithWhereWithoutExperimentInput = {
    where: ResearchProtocolScalarWhereInput
    data: XOR<ResearchProtocolUpdateManyMutationInput, ResearchProtocolUncheckedUpdateManyWithoutExperimentInput>
  }

  export type ResearchProtocolScalarWhereInput = {
    AND?: ResearchProtocolScalarWhereInput | ResearchProtocolScalarWhereInput[]
    OR?: ResearchProtocolScalarWhereInput[]
    NOT?: ResearchProtocolScalarWhereInput | ResearchProtocolScalarWhereInput[]
    id?: StringFilter<"ResearchProtocol"> | string
    experimentId?: StringFilter<"ResearchProtocol"> | string
    name?: StringFilter<"ResearchProtocol"> | string
    nameAr?: StringNullableFilter<"ResearchProtocol"> | string | null
    description?: StringNullableFilter<"ResearchProtocol"> | string | null
    descriptionAr?: StringNullableFilter<"ResearchProtocol"> | string | null
    methodology?: StringFilter<"ResearchProtocol"> | string
    methodologyAr?: StringNullableFilter<"ResearchProtocol"> | string | null
    variables?: JsonFilter<"ResearchProtocol">
    measurementSchedule?: JsonFilter<"ResearchProtocol">
    equipmentRequired?: StringNullableListFilter<"ResearchProtocol">
    safetyGuidelines?: StringNullableFilter<"ResearchProtocol"> | string | null
    version?: IntFilter<"ResearchProtocol"> | number
    approvedBy?: StringNullableFilter<"ResearchProtocol"> | string | null
    approvedAt?: DateTimeNullableFilter<"ResearchProtocol"> | Date | string | null
    createdAt?: DateTimeFilter<"ResearchProtocol"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchProtocol"> | Date | string
  }

  export type ResearchPlotUpsertWithWhereUniqueWithoutExperimentInput = {
    where: ResearchPlotWhereUniqueInput
    update: XOR<ResearchPlotUpdateWithoutExperimentInput, ResearchPlotUncheckedUpdateWithoutExperimentInput>
    create: XOR<ResearchPlotCreateWithoutExperimentInput, ResearchPlotUncheckedCreateWithoutExperimentInput>
  }

  export type ResearchPlotUpdateWithWhereUniqueWithoutExperimentInput = {
    where: ResearchPlotWhereUniqueInput
    data: XOR<ResearchPlotUpdateWithoutExperimentInput, ResearchPlotUncheckedUpdateWithoutExperimentInput>
  }

  export type ResearchPlotUpdateManyWithWhereWithoutExperimentInput = {
    where: ResearchPlotScalarWhereInput
    data: XOR<ResearchPlotUpdateManyMutationInput, ResearchPlotUncheckedUpdateManyWithoutExperimentInput>
  }

  export type ResearchPlotScalarWhereInput = {
    AND?: ResearchPlotScalarWhereInput | ResearchPlotScalarWhereInput[]
    OR?: ResearchPlotScalarWhereInput[]
    NOT?: ResearchPlotScalarWhereInput | ResearchPlotScalarWhereInput[]
    id?: StringFilter<"ResearchPlot"> | string
    experimentId?: StringFilter<"ResearchPlot"> | string
    plotCode?: StringFilter<"ResearchPlot"> | string
    name?: StringNullableFilter<"ResearchPlot"> | string | null
    nameAr?: StringNullableFilter<"ResearchPlot"> | string | null
    areaSqm?: DecimalNullableFilter<"ResearchPlot"> | Decimal | DecimalJsLike | number | string | null
    soilType?: StringNullableFilter<"ResearchPlot"> | string | null
    soilPh?: DecimalNullableFilter<"ResearchPlot"> | Decimal | DecimalJsLike | number | string | null
    previousCrop?: StringNullableFilter<"ResearchPlot"> | string | null
    replicateNumber?: IntFilter<"ResearchPlot"> | number
    blockNumber?: IntNullableFilter<"ResearchPlot"> | number | null
    rowNumber?: IntNullableFilter<"ResearchPlot"> | number | null
    columnNumber?: IntNullableFilter<"ResearchPlot"> | number | null
    metadata?: JsonFilter<"ResearchPlot">
    createdAt?: DateTimeFilter<"ResearchPlot"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchPlot"> | Date | string
  }

  export type TreatmentUpsertWithWhereUniqueWithoutExperimentInput = {
    where: TreatmentWhereUniqueInput
    update: XOR<TreatmentUpdateWithoutExperimentInput, TreatmentUncheckedUpdateWithoutExperimentInput>
    create: XOR<TreatmentCreateWithoutExperimentInput, TreatmentUncheckedCreateWithoutExperimentInput>
  }

  export type TreatmentUpdateWithWhereUniqueWithoutExperimentInput = {
    where: TreatmentWhereUniqueInput
    data: XOR<TreatmentUpdateWithoutExperimentInput, TreatmentUncheckedUpdateWithoutExperimentInput>
  }

  export type TreatmentUpdateManyWithWhereWithoutExperimentInput = {
    where: TreatmentScalarWhereInput
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyWithoutExperimentInput>
  }

  export type TreatmentScalarWhereInput = {
    AND?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
    OR?: TreatmentScalarWhereInput[]
    NOT?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
    id?: StringFilter<"Treatment"> | string
    experimentId?: StringFilter<"Treatment"> | string
    plotId?: StringNullableFilter<"Treatment"> | string | null
    treatmentCode?: StringFilter<"Treatment"> | string
    name?: StringFilter<"Treatment"> | string
    nameAr?: StringNullableFilter<"Treatment"> | string | null
    type?: EnumTreatmentTypeFilter<"Treatment"> | $Enums.TreatmentType
    description?: StringNullableFilter<"Treatment"> | string | null
    descriptionAr?: StringNullableFilter<"Treatment"> | string | null
    dosage?: StringNullableFilter<"Treatment"> | string | null
    dosageUnit?: StringNullableFilter<"Treatment"> | string | null
    applicationMethod?: StringNullableFilter<"Treatment"> | string | null
    applicationFrequency?: StringNullableFilter<"Treatment"> | string | null
    startDate?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Treatment"> | Date | string | null
    isControl?: BoolFilter<"Treatment"> | boolean
    parameters?: JsonFilter<"Treatment">
    createdAt?: DateTimeFilter<"Treatment"> | Date | string
    updatedAt?: DateTimeFilter<"Treatment"> | Date | string
  }

  export type ResearchDailyLogUpsertWithWhereUniqueWithoutExperimentInput = {
    where: ResearchDailyLogWhereUniqueInput
    update: XOR<ResearchDailyLogUpdateWithoutExperimentInput, ResearchDailyLogUncheckedUpdateWithoutExperimentInput>
    create: XOR<ResearchDailyLogCreateWithoutExperimentInput, ResearchDailyLogUncheckedCreateWithoutExperimentInput>
  }

  export type ResearchDailyLogUpdateWithWhereUniqueWithoutExperimentInput = {
    where: ResearchDailyLogWhereUniqueInput
    data: XOR<ResearchDailyLogUpdateWithoutExperimentInput, ResearchDailyLogUncheckedUpdateWithoutExperimentInput>
  }

  export type ResearchDailyLogUpdateManyWithWhereWithoutExperimentInput = {
    where: ResearchDailyLogScalarWhereInput
    data: XOR<ResearchDailyLogUpdateManyMutationInput, ResearchDailyLogUncheckedUpdateManyWithoutExperimentInput>
  }

  export type ResearchDailyLogScalarWhereInput = {
    AND?: ResearchDailyLogScalarWhereInput | ResearchDailyLogScalarWhereInput[]
    OR?: ResearchDailyLogScalarWhereInput[]
    NOT?: ResearchDailyLogScalarWhereInput | ResearchDailyLogScalarWhereInput[]
    id?: StringFilter<"ResearchDailyLog"> | string
    experimentId?: StringFilter<"ResearchDailyLog"> | string
    plotId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    treatmentId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    logDate?: DateTimeFilter<"ResearchDailyLog"> | Date | string
    logTime?: StringNullableFilter<"ResearchDailyLog"> | string | null
    category?: EnumLogCategoryFilter<"ResearchDailyLog"> | $Enums.LogCategory
    title?: StringFilter<"ResearchDailyLog"> | string
    titleAr?: StringNullableFilter<"ResearchDailyLog"> | string | null
    notes?: StringNullableFilter<"ResearchDailyLog"> | string | null
    notesAr?: StringNullableFilter<"ResearchDailyLog"> | string | null
    measurements?: JsonFilter<"ResearchDailyLog">
    weatherConditions?: JsonFilter<"ResearchDailyLog">
    photos?: StringNullableListFilter<"ResearchDailyLog">
    attachments?: StringNullableListFilter<"ResearchDailyLog">
    recordedBy?: StringFilter<"ResearchDailyLog"> | string
    deviceId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    offlineId?: StringNullableFilter<"ResearchDailyLog"> | string | null
    hash?: StringNullableFilter<"ResearchDailyLog"> | string | null
    syncedAt?: DateTimeNullableFilter<"ResearchDailyLog"> | Date | string | null
    createdAt?: DateTimeFilter<"ResearchDailyLog"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchDailyLog"> | Date | string
  }

  export type LabSampleUpsertWithWhereUniqueWithoutExperimentInput = {
    where: LabSampleWhereUniqueInput
    update: XOR<LabSampleUpdateWithoutExperimentInput, LabSampleUncheckedUpdateWithoutExperimentInput>
    create: XOR<LabSampleCreateWithoutExperimentInput, LabSampleUncheckedCreateWithoutExperimentInput>
  }

  export type LabSampleUpdateWithWhereUniqueWithoutExperimentInput = {
    where: LabSampleWhereUniqueInput
    data: XOR<LabSampleUpdateWithoutExperimentInput, LabSampleUncheckedUpdateWithoutExperimentInput>
  }

  export type LabSampleUpdateManyWithWhereWithoutExperimentInput = {
    where: LabSampleScalarWhereInput
    data: XOR<LabSampleUpdateManyMutationInput, LabSampleUncheckedUpdateManyWithoutExperimentInput>
  }

  export type LabSampleScalarWhereInput = {
    AND?: LabSampleScalarWhereInput | LabSampleScalarWhereInput[]
    OR?: LabSampleScalarWhereInput[]
    NOT?: LabSampleScalarWhereInput | LabSampleScalarWhereInput[]
    id?: StringFilter<"LabSample"> | string
    experimentId?: StringFilter<"LabSample"> | string
    plotId?: StringNullableFilter<"LabSample"> | string | null
    logId?: StringNullableFilter<"LabSample"> | string | null
    sampleCode?: StringFilter<"LabSample"> | string
    type?: EnumSampleTypeFilter<"LabSample"> | $Enums.SampleType
    description?: StringNullableFilter<"LabSample"> | string | null
    descriptionAr?: StringNullableFilter<"LabSample"> | string | null
    collectionDate?: DateTimeFilter<"LabSample"> | Date | string
    collectionTime?: StringNullableFilter<"LabSample"> | string | null
    collectedBy?: StringFilter<"LabSample"> | string
    storageLocation?: StringNullableFilter<"LabSample"> | string | null
    storageConditions?: StringNullableFilter<"LabSample"> | string | null
    quantity?: DecimalNullableFilter<"LabSample"> | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: StringNullableFilter<"LabSample"> | string | null
    analysisStatus?: StringFilter<"LabSample"> | string
    analysisResults?: JsonFilter<"LabSample">
    analyzedBy?: StringNullableFilter<"LabSample"> | string | null
    analyzedAt?: DateTimeNullableFilter<"LabSample"> | Date | string | null
    photos?: StringNullableListFilter<"LabSample">
    metadata?: JsonFilter<"LabSample">
    createdAt?: DateTimeFilter<"LabSample"> | Date | string
    updatedAt?: DateTimeFilter<"LabSample"> | Date | string
  }

  export type ExperimentCollaboratorUpsertWithWhereUniqueWithoutExperimentInput = {
    where: ExperimentCollaboratorWhereUniqueInput
    update: XOR<ExperimentCollaboratorUpdateWithoutExperimentInput, ExperimentCollaboratorUncheckedUpdateWithoutExperimentInput>
    create: XOR<ExperimentCollaboratorCreateWithoutExperimentInput, ExperimentCollaboratorUncheckedCreateWithoutExperimentInput>
  }

  export type ExperimentCollaboratorUpdateWithWhereUniqueWithoutExperimentInput = {
    where: ExperimentCollaboratorWhereUniqueInput
    data: XOR<ExperimentCollaboratorUpdateWithoutExperimentInput, ExperimentCollaboratorUncheckedUpdateWithoutExperimentInput>
  }

  export type ExperimentCollaboratorUpdateManyWithWhereWithoutExperimentInput = {
    where: ExperimentCollaboratorScalarWhereInput
    data: XOR<ExperimentCollaboratorUpdateManyMutationInput, ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentInput>
  }

  export type ExperimentCollaboratorScalarWhereInput = {
    AND?: ExperimentCollaboratorScalarWhereInput | ExperimentCollaboratorScalarWhereInput[]
    OR?: ExperimentCollaboratorScalarWhereInput[]
    NOT?: ExperimentCollaboratorScalarWhereInput | ExperimentCollaboratorScalarWhereInput[]
    id?: StringFilter<"ExperimentCollaborator"> | string
    experimentId?: StringFilter<"ExperimentCollaborator"> | string
    userId?: StringFilter<"ExperimentCollaborator"> | string
    role?: StringFilter<"ExperimentCollaborator"> | string
    permissions?: JsonFilter<"ExperimentCollaborator">
    invitedBy?: StringNullableFilter<"ExperimentCollaborator"> | string | null
    acceptedAt?: DateTimeNullableFilter<"ExperimentCollaborator"> | Date | string | null
    createdAt?: DateTimeFilter<"ExperimentCollaborator"> | Date | string
  }

  export type ExperimentAuditLogUpsertWithWhereUniqueWithoutExperimentInput = {
    where: ExperimentAuditLogWhereUniqueInput
    update: XOR<ExperimentAuditLogUpdateWithoutExperimentInput, ExperimentAuditLogUncheckedUpdateWithoutExperimentInput>
    create: XOR<ExperimentAuditLogCreateWithoutExperimentInput, ExperimentAuditLogUncheckedCreateWithoutExperimentInput>
  }

  export type ExperimentAuditLogUpdateWithWhereUniqueWithoutExperimentInput = {
    where: ExperimentAuditLogWhereUniqueInput
    data: XOR<ExperimentAuditLogUpdateWithoutExperimentInput, ExperimentAuditLogUncheckedUpdateWithoutExperimentInput>
  }

  export type ExperimentAuditLogUpdateManyWithWhereWithoutExperimentInput = {
    where: ExperimentAuditLogScalarWhereInput
    data: XOR<ExperimentAuditLogUpdateManyMutationInput, ExperimentAuditLogUncheckedUpdateManyWithoutExperimentInput>
  }

  export type ExperimentAuditLogScalarWhereInput = {
    AND?: ExperimentAuditLogScalarWhereInput | ExperimentAuditLogScalarWhereInput[]
    OR?: ExperimentAuditLogScalarWhereInput[]
    NOT?: ExperimentAuditLogScalarWhereInput | ExperimentAuditLogScalarWhereInput[]
    id?: StringFilter<"ExperimentAuditLog"> | string
    experimentId?: StringNullableFilter<"ExperimentAuditLog"> | string | null
    entityType?: StringFilter<"ExperimentAuditLog"> | string
    entityId?: StringFilter<"ExperimentAuditLog"> | string
    action?: StringFilter<"ExperimentAuditLog"> | string
    oldValues?: JsonNullableFilter<"ExperimentAuditLog">
    newValues?: JsonNullableFilter<"ExperimentAuditLog">
    changedBy?: StringFilter<"ExperimentAuditLog"> | string
    changedAt?: DateTimeFilter<"ExperimentAuditLog"> | Date | string
    ipAddress?: StringNullableFilter<"ExperimentAuditLog"> | string | null
    userAgent?: StringNullableFilter<"ExperimentAuditLog"> | string | null
  }

  export type PlantingUpsertWithWhereUniqueWithoutExperimentInput = {
    where: PlantingWhereUniqueInput
    update: XOR<PlantingUpdateWithoutExperimentInput, PlantingUncheckedUpdateWithoutExperimentInput>
    create: XOR<PlantingCreateWithoutExperimentInput, PlantingUncheckedCreateWithoutExperimentInput>
  }

  export type PlantingUpdateWithWhereUniqueWithoutExperimentInput = {
    where: PlantingWhereUniqueInput
    data: XOR<PlantingUpdateWithoutExperimentInput, PlantingUncheckedUpdateWithoutExperimentInput>
  }

  export type PlantingUpdateManyWithWhereWithoutExperimentInput = {
    where: PlantingScalarWhereInput
    data: XOR<PlantingUpdateManyMutationInput, PlantingUncheckedUpdateManyWithoutExperimentInput>
  }

  export type ExperimentCreateWithoutProtocolsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    plots?: ResearchPlotCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogCreateNestedManyWithoutExperimentInput
    samples?: LabSampleCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogCreateNestedManyWithoutExperimentInput
    plantings?: PlantingCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUncheckedCreateWithoutProtocolsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    plots?: ResearchPlotUncheckedCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentUncheckedCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutExperimentInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorUncheckedCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogUncheckedCreateNestedManyWithoutExperimentInput
    plantings?: PlantingUncheckedCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentCreateOrConnectWithoutProtocolsInput = {
    where: ExperimentWhereUniqueInput
    create: XOR<ExperimentCreateWithoutProtocolsInput, ExperimentUncheckedCreateWithoutProtocolsInput>
  }

  export type ExperimentUpsertWithoutProtocolsInput = {
    update: XOR<ExperimentUpdateWithoutProtocolsInput, ExperimentUncheckedUpdateWithoutProtocolsInput>
    create: XOR<ExperimentCreateWithoutProtocolsInput, ExperimentUncheckedCreateWithoutProtocolsInput>
    where?: ExperimentWhereInput
  }

  export type ExperimentUpdateToOneWithWhereWithoutProtocolsInput = {
    where?: ExperimentWhereInput
    data: XOR<ExperimentUpdateWithoutProtocolsInput, ExperimentUncheckedUpdateWithoutProtocolsInput>
  }

  export type ExperimentUpdateWithoutProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    plots?: ResearchPlotUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentUncheckedUpdateWithoutProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    plots?: ResearchPlotUncheckedUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUncheckedUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUncheckedUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUncheckedUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentCreateWithoutPlotsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogCreateNestedManyWithoutExperimentInput
    samples?: LabSampleCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogCreateNestedManyWithoutExperimentInput
    plantings?: PlantingCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUncheckedCreateWithoutPlotsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolUncheckedCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentUncheckedCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutExperimentInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorUncheckedCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogUncheckedCreateNestedManyWithoutExperimentInput
    plantings?: PlantingUncheckedCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentCreateOrConnectWithoutPlotsInput = {
    where: ExperimentWhereUniqueInput
    create: XOR<ExperimentCreateWithoutPlotsInput, ExperimentUncheckedCreateWithoutPlotsInput>
  }

  export type TreatmentCreateWithoutPlotInput = {
    id?: string
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutTreatmentsInput
    logs?: ResearchDailyLogCreateNestedManyWithoutTreatmentInput
  }

  export type TreatmentUncheckedCreateWithoutPlotInput = {
    id?: string
    experimentId: string
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutTreatmentInput
  }

  export type TreatmentCreateOrConnectWithoutPlotInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutPlotInput, TreatmentUncheckedCreateWithoutPlotInput>
  }

  export type TreatmentCreateManyPlotInputEnvelope = {
    data: TreatmentCreateManyPlotInput | TreatmentCreateManyPlotInput[]
    skipDuplicates?: boolean
  }

  export type ResearchDailyLogCreateWithoutPlotInput = {
    id?: string
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutLogsInput
    treatment?: TreatmentCreateNestedOneWithoutLogsInput
    samples?: LabSampleCreateNestedManyWithoutLogInput
  }

  export type ResearchDailyLogUncheckedCreateWithoutPlotInput = {
    id?: string
    experimentId: string
    treatmentId?: string | null
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: LabSampleUncheckedCreateNestedManyWithoutLogInput
  }

  export type ResearchDailyLogCreateOrConnectWithoutPlotInput = {
    where: ResearchDailyLogWhereUniqueInput
    create: XOR<ResearchDailyLogCreateWithoutPlotInput, ResearchDailyLogUncheckedCreateWithoutPlotInput>
  }

  export type ResearchDailyLogCreateManyPlotInputEnvelope = {
    data: ResearchDailyLogCreateManyPlotInput | ResearchDailyLogCreateManyPlotInput[]
    skipDuplicates?: boolean
  }

  export type LabSampleCreateWithoutPlotInput = {
    id?: string
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutSamplesInput
    log?: ResearchDailyLogCreateNestedOneWithoutSamplesInput
  }

  export type LabSampleUncheckedCreateWithoutPlotInput = {
    id?: string
    experimentId: string
    logId?: string | null
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabSampleCreateOrConnectWithoutPlotInput = {
    where: LabSampleWhereUniqueInput
    create: XOR<LabSampleCreateWithoutPlotInput, LabSampleUncheckedCreateWithoutPlotInput>
  }

  export type LabSampleCreateManyPlotInputEnvelope = {
    data: LabSampleCreateManyPlotInput | LabSampleCreateManyPlotInput[]
    skipDuplicates?: boolean
  }

  export type ExperimentUpsertWithoutPlotsInput = {
    update: XOR<ExperimentUpdateWithoutPlotsInput, ExperimentUncheckedUpdateWithoutPlotsInput>
    create: XOR<ExperimentCreateWithoutPlotsInput, ExperimentUncheckedCreateWithoutPlotsInput>
    where?: ExperimentWhereInput
  }

  export type ExperimentUpdateToOneWithWhereWithoutPlotsInput = {
    where?: ExperimentWhereInput
    data: XOR<ExperimentUpdateWithoutPlotsInput, ExperimentUncheckedUpdateWithoutPlotsInput>
  }

  export type ExperimentUpdateWithoutPlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentUncheckedUpdateWithoutPlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUncheckedUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUncheckedUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUncheckedUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUncheckedUpdateManyWithoutExperimentNestedInput
  }

  export type TreatmentUpsertWithWhereUniqueWithoutPlotInput = {
    where: TreatmentWhereUniqueInput
    update: XOR<TreatmentUpdateWithoutPlotInput, TreatmentUncheckedUpdateWithoutPlotInput>
    create: XOR<TreatmentCreateWithoutPlotInput, TreatmentUncheckedCreateWithoutPlotInput>
  }

  export type TreatmentUpdateWithWhereUniqueWithoutPlotInput = {
    where: TreatmentWhereUniqueInput
    data: XOR<TreatmentUpdateWithoutPlotInput, TreatmentUncheckedUpdateWithoutPlotInput>
  }

  export type TreatmentUpdateManyWithWhereWithoutPlotInput = {
    where: TreatmentScalarWhereInput
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyWithoutPlotInput>
  }

  export type ResearchDailyLogUpsertWithWhereUniqueWithoutPlotInput = {
    where: ResearchDailyLogWhereUniqueInput
    update: XOR<ResearchDailyLogUpdateWithoutPlotInput, ResearchDailyLogUncheckedUpdateWithoutPlotInput>
    create: XOR<ResearchDailyLogCreateWithoutPlotInput, ResearchDailyLogUncheckedCreateWithoutPlotInput>
  }

  export type ResearchDailyLogUpdateWithWhereUniqueWithoutPlotInput = {
    where: ResearchDailyLogWhereUniqueInput
    data: XOR<ResearchDailyLogUpdateWithoutPlotInput, ResearchDailyLogUncheckedUpdateWithoutPlotInput>
  }

  export type ResearchDailyLogUpdateManyWithWhereWithoutPlotInput = {
    where: ResearchDailyLogScalarWhereInput
    data: XOR<ResearchDailyLogUpdateManyMutationInput, ResearchDailyLogUncheckedUpdateManyWithoutPlotInput>
  }

  export type LabSampleUpsertWithWhereUniqueWithoutPlotInput = {
    where: LabSampleWhereUniqueInput
    update: XOR<LabSampleUpdateWithoutPlotInput, LabSampleUncheckedUpdateWithoutPlotInput>
    create: XOR<LabSampleCreateWithoutPlotInput, LabSampleUncheckedCreateWithoutPlotInput>
  }

  export type LabSampleUpdateWithWhereUniqueWithoutPlotInput = {
    where: LabSampleWhereUniqueInput
    data: XOR<LabSampleUpdateWithoutPlotInput, LabSampleUncheckedUpdateWithoutPlotInput>
  }

  export type LabSampleUpdateManyWithWhereWithoutPlotInput = {
    where: LabSampleScalarWhereInput
    data: XOR<LabSampleUpdateManyMutationInput, LabSampleUncheckedUpdateManyWithoutPlotInput>
  }

  export type ExperimentCreateWithoutTreatmentsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogCreateNestedManyWithoutExperimentInput
    samples?: LabSampleCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogCreateNestedManyWithoutExperimentInput
    plantings?: PlantingCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUncheckedCreateWithoutTreatmentsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolUncheckedCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotUncheckedCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutExperimentInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorUncheckedCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogUncheckedCreateNestedManyWithoutExperimentInput
    plantings?: PlantingUncheckedCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentCreateOrConnectWithoutTreatmentsInput = {
    where: ExperimentWhereUniqueInput
    create: XOR<ExperimentCreateWithoutTreatmentsInput, ExperimentUncheckedCreateWithoutTreatmentsInput>
  }

  export type ResearchPlotCreateWithoutTreatmentsInput = {
    id?: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutPlotsInput
    logs?: ResearchDailyLogCreateNestedManyWithoutPlotInput
    samples?: LabSampleCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotUncheckedCreateWithoutTreatmentsInput = {
    id?: string
    experimentId: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutPlotInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotCreateOrConnectWithoutTreatmentsInput = {
    where: ResearchPlotWhereUniqueInput
    create: XOR<ResearchPlotCreateWithoutTreatmentsInput, ResearchPlotUncheckedCreateWithoutTreatmentsInput>
  }

  export type ResearchDailyLogCreateWithoutTreatmentInput = {
    id?: string
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutLogsInput
    plot?: ResearchPlotCreateNestedOneWithoutLogsInput
    samples?: LabSampleCreateNestedManyWithoutLogInput
  }

  export type ResearchDailyLogUncheckedCreateWithoutTreatmentInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: LabSampleUncheckedCreateNestedManyWithoutLogInput
  }

  export type ResearchDailyLogCreateOrConnectWithoutTreatmentInput = {
    where: ResearchDailyLogWhereUniqueInput
    create: XOR<ResearchDailyLogCreateWithoutTreatmentInput, ResearchDailyLogUncheckedCreateWithoutTreatmentInput>
  }

  export type ResearchDailyLogCreateManyTreatmentInputEnvelope = {
    data: ResearchDailyLogCreateManyTreatmentInput | ResearchDailyLogCreateManyTreatmentInput[]
    skipDuplicates?: boolean
  }

  export type ExperimentUpsertWithoutTreatmentsInput = {
    update: XOR<ExperimentUpdateWithoutTreatmentsInput, ExperimentUncheckedUpdateWithoutTreatmentsInput>
    create: XOR<ExperimentCreateWithoutTreatmentsInput, ExperimentUncheckedCreateWithoutTreatmentsInput>
    where?: ExperimentWhereInput
  }

  export type ExperimentUpdateToOneWithWhereWithoutTreatmentsInput = {
    where?: ExperimentWhereInput
    data: XOR<ExperimentUpdateWithoutTreatmentsInput, ExperimentUncheckedUpdateWithoutTreatmentsInput>
  }

  export type ExperimentUpdateWithoutTreatmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentUncheckedUpdateWithoutTreatmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUncheckedUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUncheckedUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUncheckedUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUncheckedUpdateManyWithoutExperimentNestedInput
  }

  export type ResearchPlotUpsertWithoutTreatmentsInput = {
    update: XOR<ResearchPlotUpdateWithoutTreatmentsInput, ResearchPlotUncheckedUpdateWithoutTreatmentsInput>
    create: XOR<ResearchPlotCreateWithoutTreatmentsInput, ResearchPlotUncheckedCreateWithoutTreatmentsInput>
    where?: ResearchPlotWhereInput
  }

  export type ResearchPlotUpdateToOneWithWhereWithoutTreatmentsInput = {
    where?: ResearchPlotWhereInput
    data: XOR<ResearchPlotUpdateWithoutTreatmentsInput, ResearchPlotUncheckedUpdateWithoutTreatmentsInput>
  }

  export type ResearchPlotUpdateWithoutTreatmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutPlotsNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutPlotNestedInput
    samples?: LabSampleUpdateManyWithoutPlotNestedInput
  }

  export type ResearchPlotUncheckedUpdateWithoutTreatmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutPlotNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutPlotNestedInput
  }

  export type ResearchDailyLogUpsertWithWhereUniqueWithoutTreatmentInput = {
    where: ResearchDailyLogWhereUniqueInput
    update: XOR<ResearchDailyLogUpdateWithoutTreatmentInput, ResearchDailyLogUncheckedUpdateWithoutTreatmentInput>
    create: XOR<ResearchDailyLogCreateWithoutTreatmentInput, ResearchDailyLogUncheckedCreateWithoutTreatmentInput>
  }

  export type ResearchDailyLogUpdateWithWhereUniqueWithoutTreatmentInput = {
    where: ResearchDailyLogWhereUniqueInput
    data: XOR<ResearchDailyLogUpdateWithoutTreatmentInput, ResearchDailyLogUncheckedUpdateWithoutTreatmentInput>
  }

  export type ResearchDailyLogUpdateManyWithWhereWithoutTreatmentInput = {
    where: ResearchDailyLogScalarWhereInput
    data: XOR<ResearchDailyLogUpdateManyMutationInput, ResearchDailyLogUncheckedUpdateManyWithoutTreatmentInput>
  }

  export type ExperimentCreateWithoutLogsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentCreateNestedManyWithoutExperimentInput
    samples?: LabSampleCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogCreateNestedManyWithoutExperimentInput
    plantings?: PlantingCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUncheckedCreateWithoutLogsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolUncheckedCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotUncheckedCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentUncheckedCreateNestedManyWithoutExperimentInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorUncheckedCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogUncheckedCreateNestedManyWithoutExperimentInput
    plantings?: PlantingUncheckedCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentCreateOrConnectWithoutLogsInput = {
    where: ExperimentWhereUniqueInput
    create: XOR<ExperimentCreateWithoutLogsInput, ExperimentUncheckedCreateWithoutLogsInput>
  }

  export type ResearchPlotCreateWithoutLogsInput = {
    id?: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutPlotsInput
    treatments?: TreatmentCreateNestedManyWithoutPlotInput
    samples?: LabSampleCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotUncheckedCreateWithoutLogsInput = {
    id?: string
    experimentId: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    treatments?: TreatmentUncheckedCreateNestedManyWithoutPlotInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotCreateOrConnectWithoutLogsInput = {
    where: ResearchPlotWhereUniqueInput
    create: XOR<ResearchPlotCreateWithoutLogsInput, ResearchPlotUncheckedCreateWithoutLogsInput>
  }

  export type TreatmentCreateWithoutLogsInput = {
    id?: string
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutTreatmentsInput
    plot?: ResearchPlotCreateNestedOneWithoutTreatmentsInput
  }

  export type TreatmentUncheckedCreateWithoutLogsInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TreatmentCreateOrConnectWithoutLogsInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutLogsInput, TreatmentUncheckedCreateWithoutLogsInput>
  }

  export type LabSampleCreateWithoutLogInput = {
    id?: string
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutSamplesInput
    plot?: ResearchPlotCreateNestedOneWithoutSamplesInput
  }

  export type LabSampleUncheckedCreateWithoutLogInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabSampleCreateOrConnectWithoutLogInput = {
    where: LabSampleWhereUniqueInput
    create: XOR<LabSampleCreateWithoutLogInput, LabSampleUncheckedCreateWithoutLogInput>
  }

  export type LabSampleCreateManyLogInputEnvelope = {
    data: LabSampleCreateManyLogInput | LabSampleCreateManyLogInput[]
    skipDuplicates?: boolean
  }

  export type ExperimentUpsertWithoutLogsInput = {
    update: XOR<ExperimentUpdateWithoutLogsInput, ExperimentUncheckedUpdateWithoutLogsInput>
    create: XOR<ExperimentCreateWithoutLogsInput, ExperimentUncheckedCreateWithoutLogsInput>
    where?: ExperimentWhereInput
  }

  export type ExperimentUpdateToOneWithWhereWithoutLogsInput = {
    where?: ExperimentWhereInput
    data: XOR<ExperimentUpdateWithoutLogsInput, ExperimentUncheckedUpdateWithoutLogsInput>
  }

  export type ExperimentUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUncheckedUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUncheckedUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUncheckedUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUncheckedUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUncheckedUpdateManyWithoutExperimentNestedInput
  }

  export type ResearchPlotUpsertWithoutLogsInput = {
    update: XOR<ResearchPlotUpdateWithoutLogsInput, ResearchPlotUncheckedUpdateWithoutLogsInput>
    create: XOR<ResearchPlotCreateWithoutLogsInput, ResearchPlotUncheckedCreateWithoutLogsInput>
    where?: ResearchPlotWhereInput
  }

  export type ResearchPlotUpdateToOneWithWhereWithoutLogsInput = {
    where?: ResearchPlotWhereInput
    data: XOR<ResearchPlotUpdateWithoutLogsInput, ResearchPlotUncheckedUpdateWithoutLogsInput>
  }

  export type ResearchPlotUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutPlotsNestedInput
    treatments?: TreatmentUpdateManyWithoutPlotNestedInput
    samples?: LabSampleUpdateManyWithoutPlotNestedInput
  }

  export type ResearchPlotUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treatments?: TreatmentUncheckedUpdateManyWithoutPlotNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutPlotNestedInput
  }

  export type TreatmentUpsertWithoutLogsInput = {
    update: XOR<TreatmentUpdateWithoutLogsInput, TreatmentUncheckedUpdateWithoutLogsInput>
    create: XOR<TreatmentCreateWithoutLogsInput, TreatmentUncheckedCreateWithoutLogsInput>
    where?: TreatmentWhereInput
  }

  export type TreatmentUpdateToOneWithWhereWithoutLogsInput = {
    where?: TreatmentWhereInput
    data: XOR<TreatmentUpdateWithoutLogsInput, TreatmentUncheckedUpdateWithoutLogsInput>
  }

  export type TreatmentUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutTreatmentsNestedInput
    plot?: ResearchPlotUpdateOneWithoutTreatmentsNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleUpsertWithWhereUniqueWithoutLogInput = {
    where: LabSampleWhereUniqueInput
    update: XOR<LabSampleUpdateWithoutLogInput, LabSampleUncheckedUpdateWithoutLogInput>
    create: XOR<LabSampleCreateWithoutLogInput, LabSampleUncheckedCreateWithoutLogInput>
  }

  export type LabSampleUpdateWithWhereUniqueWithoutLogInput = {
    where: LabSampleWhereUniqueInput
    data: XOR<LabSampleUpdateWithoutLogInput, LabSampleUncheckedUpdateWithoutLogInput>
  }

  export type LabSampleUpdateManyWithWhereWithoutLogInput = {
    where: LabSampleScalarWhereInput
    data: XOR<LabSampleUpdateManyMutationInput, LabSampleUncheckedUpdateManyWithoutLogInput>
  }

  export type ExperimentCreateWithoutSamplesInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogCreateNestedManyWithoutExperimentInput
    plantings?: PlantingCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUncheckedCreateWithoutSamplesInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolUncheckedCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotUncheckedCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentUncheckedCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorUncheckedCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogUncheckedCreateNestedManyWithoutExperimentInput
    plantings?: PlantingUncheckedCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentCreateOrConnectWithoutSamplesInput = {
    where: ExperimentWhereUniqueInput
    create: XOR<ExperimentCreateWithoutSamplesInput, ExperimentUncheckedCreateWithoutSamplesInput>
  }

  export type ResearchPlotCreateWithoutSamplesInput = {
    id?: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutPlotsInput
    treatments?: TreatmentCreateNestedManyWithoutPlotInput
    logs?: ResearchDailyLogCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotUncheckedCreateWithoutSamplesInput = {
    id?: string
    experimentId: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    treatments?: TreatmentUncheckedCreateNestedManyWithoutPlotInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutPlotInput
  }

  export type ResearchPlotCreateOrConnectWithoutSamplesInput = {
    where: ResearchPlotWhereUniqueInput
    create: XOR<ResearchPlotCreateWithoutSamplesInput, ResearchPlotUncheckedCreateWithoutSamplesInput>
  }

  export type ResearchDailyLogCreateWithoutSamplesInput = {
    id?: string
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    experiment: ExperimentCreateNestedOneWithoutLogsInput
    plot?: ResearchPlotCreateNestedOneWithoutLogsInput
    treatment?: TreatmentCreateNestedOneWithoutLogsInput
  }

  export type ResearchDailyLogUncheckedCreateWithoutSamplesInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    treatmentId?: string | null
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchDailyLogCreateOrConnectWithoutSamplesInput = {
    where: ResearchDailyLogWhereUniqueInput
    create: XOR<ResearchDailyLogCreateWithoutSamplesInput, ResearchDailyLogUncheckedCreateWithoutSamplesInput>
  }

  export type ExperimentUpsertWithoutSamplesInput = {
    update: XOR<ExperimentUpdateWithoutSamplesInput, ExperimentUncheckedUpdateWithoutSamplesInput>
    create: XOR<ExperimentCreateWithoutSamplesInput, ExperimentUncheckedCreateWithoutSamplesInput>
    where?: ExperimentWhereInput
  }

  export type ExperimentUpdateToOneWithWhereWithoutSamplesInput = {
    where?: ExperimentWhereInput
    data: XOR<ExperimentUpdateWithoutSamplesInput, ExperimentUncheckedUpdateWithoutSamplesInput>
  }

  export type ExperimentUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentUncheckedUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUncheckedUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUncheckedUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUncheckedUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUncheckedUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUncheckedUpdateManyWithoutExperimentNestedInput
  }

  export type ResearchPlotUpsertWithoutSamplesInput = {
    update: XOR<ResearchPlotUpdateWithoutSamplesInput, ResearchPlotUncheckedUpdateWithoutSamplesInput>
    create: XOR<ResearchPlotCreateWithoutSamplesInput, ResearchPlotUncheckedCreateWithoutSamplesInput>
    where?: ResearchPlotWhereInput
  }

  export type ResearchPlotUpdateToOneWithWhereWithoutSamplesInput = {
    where?: ResearchPlotWhereInput
    data: XOR<ResearchPlotUpdateWithoutSamplesInput, ResearchPlotUncheckedUpdateWithoutSamplesInput>
  }

  export type ResearchPlotUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutPlotsNestedInput
    treatments?: TreatmentUpdateManyWithoutPlotNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutPlotNestedInput
  }

  export type ResearchPlotUncheckedUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treatments?: TreatmentUncheckedUpdateManyWithoutPlotNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutPlotNestedInput
  }

  export type ResearchDailyLogUpsertWithoutSamplesInput = {
    update: XOR<ResearchDailyLogUpdateWithoutSamplesInput, ResearchDailyLogUncheckedUpdateWithoutSamplesInput>
    create: XOR<ResearchDailyLogCreateWithoutSamplesInput, ResearchDailyLogUncheckedCreateWithoutSamplesInput>
    where?: ResearchDailyLogWhereInput
  }

  export type ResearchDailyLogUpdateToOneWithWhereWithoutSamplesInput = {
    where?: ResearchDailyLogWhereInput
    data: XOR<ResearchDailyLogUpdateWithoutSamplesInput, ResearchDailyLogUncheckedUpdateWithoutSamplesInput>
  }

  export type ResearchDailyLogUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutLogsNestedInput
    plot?: ResearchPlotUpdateOneWithoutLogsNestedInput
    treatment?: TreatmentUpdateOneWithoutLogsNestedInput
  }

  export type ResearchDailyLogUncheckedUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentId?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentCreateWithoutCollaboratorsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogCreateNestedManyWithoutExperimentInput
    samples?: LabSampleCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogCreateNestedManyWithoutExperimentInput
    plantings?: PlantingCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUncheckedCreateWithoutCollaboratorsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolUncheckedCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotUncheckedCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentUncheckedCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutExperimentInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutExperimentInput
    auditLogs?: ExperimentAuditLogUncheckedCreateNestedManyWithoutExperimentInput
    plantings?: PlantingUncheckedCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentCreateOrConnectWithoutCollaboratorsInput = {
    where: ExperimentWhereUniqueInput
    create: XOR<ExperimentCreateWithoutCollaboratorsInput, ExperimentUncheckedCreateWithoutCollaboratorsInput>
  }

  export type ExperimentUpsertWithoutCollaboratorsInput = {
    update: XOR<ExperimentUpdateWithoutCollaboratorsInput, ExperimentUncheckedUpdateWithoutCollaboratorsInput>
    create: XOR<ExperimentCreateWithoutCollaboratorsInput, ExperimentUncheckedCreateWithoutCollaboratorsInput>
    where?: ExperimentWhereInput
  }

  export type ExperimentUpdateToOneWithWhereWithoutCollaboratorsInput = {
    where?: ExperimentWhereInput
    data: XOR<ExperimentUpdateWithoutCollaboratorsInput, ExperimentUncheckedUpdateWithoutCollaboratorsInput>
  }

  export type ExperimentUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentUncheckedUpdateWithoutCollaboratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUncheckedUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUncheckedUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUncheckedUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutExperimentNestedInput
    auditLogs?: ExperimentAuditLogUncheckedUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUncheckedUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentCreateWithoutAuditLogsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogCreateNestedManyWithoutExperimentInput
    samples?: LabSampleCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorCreateNestedManyWithoutExperimentInput
    plantings?: PlantingCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    title: string
    titleAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    hypothesis?: string | null
    hypothesisAr?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    status?: $Enums.ExperimentStatus
    lockedAt?: Date | string | null
    lockedBy?: string | null
    principalResearcherId: string
    organizationId?: string | null
    farmId?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: number
    protocols?: ResearchProtocolUncheckedCreateNestedManyWithoutExperimentInput
    plots?: ResearchPlotUncheckedCreateNestedManyWithoutExperimentInput
    treatments?: TreatmentUncheckedCreateNestedManyWithoutExperimentInput
    logs?: ResearchDailyLogUncheckedCreateNestedManyWithoutExperimentInput
    samples?: LabSampleUncheckedCreateNestedManyWithoutExperimentInput
    collaborators?: ExperimentCollaboratorUncheckedCreateNestedManyWithoutExperimentInput
    plantings?: PlantingUncheckedCreateNestedManyWithoutExperimentInput
  }

  export type ExperimentCreateOrConnectWithoutAuditLogsInput = {
    where: ExperimentWhereUniqueInput
    create: XOR<ExperimentCreateWithoutAuditLogsInput, ExperimentUncheckedCreateWithoutAuditLogsInput>
  }

  export type ExperimentUpsertWithoutAuditLogsInput = {
    update: XOR<ExperimentUpdateWithoutAuditLogsInput, ExperimentUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ExperimentCreateWithoutAuditLogsInput, ExperimentUncheckedCreateWithoutAuditLogsInput>
    where?: ExperimentWhereInput
  }

  export type ExperimentUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ExperimentWhereInput
    data: XOR<ExperimentUpdateWithoutAuditLogsInput, ExperimentUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ExperimentUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUpdateManyWithoutExperimentNestedInput
  }

  export type ExperimentUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesis?: NullableStringFieldUpdateOperationsInput | string | null
    hypothesisAr?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumExperimentStatusFieldUpdateOperationsInput | $Enums.ExperimentStatus
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    principalResearcherId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    farmId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    tags?: ExperimentUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    protocols?: ResearchProtocolUncheckedUpdateManyWithoutExperimentNestedInput
    plots?: ResearchPlotUncheckedUpdateManyWithoutExperimentNestedInput
    treatments?: TreatmentUncheckedUpdateManyWithoutExperimentNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutExperimentNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutExperimentNestedInput
    collaborators?: ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentNestedInput
    plantings?: PlantingUncheckedUpdateManyWithoutExperimentNestedInput
  }

  export type SeedLotCreateManyGermplasmInput = {
    id?: string
    lotNumber: string
    initialQuantity: Decimal | DecimalJsLike | number | string
    currentQuantity: Decimal | DecimalJsLike | number | string
    quantityUnit: string
    seedCount?: number | null
    thousandSeedWeight?: Decimal | DecimalJsLike | number | string | null
    qualityGrade?: $Enums.SeedQualityGrade
    germinationRate?: Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: Date | string | null
    purityPercentage?: Decimal | DecimalJsLike | number | string | null
    moistureContent?: Decimal | DecimalJsLike | number | string | null
    vigorIndex?: Decimal | DecimalJsLike | number | string | null
    productionDate?: Date | string | null
    harvestDate?: Date | string | null
    productionLocation?: string | null
    productionSeason?: string | null
    producedBy?: string | null
    certificationNumber?: string | null
    certifiedBy?: string | null
    certificationDate?: Date | string | null
    expiryDate?: Date | string | null
    isTreated?: boolean
    treatmentType?: string | null
    treatmentProduct?: string | null
    treatmentDate?: Date | string | null
    storageLocation?: string | null
    storageConditions?: string | null
    notes?: string | null
    notesAr?: string | null
    photos?: SeedLotCreatephotosInput | string[]
    documents?: SeedLotCreatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantingCreateManyGermplasmInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    seedLotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeedLotUpdateWithoutGermplasmInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    initialQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFieldUpdateOperationsInput | string
    seedCount?: NullableIntFieldUpdateOperationsInput | number | null
    thousandSeedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFieldUpdateOperationsInput | $Enums.SeedQualityGrade
    germinationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purityPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moistureContent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    productionSeason?: NullableStringFieldUpdateOperationsInput | string | null
    producedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    treatmentType?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentProduct?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SeedLotUpdatephotosInput | string[]
    documents?: SeedLotUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantings?: PlantingUpdateManyWithoutSeedLotNestedInput
  }

  export type SeedLotUncheckedUpdateWithoutGermplasmInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    initialQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFieldUpdateOperationsInput | string
    seedCount?: NullableIntFieldUpdateOperationsInput | number | null
    thousandSeedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFieldUpdateOperationsInput | $Enums.SeedQualityGrade
    germinationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purityPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moistureContent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    productionSeason?: NullableStringFieldUpdateOperationsInput | string | null
    producedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    treatmentType?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentProduct?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SeedLotUpdatephotosInput | string[]
    documents?: SeedLotUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plantings?: PlantingUncheckedUpdateManyWithoutSeedLotNestedInput
  }

  export type SeedLotUncheckedUpdateManyWithoutGermplasmInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    initialQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantityUnit?: StringFieldUpdateOperationsInput | string
    seedCount?: NullableIntFieldUpdateOperationsInput | number | null
    thousandSeedWeight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityGrade?: EnumSeedQualityGradeFieldUpdateOperationsInput | $Enums.SeedQualityGrade
    germinationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    germinationTestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purityPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    moistureContent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vigorIndex?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harvestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    productionSeason?: NullableStringFieldUpdateOperationsInput | string | null
    producedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    certificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTreated?: BoolFieldUpdateOperationsInput | boolean
    treatmentType?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentProduct?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: SeedLotUpdatephotosInput | string[]
    documents?: SeedLotUpdatedocumentsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantingUpdateWithoutGermplasmInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutPlantingsNestedInput
    seedLot?: SeedLotUpdateOneWithoutPlantingsNestedInput
  }

  export type PlantingUncheckedUpdateWithoutGermplasmInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    seedLotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantingUncheckedUpdateManyWithoutGermplasmInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    seedLotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantingCreateManySeedLotInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    germplasmId: string
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlantingUpdateWithoutSeedLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutPlantingsNestedInput
    germplasm?: GermplasmUpdateOneRequiredWithoutPlantingsNestedInput
  }

  export type PlantingUncheckedUpdateWithoutSeedLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    germplasmId?: StringFieldUpdateOperationsInput | string
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantingUncheckedUpdateManyWithoutSeedLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    germplasmId?: StringFieldUpdateOperationsInput | string
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProtocolCreateManyExperimentInput = {
    id?: string
    name: string
    nameAr?: string | null
    description?: string | null
    descriptionAr?: string | null
    methodology: string
    methodologyAr?: string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolCreateequipmentRequiredInput | string[]
    safetyGuidelines?: string | null
    version?: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchPlotCreateManyExperimentInput = {
    id?: string
    plotCode: string
    name?: string | null
    nameAr?: string | null
    areaSqm?: Decimal | DecimalJsLike | number | string | null
    soilType?: string | null
    soilPh?: Decimal | DecimalJsLike | number | string | null
    previousCrop?: string | null
    replicateNumber?: number
    blockNumber?: number | null
    rowNumber?: number | null
    columnNumber?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TreatmentCreateManyExperimentInput = {
    id?: string
    plotId?: string | null
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchDailyLogCreateManyExperimentInput = {
    id?: string
    plotId?: string | null
    treatmentId?: string | null
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabSampleCreateManyExperimentInput = {
    id?: string
    plotId?: string | null
    logId?: string | null
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExperimentCollaboratorCreateManyExperimentInput = {
    id?: string
    userId: string
    role: string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    acceptedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ExperimentAuditLogCreateManyExperimentInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy: string
    changedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type PlantingCreateManyExperimentInput = {
    id?: string
    plotId?: string | null
    germplasmId: string
    seedLotId?: string | null
    plantingDate: Date | string
    plantingMethod?: string | null
    seedingRate?: Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: string | null
    seedsPerHill?: number | null
    seedDepth?: Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: string | null
    rowSpacing?: Decimal | DecimalJsLike | number | string | null
    plantSpacing?: Decimal | DecimalJsLike | number | string | null
    spacingUnit?: string | null
    plantedArea?: Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: string | null
    numberOfRows?: number | null
    plantsPerRow?: number | null
    totalPlantsExpected?: number | null
    germinationDate?: Date | string | null
    emergenceDate?: Date | string | null
    germinationCount?: number | null
    germinationPercentage?: Decimal | DecimalJsLike | number | string | null
    thinningDate?: Date | string | null
    finalPlantCount?: number | null
    plantedBy: string
    notes?: string | null
    notesAr?: string | null
    photos?: PlantingCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchProtocolUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: StringFieldUpdateOperationsInput | string
    methodologyAr?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolUpdateequipmentRequiredInput | string[]
    safetyGuidelines?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProtocolUncheckedUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: StringFieldUpdateOperationsInput | string
    methodologyAr?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolUpdateequipmentRequiredInput | string[]
    safetyGuidelines?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchProtocolUncheckedUpdateManyWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: StringFieldUpdateOperationsInput | string
    methodologyAr?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: JsonNullValueInput | InputJsonValue
    measurementSchedule?: JsonNullValueInput | InputJsonValue
    equipmentRequired?: ResearchProtocolUpdateequipmentRequiredInput | string[]
    safetyGuidelines?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchPlotUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treatments?: TreatmentUpdateManyWithoutPlotNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutPlotNestedInput
    samples?: LabSampleUpdateManyWithoutPlotNestedInput
  }

  export type ResearchPlotUncheckedUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treatments?: TreatmentUncheckedUpdateManyWithoutPlotNestedInput
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutPlotNestedInput
    samples?: LabSampleUncheckedUpdateManyWithoutPlotNestedInput
  }

  export type ResearchPlotUncheckedUpdateManyWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotCode?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    areaSqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    soilType?: NullableStringFieldUpdateOperationsInput | string | null
    soilPh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousCrop?: NullableStringFieldUpdateOperationsInput | string | null
    replicateNumber?: IntFieldUpdateOperationsInput | number
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    rowNumber?: NullableIntFieldUpdateOperationsInput | number | null
    columnNumber?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plot?: ResearchPlotUpdateOneWithoutTreatmentsNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateManyWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchDailyLogUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plot?: ResearchPlotUpdateOneWithoutLogsNestedInput
    treatment?: TreatmentUpdateOneWithoutLogsNestedInput
    samples?: LabSampleUpdateManyWithoutLogNestedInput
  }

  export type ResearchDailyLogUncheckedUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentId?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: LabSampleUncheckedUpdateManyWithoutLogNestedInput
  }

  export type ResearchDailyLogUncheckedUpdateManyWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    treatmentId?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plot?: ResearchPlotUpdateOneWithoutSamplesNestedInput
    log?: ResearchDailyLogUpdateOneWithoutSamplesNestedInput
  }

  export type LabSampleUncheckedUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    logId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleUncheckedUpdateManyWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    logId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentCollaboratorUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentCollaboratorUncheckedUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentCollaboratorUncheckedUpdateManyWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperimentAuditLogUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExperimentAuditLogUncheckedUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExperimentAuditLogUncheckedUpdateManyWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlantingUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    germplasm?: GermplasmUpdateOneRequiredWithoutPlantingsNestedInput
    seedLot?: SeedLotUpdateOneWithoutPlantingsNestedInput
  }

  export type PlantingUncheckedUpdateWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    germplasmId?: StringFieldUpdateOperationsInput | string
    seedLotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantingUncheckedUpdateManyWithoutExperimentInput = {
    id?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    germplasmId?: StringFieldUpdateOperationsInput | string
    seedLotId?: NullableStringFieldUpdateOperationsInput | string | null
    plantingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plantingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    seedingRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedingRateUnit?: NullableStringFieldUpdateOperationsInput | string | null
    seedsPerHill?: NullableIntFieldUpdateOperationsInput | number | null
    seedDepth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    seedDepthUnit?: NullableStringFieldUpdateOperationsInput | string | null
    rowSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantSpacing?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    spacingUnit?: NullableStringFieldUpdateOperationsInput | string | null
    plantedArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plantedAreaUnit?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfRows?: NullableIntFieldUpdateOperationsInput | number | null
    plantsPerRow?: NullableIntFieldUpdateOperationsInput | number | null
    totalPlantsExpected?: NullableIntFieldUpdateOperationsInput | number | null
    germinationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emergenceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    germinationCount?: NullableIntFieldUpdateOperationsInput | number | null
    germinationPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalPlantCount?: NullableIntFieldUpdateOperationsInput | number | null
    plantedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    photos?: PlantingUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentCreateManyPlotInput = {
    id?: string
    experimentId: string
    treatmentCode: string
    name: string
    nameAr?: string | null
    type: $Enums.TreatmentType
    description?: string | null
    descriptionAr?: string | null
    dosage?: string | null
    dosageUnit?: string | null
    applicationMethod?: string | null
    applicationFrequency?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    isControl?: boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchDailyLogCreateManyPlotInput = {
    id?: string
    experimentId: string
    treatmentId?: string | null
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabSampleCreateManyPlotInput = {
    id?: string
    experimentId: string
    logId?: string | null
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TreatmentUpdateWithoutPlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutTreatmentsNestedInput
    logs?: ResearchDailyLogUpdateManyWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutPlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: ResearchDailyLogUncheckedUpdateManyWithoutTreatmentNestedInput
  }

  export type TreatmentUncheckedUpdateManyWithoutPlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    treatmentCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameAr?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTreatmentTypeFieldUpdateOperationsInput | $Enums.TreatmentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    dosageUnit?: NullableStringFieldUpdateOperationsInput | string | null
    applicationMethod?: NullableStringFieldUpdateOperationsInput | string | null
    applicationFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isControl?: BoolFieldUpdateOperationsInput | boolean
    parameters?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchDailyLogUpdateWithoutPlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutLogsNestedInput
    treatment?: TreatmentUpdateOneWithoutLogsNestedInput
    samples?: LabSampleUpdateManyWithoutLogNestedInput
  }

  export type ResearchDailyLogUncheckedUpdateWithoutPlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    treatmentId?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: LabSampleUncheckedUpdateManyWithoutLogNestedInput
  }

  export type ResearchDailyLogUncheckedUpdateManyWithoutPlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    treatmentId?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleUpdateWithoutPlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutSamplesNestedInput
    log?: ResearchDailyLogUpdateOneWithoutSamplesNestedInput
  }

  export type LabSampleUncheckedUpdateWithoutPlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    logId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleUncheckedUpdateManyWithoutPlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    logId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchDailyLogCreateManyTreatmentInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    logDate: Date | string
    logTime?: string | null
    category: $Enums.LogCategory
    title: string
    titleAr?: string | null
    notes?: string | null
    notesAr?: string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogCreatephotosInput | string[]
    attachments?: ResearchDailyLogCreateattachmentsInput | string[]
    recordedBy: string
    deviceId?: string | null
    offlineId?: string | null
    hash?: string | null
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchDailyLogUpdateWithoutTreatmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutLogsNestedInput
    plot?: ResearchPlotUpdateOneWithoutLogsNestedInput
    samples?: LabSampleUpdateManyWithoutLogNestedInput
  }

  export type ResearchDailyLogUncheckedUpdateWithoutTreatmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: LabSampleUncheckedUpdateManyWithoutLogNestedInput
  }

  export type ResearchDailyLogUncheckedUpdateManyWithoutTreatmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logTime?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    title?: StringFieldUpdateOperationsInput | string
    titleAr?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    notesAr?: NullableStringFieldUpdateOperationsInput | string | null
    measurements?: JsonNullValueInput | InputJsonValue
    weatherConditions?: JsonNullValueInput | InputJsonValue
    photos?: ResearchDailyLogUpdatephotosInput | string[]
    attachments?: ResearchDailyLogUpdateattachmentsInput | string[]
    recordedBy?: StringFieldUpdateOperationsInput | string
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    offlineId?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleCreateManyLogInput = {
    id?: string
    experimentId: string
    plotId?: string | null
    sampleCode: string
    type: $Enums.SampleType
    description?: string | null
    descriptionAr?: string | null
    collectionDate: Date | string
    collectionTime?: string | null
    collectedBy: string
    storageLocation?: string | null
    storageConditions?: string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    quantityUnit?: string | null
    analysisStatus?: string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: string | null
    analyzedAt?: Date | string | null
    photos?: LabSampleCreatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabSampleUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiment?: ExperimentUpdateOneRequiredWithoutSamplesNestedInput
    plot?: ResearchPlotUpdateOneWithoutSamplesNestedInput
  }

  export type LabSampleUncheckedUpdateWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabSampleUncheckedUpdateManyWithoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    experimentId?: StringFieldUpdateOperationsInput | string
    plotId?: NullableStringFieldUpdateOperationsInput | string | null
    sampleCode?: StringFieldUpdateOperationsInput | string
    type?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAr?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionTime?: NullableStringFieldUpdateOperationsInput | string | null
    collectedBy?: StringFieldUpdateOperationsInput | string
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    storageConditions?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantityUnit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisStatus?: StringFieldUpdateOperationsInput | string
    analysisResults?: JsonNullValueInput | InputJsonValue
    analyzedBy?: NullableStringFieldUpdateOperationsInput | string | null
    analyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: LabSampleUpdatephotosInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use GermplasmCountOutputTypeDefaultArgs instead
     */
    export type GermplasmCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GermplasmCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeedLotCountOutputTypeDefaultArgs instead
     */
    export type SeedLotCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeedLotCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExperimentCountOutputTypeDefaultArgs instead
     */
    export type ExperimentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExperimentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResearchPlotCountOutputTypeDefaultArgs instead
     */
    export type ResearchPlotCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResearchPlotCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TreatmentCountOutputTypeDefaultArgs instead
     */
    export type TreatmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TreatmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResearchDailyLogCountOutputTypeDefaultArgs instead
     */
    export type ResearchDailyLogCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResearchDailyLogCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GermplasmDefaultArgs instead
     */
    export type GermplasmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GermplasmDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeedLotDefaultArgs instead
     */
    export type SeedLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeedLotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlantingDefaultArgs instead
     */
    export type PlantingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlantingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExperimentDefaultArgs instead
     */
    export type ExperimentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExperimentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResearchProtocolDefaultArgs instead
     */
    export type ResearchProtocolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResearchProtocolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResearchPlotDefaultArgs instead
     */
    export type ResearchPlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResearchPlotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TreatmentDefaultArgs instead
     */
    export type TreatmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TreatmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResearchDailyLogDefaultArgs instead
     */
    export type ResearchDailyLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResearchDailyLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabSampleDefaultArgs instead
     */
    export type LabSampleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabSampleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DigitalSignatureDefaultArgs instead
     */
    export type DigitalSignatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DigitalSignatureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExperimentCollaboratorDefaultArgs instead
     */
    export type ExperimentCollaboratorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExperimentCollaboratorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExperimentAuditLogDefaultArgs instead
     */
    export type ExperimentAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExperimentAuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}